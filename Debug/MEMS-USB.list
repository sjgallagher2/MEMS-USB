
/home/sam/Documents/Electronics/Projects/ARM/MEMS-USB/Debug/MEMS-USB.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000034d4  08000194  08000194  00010194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006c  08003668  08003668  00013668  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080036d4  080036d4  000136d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080036d8  080036d8  000136d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000001bc  20000000  080036dc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000900  200001bc  08003898  000201bc  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000abc  08003898  00020abc  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  000201bc  2**0
                  CONTENTS, READONLY
  9 .debug_info   00010610  00000000  00000000  000201ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002fe0  00000000  00000000  000307fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006ce4  00000000  00000000  000337dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000b08  00000000  00000000  0003a4c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000cf0  00000000  00000000  0003afc8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00004fbc  00000000  00000000  0003bcb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000038f4  00000000  00000000  00040c74  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  00044568  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00001ecc  00000000  00000000  000445e8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000194 <__do_global_dtors_aux>:
 8000194:	b510      	push	{r4, lr}
 8000196:	4c05      	ldr	r4, [pc, #20]	; (80001ac <__do_global_dtors_aux+0x18>)
 8000198:	7823      	ldrb	r3, [r4, #0]
 800019a:	b933      	cbnz	r3, 80001aa <__do_global_dtors_aux+0x16>
 800019c:	4b04      	ldr	r3, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x1c>)
 800019e:	b113      	cbz	r3, 80001a6 <__do_global_dtors_aux+0x12>
 80001a0:	4804      	ldr	r0, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x20>)
 80001a2:	f3af 8000 	nop.w
 80001a6:	2301      	movs	r3, #1
 80001a8:	7023      	strb	r3, [r4, #0]
 80001aa:	bd10      	pop	{r4, pc}
 80001ac:	200001bc 	.word	0x200001bc
 80001b0:	00000000 	.word	0x00000000
 80001b4:	08003650 	.word	0x08003650

080001b8 <frame_dummy>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	4b03      	ldr	r3, [pc, #12]	; (80001c8 <frame_dummy+0x10>)
 80001bc:	b11b      	cbz	r3, 80001c6 <frame_dummy+0xe>
 80001be:	4903      	ldr	r1, [pc, #12]	; (80001cc <frame_dummy+0x14>)
 80001c0:	4803      	ldr	r0, [pc, #12]	; (80001d0 <frame_dummy+0x18>)
 80001c2:	f3af 8000 	nop.w
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	200001c0 	.word	0x200001c0
 80001d0:	08003650 	.word	0x08003650

080001d4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80001d4:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 80001d6:	4b08      	ldr	r3, [pc, #32]	; (80001f8 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80001d8:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 80001da:	6818      	ldr	r0, [r3, #0]
 80001dc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80001e0:	fbb0 f0f3 	udiv	r0, r0, r3
 80001e4:	f000 f894 	bl	8000310 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80001e8:	2200      	movs	r2, #0
 80001ea:	4621      	mov	r1, r4
 80001ec:	f04f 30ff 	mov.w	r0, #4294967295
 80001f0:	f000 f84e 	bl	8000290 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80001f4:	2000      	movs	r0, #0
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20000110 	.word	0x20000110

080001fc <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80001fc:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80001fe:	4b0b      	ldr	r3, [pc, #44]	; (800022c <HAL_Init+0x30>)
 8000200:	681a      	ldr	r2, [r3, #0]
 8000202:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000206:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8000208:	681a      	ldr	r2, [r3, #0]
 800020a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800020e:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000210:	681a      	ldr	r2, [r3, #0]
 8000212:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000216:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000218:	2003      	movs	r0, #3
 800021a:	f000 f827 	bl	800026c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800021e:	2000      	movs	r0, #0
 8000220:	f7ff ffd8 	bl	80001d4 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8000224:	f002 fe5f 	bl	8002ee6 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8000228:	2000      	movs	r0, #0
 800022a:	bd08      	pop	{r3, pc}
 800022c:	40023c00 	.word	0x40023c00

08000230 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000230:	4a02      	ldr	r2, [pc, #8]	; (800023c <HAL_IncTick+0xc>)
 8000232:	6813      	ldr	r3, [r2, #0]
 8000234:	3301      	adds	r3, #1
 8000236:	6013      	str	r3, [r2, #0]
 8000238:	4770      	bx	lr
 800023a:	bf00      	nop
 800023c:	200001e8 	.word	0x200001e8

08000240 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000240:	4b01      	ldr	r3, [pc, #4]	; (8000248 <HAL_GetTick+0x8>)
 8000242:	6818      	ldr	r0, [r3, #0]
}
 8000244:	4770      	bx	lr
 8000246:	bf00      	nop
 8000248:	200001e8 	.word	0x200001e8

0800024c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800024c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800024e:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8000250:	f7ff fff6 	bl	8000240 <HAL_GetTick>
  uint32_t wait = Delay;
 8000254:	9c01      	ldr	r4, [sp, #4]
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000256:	1c63      	adds	r3, r4, #1
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
 8000258:	4605      	mov	r5, r0
  uint32_t wait = Delay;
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 800025a:	bf18      	it	ne
 800025c:	3401      	addne	r4, #1
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 800025e:	f7ff ffef 	bl	8000240 <HAL_GetTick>
 8000262:	1b40      	subs	r0, r0, r5
 8000264:	42a0      	cmp	r0, r4
 8000266:	d3fa      	bcc.n	800025e <HAL_Delay+0x12>
  {
  }
}
 8000268:	b003      	add	sp, #12
 800026a:	bd30      	pop	{r4, r5, pc}

0800026c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800026c:	4a07      	ldr	r2, [pc, #28]	; (800028c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800026e:	68d3      	ldr	r3, [r2, #12]
 8000270:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000274:	041b      	lsls	r3, r3, #16
 8000276:	0c1b      	lsrs	r3, r3, #16
 8000278:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800027c:	0200      	lsls	r0, r0, #8
 800027e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000282:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000286:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000288:	60d3      	str	r3, [r2, #12]
 800028a:	4770      	bx	lr
 800028c:	e000ed00 	.word	0xe000ed00

08000290 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000290:	4b17      	ldr	r3, [pc, #92]	; (80002f0 <HAL_NVIC_SetPriority+0x60>)
 8000292:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000294:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000298:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800029a:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800029e:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80002a0:	2c04      	cmp	r4, #4
 80002a2:	bf28      	it	cs
 80002a4:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80002a6:	2d06      	cmp	r5, #6

  return (
 80002a8:	f04f 0501 	mov.w	r5, #1
 80002ac:	fa05 f404 	lsl.w	r4, r5, r4
 80002b0:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80002b4:	bf8c      	ite	hi
 80002b6:	3b03      	subhi	r3, #3
 80002b8:	2300      	movls	r3, #0

  return (
 80002ba:	400c      	ands	r4, r1
 80002bc:	409c      	lsls	r4, r3
 80002be:	fa05 f303 	lsl.w	r3, r5, r3
 80002c2:	3b01      	subs	r3, #1
 80002c4:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80002c6:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80002c8:	ea42 0204 	orr.w	r2, r2, r4
 80002cc:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002d0:	bfaf      	iteee	ge
 80002d2:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002d6:	f000 000f 	andlt.w	r0, r0, #15
 80002da:	4b06      	ldrlt	r3, [pc, #24]	; (80002f4 <HAL_NVIC_SetPriority+0x64>)
 80002dc:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002de:	bfa5      	ittet	ge
 80002e0:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 80002e4:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002e6:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002e8:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 80002ec:	bd30      	pop	{r4, r5, pc}
 80002ee:	bf00      	nop
 80002f0:	e000ed00 	.word	0xe000ed00
 80002f4:	e000ed14 	.word	0xe000ed14

080002f8 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80002f8:	0942      	lsrs	r2, r0, #5
 80002fa:	2301      	movs	r3, #1
 80002fc:	f000 001f 	and.w	r0, r0, #31
 8000300:	fa03 f000 	lsl.w	r0, r3, r0
 8000304:	4b01      	ldr	r3, [pc, #4]	; (800030c <HAL_NVIC_EnableIRQ+0x14>)
 8000306:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800030a:	4770      	bx	lr
 800030c:	e000e100 	.word	0xe000e100

08000310 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000310:	3801      	subs	r0, #1
 8000312:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000316:	d20a      	bcs.n	800032e <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000318:	4b06      	ldr	r3, [pc, #24]	; (8000334 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800031a:	4a07      	ldr	r2, [pc, #28]	; (8000338 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800031c:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800031e:	21f0      	movs	r1, #240	; 0xf0
 8000320:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000324:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000326:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000328:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800032a:	601a      	str	r2, [r3, #0]
 800032c:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 800032e:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	e000e010 	.word	0xe000e010
 8000338:	e000ed00 	.word	0xe000ed00

0800033c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 800033c:	4b04      	ldr	r3, [pc, #16]	; (8000350 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800033e:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000340:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000342:	bf0c      	ite	eq
 8000344:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000348:	f022 0204 	bicne.w	r2, r2, #4
 800034c:	601a      	str	r2, [r3, #0]
 800034e:	4770      	bx	lr
 8000350:	e000e010 	.word	0xe000e010

08000354 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000354:	4770      	bx	lr

08000356 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000356:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000358:	f7ff fffc 	bl	8000354 <HAL_SYSTICK_Callback>
 800035c:	bd08      	pop	{r3, pc}
	...

08000360 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000364:	4f62      	ldr	r7, [pc, #392]	; (80004f0 <HAL_GPIO_Init+0x190>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000366:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000368:	f8df c18c 	ldr.w	ip, [pc, #396]	; 80004f8 <HAL_GPIO_Init+0x198>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800036c:	b085      	sub	sp, #20

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800036e:	f04f 0801 	mov.w	r8, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000372:	9301      	str	r3, [sp, #4]
 8000374:	46be      	mov	lr, r7
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000376:	2300      	movs	r3, #0
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000378:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800037a:	fa08 f503 	lsl.w	r5, r8, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 800037e:	ea35 0202 	bics.w	r2, r5, r2
 8000382:	f040 80ad 	bne.w	80004e0 <HAL_GPIO_Init+0x180>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000386:	684c      	ldr	r4, [r1, #4]
 8000388:	f024 0a10 	bic.w	sl, r4, #16
 800038c:	f1ba 0f02 	cmp.w	sl, #2
 8000390:	d114      	bne.n	80003bc <HAL_GPIO_Init+0x5c>
 8000392:	ea4f 09d3 	mov.w	r9, r3, lsr #3
 8000396:	eb00 0989 	add.w	r9, r0, r9, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800039a:	f003 0b07 	and.w	fp, r3, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800039e:	f8d9 6020 	ldr.w	r6, [r9, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80003a2:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 80003a6:	220f      	movs	r2, #15
 80003a8:	fa02 f20b 	lsl.w	r2, r2, fp
 80003ac:	ea26 0602 	bic.w	r6, r6, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80003b0:	690a      	ldr	r2, [r1, #16]
 80003b2:	fa02 f20b 	lsl.w	r2, r2, fp
 80003b6:	4332      	orrs	r2, r6
        GPIOx->AFR[position >> 3U] = temp;
 80003b8:	f8c9 2020 	str.w	r2, [r9, #32]
 80003bc:	ea4f 0b43 	mov.w	fp, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80003c0:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80003c4:	6802      	ldr	r2, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80003c6:	fa09 f90b 	lsl.w	r9, r9, fp
 80003ca:	ea6f 0909 	mvn.w	r9, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80003ce:	f004 0603 	and.w	r6, r4, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80003d2:	ea02 0209 	and.w	r2, r2, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80003d6:	fa06 f60b 	lsl.w	r6, r6, fp
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003da:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80003de:	4332      	orrs	r2, r6
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003e0:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 80003e4:	6002      	str	r2, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80003e6:	d80f      	bhi.n	8000408 <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80003e8:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 80003ea:	68ce      	ldr	r6, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80003ec:	ea09 0202 	and.w	r2, r9, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 80003f0:	fa06 f60b 	lsl.w	r6, r6, fp
 80003f4:	4316      	orrs	r6, r2
        GPIOx->OSPEEDR = temp;
 80003f6:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80003f8:	6842      	ldr	r2, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80003fa:	f3c4 1600 	ubfx	r6, r4, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80003fe:	ea22 0205 	bic.w	r2, r2, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000402:	409e      	lsls	r6, r3
 8000404:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 8000406:	6042      	str	r2, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000408:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800040a:	ea09 0902 	and.w	r9, r9, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800040e:	688a      	ldr	r2, [r1, #8]
 8000410:	fa02 f20b 	lsl.w	r2, r2, fp
 8000414:	ea42 0209 	orr.w	r2, r2, r9
      GPIOx->PUPDR = temp;
 8000418:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800041a:	00e2      	lsls	r2, r4, #3
 800041c:	d560      	bpl.n	80004e0 <HAL_GPIO_Init+0x180>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800041e:	2200      	movs	r2, #0
 8000420:	9203      	str	r2, [sp, #12]
 8000422:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000426:	4a33      	ldr	r2, [pc, #204]	; (80004f4 <HAL_GPIO_Init+0x194>)
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000428:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 800042c:	f8cc 6044 	str.w	r6, [ip, #68]	; 0x44
 8000430:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44
 8000434:	f023 0903 	bic.w	r9, r3, #3
 8000438:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 800043c:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000440:	f509 399c 	add.w	r9, r9, #79872	; 0x13800
 8000444:	9603      	str	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000446:	f003 0a03 	and.w	sl, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800044a:	9e03      	ldr	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 800044c:	f8d9 b008 	ldr.w	fp, [r9, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000450:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8000454:	260f      	movs	r6, #15
 8000456:	fa06 f60a 	lsl.w	r6, r6, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800045a:	4290      	cmp	r0, r2
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800045c:	ea2b 0606 	bic.w	r6, fp, r6
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000460:	d012      	beq.n	8000488 <HAL_GPIO_Init+0x128>
 8000462:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000466:	4290      	cmp	r0, r2
 8000468:	d010      	beq.n	800048c <HAL_GPIO_Init+0x12c>
 800046a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800046e:	4290      	cmp	r0, r2
 8000470:	d00e      	beq.n	8000490 <HAL_GPIO_Init+0x130>
 8000472:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000476:	4290      	cmp	r0, r2
 8000478:	d00c      	beq.n	8000494 <HAL_GPIO_Init+0x134>
 800047a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800047e:	4290      	cmp	r0, r2
 8000480:	bf14      	ite	ne
 8000482:	2207      	movne	r2, #7
 8000484:	2204      	moveq	r2, #4
 8000486:	e006      	b.n	8000496 <HAL_GPIO_Init+0x136>
 8000488:	2200      	movs	r2, #0
 800048a:	e004      	b.n	8000496 <HAL_GPIO_Init+0x136>
 800048c:	2201      	movs	r2, #1
 800048e:	e002      	b.n	8000496 <HAL_GPIO_Init+0x136>
 8000490:	2202      	movs	r2, #2
 8000492:	e000      	b.n	8000496 <HAL_GPIO_Init+0x136>
 8000494:	2203      	movs	r2, #3
 8000496:	fa02 f20a 	lsl.w	r2, r2, sl
 800049a:	4332      	orrs	r2, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 800049c:	f8c9 2008 	str.w	r2, [r9, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80004a0:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 80004a2:	43ee      	mvns	r6, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80004a4:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 80004a8:	bf0c      	ite	eq
 80004aa:	4032      	andeq	r2, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 80004ac:	432a      	orrne	r2, r5
        }
        EXTI->IMR = temp;
 80004ae:	f8ce 2000 	str.w	r2, [lr]

        temp = EXTI->EMR;
 80004b2:	f8de 2004 	ldr.w	r2, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80004b6:	f414 3f00 	tst.w	r4, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 80004ba:	bf0c      	ite	eq
 80004bc:	4032      	andeq	r2, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 80004be:	432a      	orrne	r2, r5
        }
        EXTI->EMR = temp;
 80004c0:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80004c2:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80004c4:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 80004c8:	bf0c      	ite	eq
 80004ca:	4032      	andeq	r2, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 80004cc:	432a      	orrne	r2, r5
        }
        EXTI->RTSR = temp;
 80004ce:	f8ce 2008 	str.w	r2, [lr, #8]

        temp = EXTI->FTSR;
 80004d2:	f8de 200c 	ldr.w	r2, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80004d6:	02a4      	lsls	r4, r4, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 80004d8:	bf54      	ite	pl
 80004da:	4032      	andpl	r2, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 80004dc:	432a      	orrmi	r2, r5
        }
        EXTI->FTSR = temp;
 80004de:	60fa      	str	r2, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80004e0:	3301      	adds	r3, #1
 80004e2:	2b10      	cmp	r3, #16
 80004e4:	f47f af48 	bne.w	8000378 <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 80004e8:	b005      	add	sp, #20
 80004ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80004ee:	bf00      	nop
 80004f0:	40013c00 	.word	0x40013c00
 80004f4:	40020000 	.word	0x40020000
 80004f8:	40023800 	.word	0x40023800

080004fc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80004fc:	b902      	cbnz	r2, 8000500 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80004fe:	0409      	lsls	r1, r1, #16
 8000500:	6181      	str	r1, [r0, #24]
 8000502:	4770      	bx	lr

08000504 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000504:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000506:	4606      	mov	r6, r0
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000508:	b08b      	sub	sp, #44	; 0x2c
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 800050a:	2800      	cmp	r0, #0
 800050c:	d063      	beq.n	80005d6 <HAL_PCD_Init+0xd2>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 800050e:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000510:	4634      	mov	r4, r6
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000512:	f880 33b9 	strb.w	r3, [r0, #953]	; 0x3b9
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8000516:	f002 fdcb 	bl	80030b0 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 800051a:	f854 0b10 	ldr.w	r0, [r4], #16
 800051e:	f001 f94c 	bl	80017ba <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000522:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000524:	466d      	mov	r5, sp
 8000526:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000528:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800052a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800052c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000530:	e885 0003 	stmia.w	r5, {r0, r1}
 8000534:	1d37      	adds	r7, r6, #4
 8000536:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800053a:	6830      	ldr	r0, [r6, #0]
 800053c:	f001 f8fd 	bl	800173a <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000540:	2100      	movs	r1, #0
 8000542:	6830      	ldr	r0, [r6, #0]
 8000544:	f001 f93f 	bl	80017c6 <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000548:	2100      	movs	r1, #0
 800054a:	4633      	mov	r3, r6
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 800054c:	4632      	mov	r2, r6
 800054e:	f106 0410 	add.w	r4, r6, #16
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000552:	2501      	movs	r5, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000554:	4608      	mov	r0, r1
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
   hpcd->IN_ep[i].num = i;
 8000556:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 800055a:	87d1      	strh	r1, [r2, #62]	; 0x3e
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 800055c:	3101      	adds	r1, #1
 800055e:	290f      	cmp	r1, #15
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000560:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000564:	f882 003b 	strb.w	r0, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8000568:	6410      	str	r0, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 800056a:	6450      	str	r0, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 800056c:	64d0      	str	r0, [r2, #76]	; 0x4c
 800056e:	f102 021c 	add.w	r2, r2, #28
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000572:	d1f0      	bne.n	8000556 <HAL_PCD_Init+0x52>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000574:	2200      	movs	r2, #0
 8000576:	f8d6 e000 	ldr.w	lr, [r6]
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 800057a:	4611      	mov	r1, r2
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 800057c:	f102 0040 	add.w	r0, r2, #64	; 0x40
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
   hpcd->OUT_ep[i].num = i;
 8000580:	f883 21f8 	strb.w	r2, [r3, #504]	; 0x1f8
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000584:	87da      	strh	r2, [r3, #62]	; 0x3e
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000586:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 800058a:	3201      	adds	r2, #1
 800058c:	2a0f      	cmp	r2, #15
 {
   hpcd->OUT_ep[i].is_in = 0U;
 800058e:	f883 11f9 	strb.w	r1, [r3, #505]	; 0x1f9
   hpcd->OUT_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000592:	f883 11fb 	strb.w	r1, [r3, #507]	; 0x1fb
   hpcd->OUT_ep[i].maxpacket = 0U;
 8000596:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
   hpcd->OUT_ep[i].xfer_buff = 0U;
 800059a:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
   hpcd->OUT_ep[i].xfer_len = 0U;
 800059e:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 80005a2:	6041      	str	r1, [r0, #4]
 80005a4:	f103 031c 	add.w	r3, r3, #28
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 80005a8:	d1e8      	bne.n	800057c <HAL_PCD_Init+0x78>
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 80005aa:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80005ac:	466d      	mov	r5, sp
 80005ae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80005b0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80005b2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80005b4:	e894 0003 	ldmia.w	r4, {r0, r1}
 80005b8:	e885 0003 	stmia.w	r5, {r0, r1}
 80005bc:	4670      	mov	r0, lr
 80005be:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 80005c2:	f001 f917 	bl	80017f4 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 80005c6:	2301      	movs	r3, #1
 80005c8:	f886 33b9 	strb.w	r3, [r6, #953]	; 0x3b9
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 80005cc:	6830      	ldr	r0, [r6, #0]
 80005ce:	f001 fcf4 	bl	8001fba <USB_DevDisconnect>
 return HAL_OK;
 80005d2:	2000      	movs	r0, #0
 80005d4:	e000      	b.n	80005d8 <HAL_PCD_Init+0xd4>
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 80005d6:	2001      	movs	r0, #1
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 return HAL_OK;
}
 80005d8:	b00b      	add	sp, #44	; 0x2c
 80005da:	bdf0      	pop	{r4, r5, r6, r7, pc}

080005dc <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 80005dc:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 80005e0:	2b01      	cmp	r3, #1
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 80005e2:	b510      	push	{r4, lr}
 80005e4:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80005e6:	d00c      	beq.n	8000602 <HAL_PCD_Start+0x26>
 80005e8:	2301      	movs	r3, #1
 80005ea:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_DevConnect (hpcd->Instance);  
 80005ee:	6800      	ldr	r0, [r0, #0]
 80005f0:	f001 fcd7 	bl	8001fa2 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80005f4:	6820      	ldr	r0, [r4, #0]
 80005f6:	f001 f8da 	bl	80017ae <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 80005fa:	2000      	movs	r0, #0
 80005fc:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8000600:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000602:	2002      	movs	r0, #2
  USB_DevConnect (hpcd->Instance);  
  __HAL_PCD_ENABLE(hpcd);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8000604:	bd10      	pop	{r4, pc}
	...

08000608 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800060c:	f8d0 a000 	ldr.w	sl, [r0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000610:	b087      	sub	sp, #28
 8000612:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000U;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000614:	4650      	mov	r0, sl
 8000616:	f001 fd0a 	bl	800202e <USB_GetMode>
 800061a:	2800      	cmp	r0, #0
 800061c:	f040 8277 	bne.w	8000b0e <HAL_PCD_IRQHandler+0x506>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000620:	6820      	ldr	r0, [r4, #0]
 8000622:	f001 fcd6 	bl	8001fd2 <USB_ReadInterrupts>
 8000626:	2800      	cmp	r0, #0
 8000628:	f000 8271 	beq.w	8000b0e <HAL_PCD_IRQHandler+0x506>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800062c:	6820      	ldr	r0, [r4, #0]
 800062e:	f001 fcd0 	bl	8001fd2 <USB_ReadInterrupts>
 8000632:	0785      	lsls	r5, r0, #30
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000634:	bf48      	it	mi
 8000636:	6822      	ldrmi	r2, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000638:	6820      	ldr	r0, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800063a:	bf42      	ittt	mi
 800063c:	6953      	ldrmi	r3, [r2, #20]
 800063e:	f003 0302 	andmi.w	r3, r3, #2
 8000642:	6153      	strmi	r3, [r2, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000644:	f001 fcc5 	bl	8001fd2 <USB_ReadInterrupts>
 8000648:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
 800064c:	d04a      	beq.n	80006e4 <HAL_PCD_IRQHandler+0xdc>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800064e:	6820      	ldr	r0, [r4, #0]
 8000650:	f001 fcc3 	bl	8001fda <USB_ReadDevAllOutEpInterrupt>
 8000654:	f50a 6630 	add.w	r6, sl, #2816	; 0xb00
 8000658:	4607      	mov	r7, r0
 800065a:	46a1      	mov	r9, r4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
 800065c:	2500      	movs	r5, #0
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 800065e:	2f00      	cmp	r7, #0
 8000660:	d041      	beq.n	80006e6 <HAL_PCD_IRQHandler+0xde>
      {
        if (ep_intr & 0x1U)
 8000662:	07f8      	lsls	r0, r7, #31
 8000664:	d538      	bpl.n	80006d8 <HAL_PCD_IRQHandler+0xd0>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000666:	fa5f fb85 	uxtb.w	fp, r5
 800066a:	4659      	mov	r1, fp
 800066c:	6820      	ldr	r0, [r4, #0]
 800066e:	f001 fcc4 	bl	8001ffa <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000672:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000676:	4680      	mov	r8, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000678:	d021      	beq.n	80006be <HAL_PCD_IRQHandler+0xb6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
            
            if(hpcd->Init.dma_enable == 1U)
 800067a:	6921      	ldr	r1, [r4, #16]
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800067c:	2301      	movs	r3, #1
            
            if(hpcd->Init.dma_enable == 1U)
 800067e:	4299      	cmp	r1, r3
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000680:	60b3      	str	r3, [r6, #8]
            
            if(hpcd->Init.dma_enable == 1U)
 8000682:	d10c      	bne.n	800069e <HAL_PCD_IRQHandler+0x96>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8000684:	6931      	ldr	r1, [r6, #16]
 8000686:	f8d9 0200 	ldr.w	r0, [r9, #512]	; 0x200
 800068a:	f3c1 0112 	ubfx	r1, r1, #0, #19
 800068e:	1a41      	subs	r1, r0, r1
 8000690:	f8c9 1210 	str.w	r1, [r9, #528]	; 0x210
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8000694:	f8d9 1204 	ldr.w	r1, [r9, #516]	; 0x204
 8000698:	4408      	add	r0, r1
 800069a:	f8c9 0204 	str.w	r0, [r9, #516]	; 0x204
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 800069e:	4659      	mov	r1, fp
 80006a0:	4620      	mov	r0, r4
 80006a2:	f002 fd3d 	bl	8003120 <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 80006a6:	6921      	ldr	r1, [r4, #16]
 80006a8:	2901      	cmp	r1, #1
 80006aa:	d108      	bne.n	80006be <HAL_PCD_IRQHandler+0xb6>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80006ac:	b93d      	cbnz	r5, 80006be <HAL_PCD_IRQHandler+0xb6>
 80006ae:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 80006b2:	b922      	cbnz	r2, 80006be <HAL_PCD_IRQHandler+0xb6>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80006b4:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 80006b8:	6820      	ldr	r0, [r4, #0]
 80006ba:	f001 fcd7 	bl	800206c <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 80006be:	f018 0f08 	tst.w	r8, #8
 80006c2:	d004      	beq.n	80006ce <HAL_PCD_IRQHandler+0xc6>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 80006c4:	4620      	mov	r0, r4
 80006c6:	f002 fd25 	bl	8003114 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 80006ca:	2308      	movs	r3, #8
 80006cc:	60b3      	str	r3, [r6, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 80006ce:	f018 0f10 	tst.w	r8, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 80006d2:	bf1c      	itt	ne
 80006d4:	2310      	movne	r3, #16
 80006d6:	60b3      	strne	r3, [r6, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
 80006d8:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 80006da:	087f      	lsrs	r7, r7, #1
 80006dc:	3620      	adds	r6, #32
 80006de:	f109 091c 	add.w	r9, r9, #28
 80006e2:	e7bc      	b.n	800065e <HAL_PCD_IRQHandler+0x56>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 80006e4:	4605      	mov	r5, r0
        epnum++;
        ep_intr >>= 1U;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80006e6:	6820      	ldr	r0, [r4, #0]
 80006e8:	f001 fc73 	bl	8001fd2 <USB_ReadInterrupts>
 80006ec:	0341      	lsls	r1, r0, #13
 80006ee:	f140 809b 	bpl.w	8000828 <HAL_PCD_IRQHandler+0x220>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 80006f2:	6820      	ldr	r0, [r4, #0]
 80006f4:	f001 fc79 	bl	8001fea <USB_ReadDevAllInEpInterrupt>
 80006f8:	4626      	mov	r6, r4
 80006fa:	9003      	str	r0, [sp, #12]
 80006fc:	f50a 6810 	add.w	r8, sl, #2304	; 0x900
      
      epnum = 0U;
 8000700:	2500      	movs	r5, #0
      
      while ( ep_intr )
 8000702:	9b03      	ldr	r3, [sp, #12]
 8000704:	2b00      	cmp	r3, #0
 8000706:	f000 808f 	beq.w	8000828 <HAL_PCD_IRQHandler+0x220>
      {
        if (ep_intr & 0x1U) /* In ITR */
 800070a:	9b03      	ldr	r3, [sp, #12]
 800070c:	07da      	lsls	r2, r3, #31
 800070e:	f140 8083 	bpl.w	8000818 <HAL_PCD_IRQHandler+0x210>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8000712:	fa5f f985 	uxtb.w	r9, r5
 8000716:	4649      	mov	r1, r9
 8000718:	6820      	ldr	r0, [r4, #0]
 800071a:	f001 fc78 	bl	800200e <USB_ReadDevInEPInterrupt>

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800071e:	07c3      	lsls	r3, r0, #31
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U) /* In ITR */
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8000720:	4607      	mov	r7, r0

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8000722:	d520      	bpl.n	8000766 <HAL_PCD_IRQHandler+0x15e>
          {
            fifoemptymsk = 0x1U << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8000724:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8000728:	2101      	movs	r1, #1
 800072a:	40a9      	lsls	r1, r5
 800072c:	ea23 0301 	bic.w	r3, r3, r1
 8000730:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8000734:	2301      	movs	r3, #1
 8000736:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 800073a:	6923      	ldr	r3, [r4, #16]
 800073c:	2b01      	cmp	r3, #1
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 800073e:	bf01      	itttt	eq
 8000740:	6c72      	ldreq	r2, [r6, #68]	; 0x44
 8000742:	6c33      	ldreq	r3, [r6, #64]	; 0x40
 8000744:	189b      	addeq	r3, r3, r2
 8000746:	6473      	streq	r3, [r6, #68]	; 0x44
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8000748:	4649      	mov	r1, r9
 800074a:	4620      	mov	r0, r4
 800074c:	f002 fcf1 	bl	8003132 <HAL_PCD_DataInStageCallback>

            if (hpcd->Init.dma_enable == 1U)
 8000750:	6921      	ldr	r1, [r4, #16]
 8000752:	2901      	cmp	r1, #1
 8000754:	d107      	bne.n	8000766 <HAL_PCD_IRQHandler+0x15e>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8000756:	b935      	cbnz	r5, 8000766 <HAL_PCD_IRQHandler+0x15e>
 8000758:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800075a:	b923      	cbnz	r3, 8000766 <HAL_PCD_IRQHandler+0x15e>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800075c:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000760:	6820      	ldr	r0, [r4, #0]
 8000762:	f001 fc83 	bl	800206c <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8000766:	0738      	lsls	r0, r7, #28
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8000768:	bf44      	itt	mi
 800076a:	2308      	movmi	r3, #8
 800076c:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8000770:	06f9      	lsls	r1, r7, #27
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8000772:	bf44      	itt	mi
 8000774:	2310      	movmi	r3, #16
 8000776:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800077a:	067a      	lsls	r2, r7, #25
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800077c:	bf44      	itt	mi
 800077e:	2340      	movmi	r3, #64	; 0x40
 8000780:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8000784:	07bb      	lsls	r3, r7, #30
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8000786:	bf44      	itt	mi
 8000788:	2302      	movmi	r3, #2
 800078a:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 800078e:	063f      	lsls	r7, r7, #24
 8000790:	d542      	bpl.n	8000818 <HAL_PCD_IRQHandler+0x210>
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8000792:	6823      	ldr	r3, [r4, #0]
 8000794:	9304      	str	r3, [sp, #16]
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8000796:	6d37      	ldr	r7, [r6, #80]	; 0x50
 8000798:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 800079a:	1bdb      	subs	r3, r3, r7
  
  if (len > ep->maxpacket)
 800079c:	6c37      	ldr	r7, [r6, #64]	; 0x40
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 800079e:	429f      	cmp	r7, r3
 80007a0:	bf28      	it	cs
 80007a2:	461f      	movcs	r7, r3
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80007a4:	9b04      	ldr	r3, [sp, #16]
 80007a6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 80007aa:	f107 0b03 	add.w	fp, r7, #3
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80007ae:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 80007b2:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80007b6:	9305      	str	r3, [sp, #20]
 80007b8:	9b05      	ldr	r3, [sp, #20]
 80007ba:	699b      	ldr	r3, [r3, #24]
 80007bc:	b29b      	uxth	r3, r3
 80007be:	455b      	cmp	r3, fp
 80007c0:	d80c      	bhi.n	80007dc <HAL_PCD_IRQHandler+0x1d4>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
 80007c2:	bb4f      	cbnz	r7, 8000818 <HAL_PCD_IRQHandler+0x210>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80007c4:	9b04      	ldr	r3, [sp, #16]
 80007c6:	2201      	movs	r2, #1
 80007c8:	f503 6900 	add.w	r9, r3, #2048	; 0x800
 80007cc:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 80007d0:	40aa      	lsls	r2, r5
 80007d2:	ea23 0302 	bic.w	r3, r3, r2
 80007d6:	f8c9 3034 	str.w	r3, [r9, #52]	; 0x34
 80007da:	e01d      	b.n	8000818 <HAL_PCD_IRQHandler+0x210>
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
          (ep->xfer_count < ep->xfer_len) &&
 80007dc:	6d32      	ldr	r2, [r6, #80]	; 0x50
 80007de:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
 80007e0:	4293      	cmp	r3, r2
 80007e2:	d9ee      	bls.n	80007c2 <HAL_PCD_IRQHandler+0x1ba>
          (ep->xfer_count < ep->xfer_len) &&
 80007e4:	2b00      	cmp	r3, #0
 80007e6:	d0ec      	beq.n	80007c2 <HAL_PCD_IRQHandler+0x1ba>
            (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 80007e8:	6c37      	ldr	r7, [r6, #64]	; 0x40
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 80007ea:	9804      	ldr	r0, [sp, #16]
  while  (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b) &&
          (ep->xfer_count < ep->xfer_len) &&
            (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 80007ec:	1a9b      	subs	r3, r3, r2
 80007ee:	429f      	cmp	r7, r3
 80007f0:	bf28      	it	cs
 80007f2:	461f      	movcs	r7, r3
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 80007f4:	7c23      	ldrb	r3, [r4, #16]
 80007f6:	9300      	str	r3, [sp, #0]
 80007f8:	464a      	mov	r2, r9
 80007fa:	b2bb      	uxth	r3, r7
 80007fc:	6c71      	ldr	r1, [r6, #68]	; 0x44
 80007fe:	f001 fb4e 	bl	8001e9e <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8000802:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000804:	443b      	add	r3, r7
 8000806:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 8000808:	6d33      	ldr	r3, [r6, #80]	; 0x50
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 800080a:	f107 0b03 	add.w	fp, r7, #3
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 800080e:	443b      	add	r3, r7
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 8000810:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8000814:	6533      	str	r3, [r6, #80]	; 0x50
 8000816:	e7cf      	b.n	80007b8 <HAL_PCD_IRQHandler+0x1b0>
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
        ep_intr >>= 1U;
 8000818:	9b03      	ldr	r3, [sp, #12]
 800081a:	085b      	lsrs	r3, r3, #1
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 800081c:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 800081e:	9303      	str	r3, [sp, #12]
 8000820:	361c      	adds	r6, #28
 8000822:	f108 0820 	add.w	r8, r8, #32
 8000826:	e76c      	b.n	8000702 <HAL_PCD_IRQHandler+0xfa>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8000828:	6820      	ldr	r0, [r4, #0]
 800082a:	f001 fbd2 	bl	8001fd2 <USB_ReadInterrupts>
 800082e:	2800      	cmp	r0, #0
 8000830:	da0d      	bge.n	800084e <HAL_PCD_IRQHandler+0x246>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8000832:	f8da 3804 	ldr.w	r3, [sl, #2052]	; 0x804
 8000836:	f023 0301 	bic.w	r3, r3, #1
 800083a:	f8ca 3804 	str.w	r3, [sl, #2052]	; 0x804
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 800083e:	4620      	mov	r0, r4
 8000840:	f002 fcac 	bl	800319c <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8000844:	6822      	ldr	r2, [r4, #0]
 8000846:	6953      	ldr	r3, [r2, #20]
 8000848:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800084c:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800084e:	6820      	ldr	r0, [r4, #0]
 8000850:	f001 fbbf 	bl	8001fd2 <USB_ReadInterrupts>
 8000854:	0506      	lsls	r6, r0, #20
 8000856:	d50b      	bpl.n	8000870 <HAL_PCD_IRQHandler+0x268>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8000858:	f8da 3808 	ldr.w	r3, [sl, #2056]	; 0x808
 800085c:	07d8      	lsls	r0, r3, #31
 800085e:	d502      	bpl.n	8000866 <HAL_PCD_IRQHandler+0x25e>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 8000860:	4620      	mov	r0, r4
 8000862:	f002 fc83 	bl	800316c <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8000866:	6822      	ldr	r2, [r4, #0]
 8000868:	6953      	ldr	r3, [r2, #20]
 800086a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800086e:	6153      	str	r3, [r2, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8000870:	6820      	ldr	r0, [r4, #0]
 8000872:	f001 fbae 	bl	8001fd2 <USB_ReadInterrupts>
 8000876:	04c1      	lsls	r1, r0, #19
 8000878:	d543      	bpl.n	8000902 <HAL_PCD_IRQHandler+0x2fa>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 800087a:	f50a 6600 	add.w	r6, sl, #2048	; 0x800
 800087e:	6873      	ldr	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
 8000880:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8000882:	f023 0301 	bic.w	r3, r3, #1
 8000886:	6073      	str	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
 8000888:	2110      	movs	r1, #16
 800088a:	f001 f84d 	bl	8001928 <USB_FlushTxFifo>
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800088e:	6860      	ldr	r0, [r4, #4]
 8000890:	f50a 6310 	add.w	r3, sl, #2304	; 0x900
 8000894:	2200      	movs	r2, #0
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 8000896:	21ff      	movs	r1, #255	; 0xff
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8000898:	4282      	cmp	r2, r0
 800089a:	d005      	beq.n	80008a8 <HAL_PCD_IRQHandler+0x2a0>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 800089c:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0x10U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800089e:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 80008a0:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
 80008a4:	3320      	adds	r3, #32
 80008a6:	e7f7      	b.n	8000898 <HAL_PCD_IRQHandler+0x290>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80008a8:	f04f 33ff 	mov.w	r3, #4294967295
 80008ac:	61b3      	str	r3, [r6, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 80008ae:	69f3      	ldr	r3, [r6, #28]
 80008b0:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 80008b4:	61f3      	str	r3, [r6, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 80008b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80008b8:	b153      	cbz	r3, 80008d0 <HAL_PCD_IRQHandler+0x2c8>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 80008ba:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 80008be:	f043 030b 	orr.w	r3, r3, #11
 80008c2:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 80008c6:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80008c8:	f043 030b 	orr.w	r3, r3, #11
 80008cc:	6473      	str	r3, [r6, #68]	; 0x44
 80008ce:	e007      	b.n	80008e0 <HAL_PCD_IRQHandler+0x2d8>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 80008d0:	6973      	ldr	r3, [r6, #20]
 80008d2:	f043 030b 	orr.w	r3, r3, #11
 80008d6:	6173      	str	r3, [r6, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 80008d8:	6933      	ldr	r3, [r6, #16]
 80008da:	f043 030b 	orr.w	r3, r3, #11
 80008de:	6133      	str	r3, [r6, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80008e0:	f8da 3800 	ldr.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80008e4:	7c21      	ldrb	r1, [r4, #16]
 80008e6:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80008e8:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80008ec:	f8ca 3800 	str.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80008f0:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 80008f4:	f001 fbba 	bl	800206c <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80008f8:	6822      	ldr	r2, [r4, #0]
 80008fa:	6953      	ldr	r3, [r2, #20]
 80008fc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000900:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8000902:	6820      	ldr	r0, [r4, #0]
 8000904:	f001 fb65 	bl	8001fd2 <USB_ReadInterrupts>
 8000908:	0482      	lsls	r2, r0, #18
 800090a:	d57c      	bpl.n	8000a06 <HAL_PCD_IRQHandler+0x3fe>
    {
      USB_ActivateSetup(hpcd->Instance);
 800090c:	6820      	ldr	r0, [r4, #0]
 800090e:	f001 fb92 	bl	8002036 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8000912:	6820      	ldr	r0, [r4, #0]
 8000914:	68c3      	ldr	r3, [r0, #12]
 8000916:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800091a:	60c3      	str	r3, [r0, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 800091c:	f001 f82d 	bl	800197a <USB_GetDevSpeed>
 8000920:	b948      	cbnz	r0, 8000936 <HAL_PCD_IRQHandler+0x32e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000922:	6822      	ldr	r2, [r4, #0]
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8000924:	60e0      	str	r0, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8000926:	f44f 7300 	mov.w	r3, #512	; 0x200
 800092a:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 800092c:	68d3      	ldr	r3, [r2, #12]
 800092e:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8000932:	60d3      	str	r3, [r2, #12]
 8000934:	e05f      	b.n	80009f6 <HAL_PCD_IRQHandler+0x3ee>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8000936:	2303      	movs	r3, #3
 8000938:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 800093a:	2340      	movs	r3, #64	; 0x40
 800093c:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response 
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access 
        latency to the Data FIFO */
        
        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 800093e:	f000 fcab 	bl	8001298 <HAL_RCC_GetHCLKFreq>
        
        if((hclk >= 14200000U)&&(hclk < 15000000U))
 8000942:	4b74      	ldr	r3, [pc, #464]	; (8000b14 <HAL_PCD_IRQHandler+0x50c>)
 8000944:	4a74      	ldr	r2, [pc, #464]	; (8000b18 <HAL_PCD_IRQHandler+0x510>)
 8000946:	4403      	add	r3, r0
 8000948:	4293      	cmp	r3, r2
 800094a:	6823      	ldr	r3, [r4, #0]
 800094c:	d803      	bhi.n	8000956 <HAL_PCD_IRQHandler+0x34e>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xFU << 10U) & USB_OTG_GUSBCFG_TRDT);
 800094e:	68da      	ldr	r2, [r3, #12]
 8000950:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
 8000954:	e04e      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 15000000U)&&(hclk < 16000000U))
 8000956:	4a71      	ldr	r2, [pc, #452]	; (8000b1c <HAL_PCD_IRQHandler+0x514>)
 8000958:	4971      	ldr	r1, [pc, #452]	; (8000b20 <HAL_PCD_IRQHandler+0x518>)
 800095a:	4402      	add	r2, r0
 800095c:	428a      	cmp	r2, r1
 800095e:	d803      	bhi.n	8000968 <HAL_PCD_IRQHandler+0x360>
        {
          /* hclk Clock Range between 15-16 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xEU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000960:	68da      	ldr	r2, [r3, #12]
 8000962:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 8000966:	e045      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 16000000U)&&(hclk < 17200000U))
 8000968:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 800096c:	496d      	ldr	r1, [pc, #436]	; (8000b24 <HAL_PCD_IRQHandler+0x51c>)
 800096e:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 8000972:	428a      	cmp	r2, r1
 8000974:	d803      	bhi.n	800097e <HAL_PCD_IRQHandler+0x376>
        {
          /* hclk Clock Range between 16-17.2 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xDU << 10U) & USB_OTG_GUSBCFG_TRDT);
 8000976:	68da      	ldr	r2, [r3, #12]
 8000978:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 800097c:	e03a      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 17200000U)&&(hclk < 18500000U))
 800097e:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 8000982:	4969      	ldr	r1, [pc, #420]	; (8000b28 <HAL_PCD_IRQHandler+0x520>)
 8000984:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 8000988:	428a      	cmp	r2, r1
 800098a:	d803      	bhi.n	8000994 <HAL_PCD_IRQHandler+0x38c>
        {
          /* hclk Clock Range between 17.2-18.5 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xCU << 10U) & USB_OTG_GUSBCFG_TRDT);
 800098c:	68da      	ldr	r2, [r3, #12]
 800098e:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 8000992:	e02f      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 18500000U)&&(hclk < 20000000U))
 8000994:	4a65      	ldr	r2, [pc, #404]	; (8000b2c <HAL_PCD_IRQHandler+0x524>)
 8000996:	4966      	ldr	r1, [pc, #408]	; (8000b30 <HAL_PCD_IRQHandler+0x528>)
 8000998:	4402      	add	r2, r0
 800099a:	428a      	cmp	r2, r1
 800099c:	d803      	bhi.n	80009a6 <HAL_PCD_IRQHandler+0x39e>
        {
          /* hclk Clock Range between 18.5-20 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xBU << 10U) & USB_OTG_GUSBCFG_TRDT);
 800099e:	68da      	ldr	r2, [r3, #12]
 80009a0:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 80009a4:	e026      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 20000000U)&&(hclk < 21800000U))
 80009a6:	4a63      	ldr	r2, [pc, #396]	; (8000b34 <HAL_PCD_IRQHandler+0x52c>)
 80009a8:	4963      	ldr	r1, [pc, #396]	; (8000b38 <HAL_PCD_IRQHandler+0x530>)
 80009aa:	4402      	add	r2, r0
 80009ac:	428a      	cmp	r2, r1
 80009ae:	d803      	bhi.n	80009b8 <HAL_PCD_IRQHandler+0x3b0>
        {
          /* hclk Clock Range between 20-21.8 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xAU << 10U) & USB_OTG_GUSBCFG_TRDT);
 80009b0:	68da      	ldr	r2, [r3, #12]
 80009b2:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 80009b6:	e01d      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 21800000U)&&(hclk < 24000000U))
 80009b8:	4a60      	ldr	r2, [pc, #384]	; (8000b3c <HAL_PCD_IRQHandler+0x534>)
 80009ba:	4961      	ldr	r1, [pc, #388]	; (8000b40 <HAL_PCD_IRQHandler+0x538>)
 80009bc:	4402      	add	r2, r0
 80009be:	428a      	cmp	r2, r1
 80009c0:	d803      	bhi.n	80009ca <HAL_PCD_IRQHandler+0x3c2>
        {
          /* hclk Clock Range between 21.8-24 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9U << 10U) & USB_OTG_GUSBCFG_TRDT);
 80009c2:	68da      	ldr	r2, [r3, #12]
 80009c4:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 80009c8:	e014      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 24000000U)&&(hclk < 27700000U))
 80009ca:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 80009ce:	495d      	ldr	r1, [pc, #372]	; (8000b44 <HAL_PCD_IRQHandler+0x53c>)
 80009d0:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 80009d4:	428a      	cmp	r2, r1
 80009d6:	d803      	bhi.n	80009e0 <HAL_PCD_IRQHandler+0x3d8>
        {
          /* hclk Clock Range between 24-27.7 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8U << 10U) & USB_OTG_GUSBCFG_TRDT);
 80009d8:	68da      	ldr	r2, [r3, #12]
 80009da:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80009de:	e009      	b.n	80009f4 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 27700000U)&&(hclk < 32000000U))
 80009e0:	4a59      	ldr	r2, [pc, #356]	; (8000b48 <HAL_PCD_IRQHandler+0x540>)
 80009e2:	495a      	ldr	r1, [pc, #360]	; (8000b4c <HAL_PCD_IRQHandler+0x544>)
 80009e4:	4402      	add	r2, r0
 80009e6:	428a      	cmp	r2, r1
        {
          /* hclk Clock Range between 27.7-32 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7U << 10U) & USB_OTG_GUSBCFG_TRDT);
 80009e8:	68da      	ldr	r2, [r3, #12]
 80009ea:	bf94      	ite	ls
 80009ec:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
        }
        
        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-180 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6U << 10U) & USB_OTG_GUSBCFG_TRDT);
 80009f0:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 80009f4:	60da      	str	r2, [r3, #12]
        }  
      }
      
      HAL_PCD_ResetCallback(hpcd);
 80009f6:	4620      	mov	r0, r4
 80009f8:	f002 fba7 	bl	800314a <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 80009fc:	6822      	ldr	r2, [r4, #0]
 80009fe:	6953      	ldr	r3, [r2, #20]
 8000a00:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000a04:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8000a06:	6820      	ldr	r0, [r4, #0]
 8000a08:	f001 fae3 	bl	8001fd2 <USB_ReadInterrupts>
 8000a0c:	06c3      	lsls	r3, r0, #27
 8000a0e:	d538      	bpl.n	8000a82 <HAL_PCD_IRQHandler+0x47a>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000a10:	6822      	ldr	r2, [r4, #0]
 8000a12:	6993      	ldr	r3, [r2, #24]
 8000a14:	f023 0310 	bic.w	r3, r3, #16
 8000a18:	6193      	str	r3, [r2, #24]
      
      temp = USBx->GRXSTSP;
 8000a1a:	f8da 6020 	ldr.w	r6, [sl, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8000a1e:	f3c6 4343 	ubfx	r3, r6, #17, #4
 8000a22:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8000a24:	f006 070f 	and.w	r7, r6, #15
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8000a28:	d114      	bne.n	8000a54 <HAL_PCD_IRQHandler+0x44c>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8000a2a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8000a2e:	4033      	ands	r3, r6
 8000a30:	b313      	cbz	r3, 8000a78 <HAL_PCD_IRQHandler+0x470>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8000a32:	231c      	movs	r3, #28
 8000a34:	fb03 4707 	mla	r7, r3, r7, r4
 8000a38:	f3c6 160a 	ubfx	r6, r6, #4, #11
 8000a3c:	4632      	mov	r2, r6
 8000a3e:	f8d7 1204 	ldr.w	r1, [r7, #516]	; 0x204
 8000a42:	4650      	mov	r0, sl
 8000a44:	f001 fa3f 	bl	8001ec6 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000a48:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 8000a4c:	4433      	add	r3, r6
 8000a4e:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 8000a52:	e00c      	b.n	8000a6e <HAL_PCD_IRQHandler+0x466>
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 8000a54:	2b06      	cmp	r3, #6
 8000a56:	d10f      	bne.n	8000a78 <HAL_PCD_IRQHandler+0x470>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8000a58:	2208      	movs	r2, #8
 8000a5a:	f504 716f 	add.w	r1, r4, #956	; 0x3bc
 8000a5e:	4650      	mov	r0, sl
 8000a60:	f001 fa31 	bl	8001ec6 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8000a64:	231c      	movs	r3, #28
 8000a66:	fb03 4707 	mla	r7, r3, r7, r4
 8000a6a:	f3c6 160a 	ubfx	r6, r6, #4, #11
 8000a6e:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 8000a72:	441e      	add	r6, r3
 8000a74:	f8c7 6210 	str.w	r6, [r7, #528]	; 0x210
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8000a78:	6822      	ldr	r2, [r4, #0]
 8000a7a:	6993      	ldr	r3, [r2, #24]
 8000a7c:	f043 0310 	orr.w	r3, r3, #16
 8000a80:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8000a82:	6820      	ldr	r0, [r4, #0]
 8000a84:	f001 faa5 	bl	8001fd2 <USB_ReadInterrupts>
 8000a88:	0707      	lsls	r7, r0, #28
 8000a8a:	d507      	bpl.n	8000a9c <HAL_PCD_IRQHandler+0x494>
    {
      HAL_PCD_SOFCallback(hpcd);
 8000a8c:	4620      	mov	r0, r4
 8000a8e:	f002 fb58 	bl	8003142 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8000a92:	6822      	ldr	r2, [r4, #0]
 8000a94:	6953      	ldr	r3, [r2, #20]
 8000a96:	f003 0308 	and.w	r3, r3, #8
 8000a9a:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8000a9c:	6820      	ldr	r0, [r4, #0]
 8000a9e:	f001 fa98 	bl	8001fd2 <USB_ReadInterrupts>
 8000aa2:	02c6      	lsls	r6, r0, #11
 8000aa4:	d508      	bpl.n	8000ab8 <HAL_PCD_IRQHandler+0x4b0>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8000aa6:	b2e9      	uxtb	r1, r5
 8000aa8:	4620      	mov	r0, r4
 8000aaa:	f002 fb7f 	bl	80031ac <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8000aae:	6822      	ldr	r2, [r4, #0]
 8000ab0:	6953      	ldr	r3, [r2, #20]
 8000ab2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000ab6:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8000ab8:	6820      	ldr	r0, [r4, #0]
 8000aba:	f001 fa8a 	bl	8001fd2 <USB_ReadInterrupts>
 8000abe:	0280      	lsls	r0, r0, #10
 8000ac0:	d508      	bpl.n	8000ad4 <HAL_PCD_IRQHandler+0x4cc>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8000ac2:	b2e9      	uxtb	r1, r5
 8000ac4:	4620      	mov	r0, r4
 8000ac6:	f002 fb6d 	bl	80031a4 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8000aca:	6822      	ldr	r2, [r4, #0]
 8000acc:	6953      	ldr	r3, [r2, #20]
 8000ace:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000ad2:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8000ad4:	6820      	ldr	r0, [r4, #0]
 8000ad6:	f001 fa7c 	bl	8001fd2 <USB_ReadInterrupts>
 8000ada:	0041      	lsls	r1, r0, #1
 8000adc:	d507      	bpl.n	8000aee <HAL_PCD_IRQHandler+0x4e6>
    {
      HAL_PCD_ConnectCallback(hpcd);
 8000ade:	4620      	mov	r0, r4
 8000ae0:	f002 fb68 	bl	80031b4 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8000ae4:	6822      	ldr	r2, [r4, #0]
 8000ae6:	6953      	ldr	r3, [r2, #20]
 8000ae8:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000aec:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8000aee:	6820      	ldr	r0, [r4, #0]
 8000af0:	f001 fa6f 	bl	8001fd2 <USB_ReadInterrupts>
 8000af4:	0742      	lsls	r2, r0, #29
 8000af6:	d50a      	bpl.n	8000b0e <HAL_PCD_IRQHandler+0x506>
    {
      temp = hpcd->Instance->GOTGINT;
 8000af8:	6823      	ldr	r3, [r4, #0]
 8000afa:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8000afc:	076b      	lsls	r3, r5, #29
 8000afe:	d502      	bpl.n	8000b06 <HAL_PCD_IRQHandler+0x4fe>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8000b00:	4620      	mov	r0, r4
 8000b02:	f002 fb5b 	bl	80031bc <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 8000b06:	6822      	ldr	r2, [r4, #0]
 8000b08:	6853      	ldr	r3, [r2, #4]
 8000b0a:	432b      	orrs	r3, r5
 8000b0c:	6053      	str	r3, [r2, #4]
    }
  }
}
 8000b0e:	b007      	add	sp, #28
 8000b10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b14:	ff275340 	.word	0xff275340
 8000b18:	000c34ff 	.word	0x000c34ff
 8000b1c:	ff1b1e40 	.word	0xff1b1e40
 8000b20:	000f423f 	.word	0x000f423f
 8000b24:	00124f7f 	.word	0x00124f7f
 8000b28:	0013d61f 	.word	0x0013d61f
 8000b2c:	fee5b660 	.word	0xfee5b660
 8000b30:	0016e35f 	.word	0x0016e35f
 8000b34:	feced300 	.word	0xfeced300
 8000b38:	001b773f 	.word	0x001b773f
 8000b3c:	feb35bc0 	.word	0xfeb35bc0
 8000b40:	002191bf 	.word	0x002191bf
 8000b44:	0038751f 	.word	0x0038751f
 8000b48:	fe5954e0 	.word	0xfe5954e0
 8000b4c:	00419cdf 	.word	0x00419cdf

08000b50 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8000b50:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8000b54:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8000b56:	b510      	push	{r4, lr}
 8000b58:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8000b5a:	d009      	beq.n	8000b70 <HAL_PCD_SetAddress+0x20>
 8000b5c:	2301      	movs	r3, #1
 8000b5e:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
  USB_SetDevAddress(hpcd->Instance, address);
 8000b62:	6800      	ldr	r0, [r0, #0]
 8000b64:	f001 fa0d 	bl	8001f82 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8000b68:	2000      	movs	r0, #0
 8000b6a:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8000b6e:	bd10      	pop	{r4, pc}
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8000b70:	2002      	movs	r0, #2
  USB_SetDevAddress(hpcd->Instance, address);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8000b72:	bd10      	pop	{r4, pc}

08000b74 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8000b74:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8000b76:	b24e      	sxtb	r6, r1
 8000b78:	2e00      	cmp	r6, #0
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8000b7a:	4604      	mov	r4, r0
 8000b7c:	f04f 051c 	mov.w	r5, #28
 8000b80:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000b84:	bfb5      	itete	lt
 8000b86:	fb05 4100 	mlalt	r1, r5, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000b8a:	fb05 4101 	mlage	r1, r5, r1, r4
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000b8e:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000b90:	f501 71fc 	addge.w	r1, r1, #504	; 0x1f8
  }
  ep->num   = ep_addr & 0x7F;
 8000b94:	b2c0      	uxtb	r0, r0
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
  if (ep->is_in)
 8000b96:	2e00      	cmp	r6, #0
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8000b98:	bfb8      	it	lt
 8000b9a:	80c8      	strhlt	r0, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 8000b9c:	2b02      	cmp	r3, #2
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 8000b9e:	70cb      	strb	r3, [r1, #3]
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8000ba0:	ea4f 75d6 	mov.w	r5, r6, lsr #31
    ep->tx_fifo_num = ep->num;
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
 8000ba4:	bf04      	itt	eq
 8000ba6:	2300      	moveq	r3, #0
 8000ba8:	710b      	strbeq	r3, [r1, #4]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8000baa:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8000bac:	704d      	strb	r5, [r1, #1]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8000bae:	f894 33b8 	ldrb.w	r3, [r4, #952]	; 0x3b8
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
 8000bb2:	608a      	str	r2, [r1, #8]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8000bb4:	2b01      	cmp	r3, #1
 8000bb6:	d009      	beq.n	8000bcc <HAL_PCD_EP_Open+0x58>
 8000bb8:	2301      	movs	r3, #1
 8000bba:	f884 33b8 	strb.w	r3, [r4, #952]	; 0x3b8
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8000bbe:	6820      	ldr	r0, [r4, #0]
 8000bc0:	f000 fef6 	bl	80019b0 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8000bc4:	2000      	movs	r0, #0
 8000bc6:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return ret;
 8000bca:	bd70      	pop	{r4, r5, r6, pc}
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8000bcc:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return ret;
}
 8000bce:	bd70      	pop	{r4, r5, r6, pc}

08000bd0 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8000bd0:	b24b      	sxtb	r3, r1
 8000bd2:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 8000bd4:	b510      	push	{r4, lr}
 8000bd6:	f04f 021c 	mov.w	r2, #28
 8000bda:	4604      	mov	r4, r0
 8000bdc:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000be0:	bfb5      	itete	lt
 8000be2:	fb02 4100 	mlalt	r1, r2, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000be6:	fb02 4101 	mlage	r1, r2, r1, r4
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000bea:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000bec:	f501 71fc 	addge.w	r1, r1, #504	; 0x1f8
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8000bf0:	0fdb      	lsrs	r3, r3, #31
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8000bf2:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 8000bf4:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8000bf6:	f894 33b8 	ldrb.w	r3, [r4, #952]	; 0x3b8
 8000bfa:	2b01      	cmp	r3, #1
 8000bfc:	d009      	beq.n	8000c12 <HAL_PCD_EP_Close+0x42>
 8000bfe:	2301      	movs	r3, #1
 8000c00:	f884 33b8 	strb.w	r3, [r4, #952]	; 0x3b8
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8000c04:	6820      	ldr	r0, [r4, #0]
 8000c06:	f000 ff14 	bl	8001a32 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8000c0a:	2000      	movs	r0, #0
 8000c0c:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  return HAL_OK;
 8000c10:	bd10      	pop	{r4, pc}
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd); 
 8000c12:	2002      	movs	r0, #2
  USB_DeactivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8000c14:	bd10      	pop	{r4, pc}

08000c16 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000c16:	b538      	push	{r3, r4, r5, lr}
 8000c18:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000c1c:	241c      	movs	r4, #28
 8000c1e:	436c      	muls	r4, r5
 8000c20:	f504 71fc 	add.w	r1, r4, #504	; 0x1f8
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000c24:	4404      	add	r4, r0
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8000c26:	4401      	add	r1, r0
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
 8000c28:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
  ep->xfer_count = 0U;
 8000c2c:	2300      	movs	r3, #0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000c2e:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 8000c32:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->is_in = 0U;
 8000c36:	f884 31f9 	strb.w	r3, [r4, #505]	; 0x1f9
  ep->num = ep_addr & 0x7F;
 8000c3a:	f884 51f8 	strb.w	r5, [r4, #504]	; 0x1f8
  
  if (hpcd->Init.dma_enable == 1U)
 8000c3e:	6903      	ldr	r3, [r0, #16]
 8000c40:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8000c42:	bf08      	it	eq
 8000c44:	f8c4 2208 	streq.w	r2, [r4, #520]	; 0x208
  }
  
  if ((ep_addr & 0x7F) == 0)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000c48:	6800      	ldr	r0, [r0, #0]
 8000c4a:	b2da      	uxtb	r2, r3
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  if ((ep_addr & 0x7F) == 0)
 8000c4c:	b915      	cbnz	r5, 8000c54 <HAL_PCD_EP_Receive+0x3e>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000c4e:	f001 f87d 	bl	8001d4c <USB_EP0StartXfer>
 8000c52:	e001      	b.n	8000c58 <HAL_PCD_EP_Receive+0x42>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000c54:	f000 ff5e 	bl	8001b14 <USB_EPStartXfer>
  }
  
  return HAL_OK;
}
 8000c58:	2000      	movs	r0, #0
 8000c5a:	bd38      	pop	{r3, r4, r5, pc}

08000c5c <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0xF].xfer_count;
 8000c5c:	f001 010f 	and.w	r1, r1, #15
 8000c60:	231c      	movs	r3, #28
 8000c62:	fb03 0001 	mla	r0, r3, r1, r0
}
 8000c66:	f8b0 0210 	ldrh.w	r0, [r0, #528]	; 0x210
 8000c6a:	4770      	bx	lr

08000c6c <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000c6c:	b538      	push	{r3, r4, r5, lr}
 8000c6e:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000c72:	241c      	movs	r4, #28
 8000c74:	436c      	muls	r4, r5
 8000c76:	f104 0138 	add.w	r1, r4, #56	; 0x38
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000c7a:	4404      	add	r4, r0
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000c7c:	4401      	add	r1, r0
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
 8000c7e:	64e3      	str	r3, [r4, #76]	; 0x4c
  ep->xfer_count = 0U;
 8000c80:	2300      	movs	r3, #0
 8000c82:	6523      	str	r3, [r4, #80]	; 0x50
  ep->is_in = 1U;
 8000c84:	2301      	movs	r3, #1
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000c86:	6462      	str	r2, [r4, #68]	; 0x44
  ep->xfer_len = len;
  ep->xfer_count = 0U;
  ep->is_in = 1U;
 8000c88:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  ep->num = ep_addr & 0x7F;
 8000c8c:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
  
  if (hpcd->Init.dma_enable == 1U)
 8000c90:	6903      	ldr	r3, [r0, #16]
 8000c92:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8000c94:	bf08      	it	eq
 8000c96:	64a2      	streq	r2, [r4, #72]	; 0x48
  }
  
  if ((ep_addr & 0x7F) == 0)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000c98:	6800      	ldr	r0, [r0, #0]
 8000c9a:	b2da      	uxtb	r2, r3
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  if ((ep_addr & 0x7F) == 0)
 8000c9c:	b915      	cbnz	r5, 8000ca4 <HAL_PCD_EP_Transmit+0x38>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000c9e:	f001 f855 	bl	8001d4c <USB_EP0StartXfer>
 8000ca2:	e001      	b.n	8000ca8 <HAL_PCD_EP_Transmit+0x3c>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8000ca4:	f000 ff36 	bl	8001b14 <USB_EPStartXfer>
  }
  
  return HAL_OK;
}
 8000ca8:	2000      	movs	r0, #0
 8000caa:	bd38      	pop	{r3, r4, r5, pc}

08000cac <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8000cac:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8000cae:	b24b      	sxtb	r3, r1
 8000cb0:	2b00      	cmp	r3, #0
 8000cb2:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8000cb6:	f04f 021c 	mov.w	r2, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000cba:	bfb5      	itete	lt
 8000cbc:	fb02 0105 	mlalt	r1, r2, r5, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8000cc0:	fb02 0101 	mlage	r1, r2, r1, r0
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000cc4:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8000cc6:	f501 71fc 	addge.w	r1, r1, #504	; 0x1f8
  }
  
  ep->is_stall = 1U;
 8000cca:	2201      	movs	r2, #1
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8000ccc:	0fdb      	lsrs	r3, r3, #31
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7F;
 8000cce:	b2ed      	uxtb	r5, r5
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
 8000cd0:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7F;
 8000cd2:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8000cd4:	704b      	strb	r3, [r1, #1]
  
  
  __HAL_LOCK(hpcd); 
 8000cd6:	f890 33b8 	ldrb.w	r3, [r0, #952]	; 0x3b8
 8000cda:	4293      	cmp	r3, r2
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8000cdc:	4604      	mov	r4, r0
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  
  __HAL_LOCK(hpcd); 
 8000cde:	d00f      	beq.n	8000d00 <HAL_PCD_EP_SetStall+0x54>
 8000ce0:	f880 23b8 	strb.w	r2, [r0, #952]	; 0x3b8
  USB_EPSetStall(hpcd->Instance , ep);
 8000ce4:	6800      	ldr	r0, [r0, #0]
 8000ce6:	f001 f8fc 	bl	8001ee2 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8000cea:	b92d      	cbnz	r5, 8000cf8 <HAL_PCD_EP_SetStall+0x4c>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8000cec:	f504 726f 	add.w	r2, r4, #956	; 0x3bc
 8000cf0:	7c21      	ldrb	r1, [r4, #16]
 8000cf2:	6820      	ldr	r0, [r4, #0]
 8000cf4:	f001 f9ba 	bl	800206c <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd); 
 8000cf8:	2000      	movs	r0, #0
 8000cfa:	f884 03b8 	strb.w	r0, [r4, #952]	; 0x3b8
  
  return HAL_OK;
 8000cfe:	bd38      	pop	{r3, r4, r5, pc}
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  
  __HAL_LOCK(hpcd); 
 8000d00:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8000d02:	bd38      	pop	{r3, r4, r5, pc}

08000d04 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8000d04:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8000d06:	b24b      	sxtb	r3, r1
 8000d08:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8000d0a:	4605      	mov	r5, r0
 8000d0c:	f04f 021c 	mov.w	r2, #28
 8000d10:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000d14:	bfb5      	itete	lt
 8000d16:	fb02 5100 	mlalt	r1, r2, r0, r5
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8000d1a:	fb02 5101 	mlage	r1, r2, r1, r5
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8000d1e:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8000d20:	f501 71fc 	addge.w	r1, r1, #504	; 0x1f8
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8000d24:	0fdb      	lsrs	r3, r3, #31
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0U;
 8000d26:	2400      	movs	r4, #0
 8000d28:	708c      	strb	r4, [r1, #2]
  ep->num   = ep_addr & 0x7F;
 8000d2a:	7008      	strb	r0, [r1, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8000d2c:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8000d2e:	f895 33b8 	ldrb.w	r3, [r5, #952]	; 0x3b8
 8000d32:	2b01      	cmp	r3, #1
 8000d34:	d009      	beq.n	8000d4a <HAL_PCD_EP_ClrStall+0x46>
 8000d36:	2301      	movs	r3, #1
 8000d38:	f885 33b8 	strb.w	r3, [r5, #952]	; 0x3b8
  USB_EPClearStall(hpcd->Instance , ep);
 8000d3c:	6828      	ldr	r0, [r5, #0]
 8000d3e:	f001 f902 	bl	8001f46 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8000d42:	f885 43b8 	strb.w	r4, [r5, #952]	; 0x3b8
    
  return HAL_OK;
 8000d46:	4620      	mov	r0, r4
 8000d48:	bd38      	pop	{r3, r4, r5, pc}
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 8000d4a:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 8000d4c:	bd38      	pop	{r3, r4, r5, pc}

08000d4e <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8000d4e:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8000d50:	6804      	ldr	r4, [r0, #0]
 8000d52:	6a60      	ldr	r0, [r4, #36]	; 0x24
  
  if(fifo == 0)
 8000d54:	b919      	cbnz	r1, 8000d5e <HAL_PCDEx_SetTxFiFo+0x10>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 8000d56:	ea40 4302 	orr.w	r3, r0, r2, lsl #16
 8000d5a:	62a3      	str	r3, [r4, #40]	; 0x28
 8000d5c:	e016      	b.n	8000d8c <HAL_PCDEx_SetTxFiFo+0x3e>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8000d5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0; i < (fifo - 1); i++)
 8000d60:	2500      	movs	r5, #0
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8000d62:	eb00 4313 	add.w	r3, r0, r3, lsr #16
    for (i = 0; i < (fifo - 1); i++)
 8000d66:	1e4e      	subs	r6, r1, #1
 8000d68:	b2e8      	uxtb	r0, r5
 8000d6a:	42b0      	cmp	r0, r6
 8000d6c:	f105 0501 	add.w	r5, r5, #1
 8000d70:	da06      	bge.n	8000d80 <HAL_PCDEx_SetTxFiFo+0x32>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 8000d72:	3040      	adds	r0, #64	; 0x40
 8000d74:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8000d78:	6840      	ldr	r0, [r0, #4]
 8000d7a:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 8000d7e:	e7f3      	b.n	8000d68 <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 8000d80:	313f      	adds	r1, #63	; 0x3f
 8000d82:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8000d86:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8000d8a:	6063      	str	r3, [r4, #4]
  }
  
  return HAL_OK;
}
 8000d8c:	2000      	movs	r0, #0
 8000d8e:	bd70      	pop	{r4, r5, r6, pc}

08000d90 <HAL_PCDEx_SetRxFiFo>:
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8000d90:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 8000d92:	2000      	movs	r0, #0
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8000d94:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 8000d96:	4770      	bx	lr

08000d98 <HAL_RCC_OscConfig>:
  uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000d98:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000d9a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8000d9e:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000da0:	07d8      	lsls	r0, r3, #31
 8000da2:	d403      	bmi.n	8000dac <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000da4:	6823      	ldr	r3, [r4, #0]
 8000da6:	0799      	lsls	r1, r3, #30
 8000da8:	d44b      	bmi.n	8000e42 <HAL_RCC_OscConfig+0xaa>
 8000daa:	e09b      	b.n	8000ee4 <HAL_RCC_OscConfig+0x14c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8000dac:	4b8c      	ldr	r3, [pc, #560]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000dae:	689a      	ldr	r2, [r3, #8]
 8000db0:	f002 020c 	and.w	r2, r2, #12
 8000db4:	2a04      	cmp	r2, #4
 8000db6:	d007      	beq.n	8000dc8 <HAL_RCC_OscConfig+0x30>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000db8:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8000dba:	f002 020c 	and.w	r2, r2, #12
 8000dbe:	2a08      	cmp	r2, #8
 8000dc0:	d10b      	bne.n	8000dda <HAL_RCC_OscConfig+0x42>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000dc2:	685b      	ldr	r3, [r3, #4]
 8000dc4:	025a      	lsls	r2, r3, #9
 8000dc6:	d508      	bpl.n	8000dda <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000dc8:	4b85      	ldr	r3, [pc, #532]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000dca:	681b      	ldr	r3, [r3, #0]
 8000dcc:	039b      	lsls	r3, r3, #14
 8000dce:	d5e9      	bpl.n	8000da4 <HAL_RCC_OscConfig+0xc>
 8000dd0:	6863      	ldr	r3, [r4, #4]
 8000dd2:	2b00      	cmp	r3, #0
 8000dd4:	d1e6      	bne.n	8000da4 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 8000dd6:	2001      	movs	r0, #1
 8000dd8:	e164      	b.n	80010a4 <HAL_RCC_OscConfig+0x30c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000dda:	6863      	ldr	r3, [r4, #4]
 8000ddc:	4d80      	ldr	r5, [pc, #512]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000dde:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000de2:	d006      	beq.n	8000df2 <HAL_RCC_OscConfig+0x5a>
 8000de4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000de8:	d108      	bne.n	8000dfc <HAL_RCC_OscConfig+0x64>
 8000dea:	682b      	ldr	r3, [r5, #0]
 8000dec:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000df0:	602b      	str	r3, [r5, #0]
 8000df2:	682b      	ldr	r3, [r5, #0]
 8000df4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000df8:	602b      	str	r3, [r5, #0]
 8000dfa:	e008      	b.n	8000e0e <HAL_RCC_OscConfig+0x76>
 8000dfc:	682a      	ldr	r2, [r5, #0]
 8000dfe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000e02:	602a      	str	r2, [r5, #0]
 8000e04:	682a      	ldr	r2, [r5, #0]
 8000e06:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000e0a:	602a      	str	r2, [r5, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8000e0c:	b16b      	cbz	r3, 8000e2a <HAL_RCC_OscConfig+0x92>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000e0e:	f7ff fa17 	bl	8000240 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000e12:	4d73      	ldr	r5, [pc, #460]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000e14:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000e16:	682b      	ldr	r3, [r5, #0]
 8000e18:	039f      	lsls	r7, r3, #14
 8000e1a:	d4c3      	bmi.n	8000da4 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000e1c:	f7ff fa10 	bl	8000240 <HAL_GetTick>
 8000e20:	1b80      	subs	r0, r0, r6
 8000e22:	2864      	cmp	r0, #100	; 0x64
 8000e24:	d9f7      	bls.n	8000e16 <HAL_RCC_OscConfig+0x7e>
          {
            return HAL_TIMEOUT;
 8000e26:	2003      	movs	r0, #3
 8000e28:	e13c      	b.n	80010a4 <HAL_RCC_OscConfig+0x30c>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000e2a:	f7ff fa09 	bl	8000240 <HAL_GetTick>
 8000e2e:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000e30:	682b      	ldr	r3, [r5, #0]
 8000e32:	0398      	lsls	r0, r3, #14
 8000e34:	d5b6      	bpl.n	8000da4 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000e36:	f7ff fa03 	bl	8000240 <HAL_GetTick>
 8000e3a:	1b80      	subs	r0, r0, r6
 8000e3c:	2864      	cmp	r0, #100	; 0x64
 8000e3e:	d9f7      	bls.n	8000e30 <HAL_RCC_OscConfig+0x98>
 8000e40:	e7f1      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8000e42:	4b67      	ldr	r3, [pc, #412]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000e44:	689a      	ldr	r2, [r3, #8]
 8000e46:	f012 0f0c 	tst.w	r2, #12
 8000e4a:	d007      	beq.n	8000e5c <HAL_RCC_OscConfig+0xc4>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8000e4c:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8000e4e:	f002 020c 	and.w	r2, r2, #12
 8000e52:	2a08      	cmp	r2, #8
 8000e54:	d117      	bne.n	8000e86 <HAL_RCC_OscConfig+0xee>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8000e56:	685b      	ldr	r3, [r3, #4]
 8000e58:	0259      	lsls	r1, r3, #9
 8000e5a:	d414      	bmi.n	8000e86 <HAL_RCC_OscConfig+0xee>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000e5c:	4b60      	ldr	r3, [pc, #384]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000e5e:	681a      	ldr	r2, [r3, #0]
 8000e60:	0792      	lsls	r2, r2, #30
 8000e62:	d502      	bpl.n	8000e6a <HAL_RCC_OscConfig+0xd2>
 8000e64:	68e2      	ldr	r2, [r4, #12]
 8000e66:	2a01      	cmp	r2, #1
 8000e68:	d1b5      	bne.n	8000dd6 <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000e6a:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000e6c:	21f8      	movs	r1, #248	; 0xf8
 8000e6e:	fa91 f1a1 	rbit	r1, r1
 8000e72:	6920      	ldr	r0, [r4, #16]
 8000e74:	fab1 f181 	clz	r1, r1
 8000e78:	fa00 f101 	lsl.w	r1, r0, r1
 8000e7c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8000e80:	430a      	orrs	r2, r1
 8000e82:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000e84:	e02e      	b.n	8000ee4 <HAL_RCC_OscConfig+0x14c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8000e86:	68e2      	ldr	r2, [r4, #12]
 8000e88:	4b56      	ldr	r3, [pc, #344]	; (8000fe4 <HAL_RCC_OscConfig+0x24c>)
 8000e8a:	b1ea      	cbz	r2, 8000ec8 <HAL_RCC_OscConfig+0x130>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000e8c:	2201      	movs	r2, #1
 8000e8e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000e90:	f7ff f9d6 	bl	8000240 <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000e94:	4d52      	ldr	r5, [pc, #328]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000e96:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000e98:	682b      	ldr	r3, [r5, #0]
 8000e9a:	4851      	ldr	r0, [pc, #324]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000e9c:	079b      	lsls	r3, r3, #30
 8000e9e:	d405      	bmi.n	8000eac <HAL_RCC_OscConfig+0x114>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000ea0:	f7ff f9ce 	bl	8000240 <HAL_GetTick>
 8000ea4:	1b80      	subs	r0, r0, r6
 8000ea6:	2802      	cmp	r0, #2
 8000ea8:	d9f6      	bls.n	8000e98 <HAL_RCC_OscConfig+0x100>
 8000eaa:	e7bc      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000eac:	6803      	ldr	r3, [r0, #0]
 8000eae:	22f8      	movs	r2, #248	; 0xf8
 8000eb0:	fa92 f2a2 	rbit	r2, r2
 8000eb4:	6921      	ldr	r1, [r4, #16]
 8000eb6:	fab2 f282 	clz	r2, r2
 8000eba:	fa01 f202 	lsl.w	r2, r1, r2
 8000ebe:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000ec2:	4313      	orrs	r3, r2
 8000ec4:	6003      	str	r3, [r0, #0]
 8000ec6:	e00d      	b.n	8000ee4 <HAL_RCC_OscConfig+0x14c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000ec8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000eca:	f7ff f9b9 	bl	8000240 <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000ece:	4d44      	ldr	r5, [pc, #272]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000ed0:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000ed2:	682b      	ldr	r3, [r5, #0]
 8000ed4:	079f      	lsls	r7, r3, #30
 8000ed6:	d505      	bpl.n	8000ee4 <HAL_RCC_OscConfig+0x14c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000ed8:	f7ff f9b2 	bl	8000240 <HAL_GetTick>
 8000edc:	1b80      	subs	r0, r0, r6
 8000ede:	2802      	cmp	r0, #2
 8000ee0:	d9f7      	bls.n	8000ed2 <HAL_RCC_OscConfig+0x13a>
 8000ee2:	e7a0      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000ee4:	6823      	ldr	r3, [r4, #0]
 8000ee6:	071e      	lsls	r6, r3, #28
 8000ee8:	d403      	bmi.n	8000ef2 <HAL_RCC_OscConfig+0x15a>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000eea:	6823      	ldr	r3, [r4, #0]
 8000eec:	075d      	lsls	r5, r3, #29
 8000eee:	d548      	bpl.n	8000f82 <HAL_RCC_OscConfig+0x1ea>
 8000ef0:	e01f      	b.n	8000f32 <HAL_RCC_OscConfig+0x19a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8000ef2:	6962      	ldr	r2, [r4, #20]
 8000ef4:	4b3c      	ldr	r3, [pc, #240]	; (8000fe8 <HAL_RCC_OscConfig+0x250>)
 8000ef6:	b172      	cbz	r2, 8000f16 <HAL_RCC_OscConfig+0x17e>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000ef8:	2201      	movs	r2, #1
 8000efa:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000efc:	f7ff f9a0 	bl	8000240 <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000f00:	4d37      	ldr	r5, [pc, #220]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000f02:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000f04:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000f06:	0798      	lsls	r0, r3, #30
 8000f08:	d4ef      	bmi.n	8000eea <HAL_RCC_OscConfig+0x152>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000f0a:	f7ff f999 	bl	8000240 <HAL_GetTick>
 8000f0e:	1b80      	subs	r0, r0, r6
 8000f10:	2802      	cmp	r0, #2
 8000f12:	d9f7      	bls.n	8000f04 <HAL_RCC_OscConfig+0x16c>
 8000f14:	e787      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000f16:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000f18:	f7ff f992 	bl	8000240 <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000f1c:	4d30      	ldr	r5, [pc, #192]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000f1e:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000f20:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8000f22:	0799      	lsls	r1, r3, #30
 8000f24:	d5e1      	bpl.n	8000eea <HAL_RCC_OscConfig+0x152>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000f26:	f7ff f98b 	bl	8000240 <HAL_GetTick>
 8000f2a:	1b80      	subs	r0, r0, r6
 8000f2c:	2802      	cmp	r0, #2
 8000f2e:	d9f7      	bls.n	8000f20 <HAL_RCC_OscConfig+0x188>
 8000f30:	e779      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000f32:	2300      	movs	r3, #0
 8000f34:	9301      	str	r3, [sp, #4]
 8000f36:	4b2a      	ldr	r3, [pc, #168]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8000f38:	4d2c      	ldr	r5, [pc, #176]	; (8000fec <HAL_RCC_OscConfig+0x254>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000f3a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000f3c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000f40:	641a      	str	r2, [r3, #64]	; 0x40
 8000f42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000f44:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000f48:	9301      	str	r3, [sp, #4]
 8000f4a:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8000f4c:	682b      	ldr	r3, [r5, #0]
 8000f4e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000f52:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8000f54:	f7ff f974 	bl	8000240 <HAL_GetTick>
 8000f58:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8000f5a:	682b      	ldr	r3, [r5, #0]
 8000f5c:	05da      	lsls	r2, r3, #23
 8000f5e:	d513      	bpl.n	8000f88 <HAL_RCC_OscConfig+0x1f0>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000f60:	68a3      	ldr	r3, [r4, #8]
 8000f62:	4d1f      	ldr	r5, [pc, #124]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
 8000f64:	2b01      	cmp	r3, #1
 8000f66:	d115      	bne.n	8000f94 <HAL_RCC_OscConfig+0x1fc>
 8000f68:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000f6a:	f043 0301 	orr.w	r3, r3, #1
 8000f6e:	672b      	str	r3, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000f70:	f7ff f966 	bl	8000240 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000f74:	4d1a      	ldr	r5, [pc, #104]	; (8000fe0 <HAL_RCC_OscConfig+0x248>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000f76:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000f78:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000f7c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000f7e:	079b      	lsls	r3, r3, #30
 8000f80:	d519      	bpl.n	8000fb6 <HAL_RCC_OscConfig+0x21e>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000f82:	69a2      	ldr	r2, [r4, #24]
 8000f84:	bba2      	cbnz	r2, 8000ff0 <HAL_RCC_OscConfig+0x258>
 8000f86:	e072      	b.n	800106e <HAL_RCC_OscConfig+0x2d6>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8000f88:	f7ff f95a 	bl	8000240 <HAL_GetTick>
 8000f8c:	1b80      	subs	r0, r0, r6
 8000f8e:	2802      	cmp	r0, #2
 8000f90:	d9e3      	bls.n	8000f5a <HAL_RCC_OscConfig+0x1c2>
 8000f92:	e748      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000f94:	2b05      	cmp	r3, #5
 8000f96:	d104      	bne.n	8000fa2 <HAL_RCC_OscConfig+0x20a>
 8000f98:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000f9a:	f043 0304 	orr.w	r3, r3, #4
 8000f9e:	672b      	str	r3, [r5, #112]	; 0x70
 8000fa0:	e7e2      	b.n	8000f68 <HAL_RCC_OscConfig+0x1d0>
 8000fa2:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8000fa4:	f022 0201 	bic.w	r2, r2, #1
 8000fa8:	672a      	str	r2, [r5, #112]	; 0x70
 8000faa:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8000fac:	f022 0204 	bic.w	r2, r2, #4
 8000fb0:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8000fb2:	b133      	cbz	r3, 8000fc2 <HAL_RCC_OscConfig+0x22a>
 8000fb4:	e7dc      	b.n	8000f70 <HAL_RCC_OscConfig+0x1d8>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000fb6:	f7ff f943 	bl	8000240 <HAL_GetTick>
 8000fba:	1b80      	subs	r0, r0, r6
 8000fbc:	42b8      	cmp	r0, r7
 8000fbe:	d9dd      	bls.n	8000f7c <HAL_RCC_OscConfig+0x1e4>
 8000fc0:	e731      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000fc2:	f7ff f93d 	bl	8000240 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000fc6:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000fca:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000fcc:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8000fce:	0798      	lsls	r0, r3, #30
 8000fd0:	d5d7      	bpl.n	8000f82 <HAL_RCC_OscConfig+0x1ea>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000fd2:	f7ff f935 	bl	8000240 <HAL_GetTick>
 8000fd6:	1b80      	subs	r0, r0, r6
 8000fd8:	42b8      	cmp	r0, r7
 8000fda:	d9f7      	bls.n	8000fcc <HAL_RCC_OscConfig+0x234>
 8000fdc:	e723      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
 8000fde:	bf00      	nop
 8000fe0:	40023800 	.word	0x40023800
 8000fe4:	42470000 	.word	0x42470000
 8000fe8:	42470e80 	.word	0x42470e80
 8000fec:	40007000 	.word	0x40007000
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8000ff0:	4d2e      	ldr	r5, [pc, #184]	; (80010ac <HAL_RCC_OscConfig+0x314>)
 8000ff2:	68ab      	ldr	r3, [r5, #8]
 8000ff4:	f003 030c 	and.w	r3, r3, #12
 8000ff8:	2b08      	cmp	r3, #8
 8000ffa:	f43f aeec 	beq.w	8000dd6 <HAL_RCC_OscConfig+0x3e>
 8000ffe:	4e2c      	ldr	r6, [pc, #176]	; (80010b0 <HAL_RCC_OscConfig+0x318>)
 8001000:	2300      	movs	r3, #0
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001002:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001004:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001006:	d141      	bne.n	800108c <HAL_RCC_OscConfig+0x2f4>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001008:	f7ff f91a 	bl	8000240 <HAL_GetTick>
 800100c:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800100e:	682b      	ldr	r3, [r5, #0]
 8001010:	4f26      	ldr	r7, [pc, #152]	; (80010ac <HAL_RCC_OscConfig+0x314>)
 8001012:	0199      	lsls	r1, r3, #6
 8001014:	d42d      	bmi.n	8001072 <HAL_RCC_OscConfig+0x2da>
 8001016:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 800101a:	fa92 f2a2 	rbit	r2, r2
 800101e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001022:	fab2 fe82 	clz	lr, r2
 8001026:	fa93 f3a3 	rbit	r3, r3
 800102a:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 800102e:	fab3 f583 	clz	r5, r3
 8001032:	fa92 f2a2 	rbit	r2, r2
 8001036:	69e0      	ldr	r0, [r4, #28]
 8001038:	6a23      	ldr	r3, [r4, #32]
 800103a:	fab2 f182 	clz	r1, r2
 800103e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001040:	4303      	orrs	r3, r0
 8001042:	fa02 f20e 	lsl.w	r2, r2, lr
 8001046:	ea43 0002 	orr.w	r0, r3, r2
 800104a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800104c:	085a      	lsrs	r2, r3, #1
 800104e:	3a01      	subs	r2, #1
 8001050:	fa02 f305 	lsl.w	r3, r2, r5
 8001054:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001056:	4303      	orrs	r3, r0
 8001058:	408a      	lsls	r2, r1
 800105a:	4313      	orrs	r3, r2
 800105c:	607b      	str	r3, [r7, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800105e:	2301      	movs	r3, #1
 8001060:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001062:	f7ff f8ed 	bl	8000240 <HAL_GetTick>
 8001066:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001068:	683b      	ldr	r3, [r7, #0]
 800106a:	019a      	lsls	r2, r3, #6
 800106c:	d508      	bpl.n	8001080 <HAL_RCC_OscConfig+0x2e8>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800106e:	2000      	movs	r0, #0
 8001070:	e018      	b.n	80010a4 <HAL_RCC_OscConfig+0x30c>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001072:	f7ff f8e5 	bl	8000240 <HAL_GetTick>
 8001076:	ebc8 0000 	rsb	r0, r8, r0
 800107a:	2802      	cmp	r0, #2
 800107c:	d9c7      	bls.n	800100e <HAL_RCC_OscConfig+0x276>
 800107e:	e6d2      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001080:	f7ff f8de 	bl	8000240 <HAL_GetTick>
 8001084:	1b00      	subs	r0, r0, r4
 8001086:	2802      	cmp	r0, #2
 8001088:	d9ee      	bls.n	8001068 <HAL_RCC_OscConfig+0x2d0>
 800108a:	e6cc      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800108c:	f7ff f8d8 	bl	8000240 <HAL_GetTick>
 8001090:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001092:	682b      	ldr	r3, [r5, #0]
 8001094:	019b      	lsls	r3, r3, #6
 8001096:	d5ea      	bpl.n	800106e <HAL_RCC_OscConfig+0x2d6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001098:	f7ff f8d2 	bl	8000240 <HAL_GetTick>
 800109c:	1b00      	subs	r0, r0, r4
 800109e:	2802      	cmp	r0, #2
 80010a0:	d9f7      	bls.n	8001092 <HAL_RCC_OscConfig+0x2fa>
 80010a2:	e6c0      	b.n	8000e26 <HAL_RCC_OscConfig+0x8e>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80010a4:	b002      	add	sp, #8
 80010a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80010aa:	bf00      	nop
 80010ac:	40023800 	.word	0x40023800
 80010b0:	42470060 	.word	0x42470060

080010b4 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80010b4:	491b      	ldr	r1, [pc, #108]	; (8001124 <HAL_RCC_GetSysClockFreq+0x70>)
 80010b6:	688b      	ldr	r3, [r1, #8]
 80010b8:	f003 030c 	and.w	r3, r3, #12
 80010bc:	2b04      	cmp	r3, #4
 80010be:	d02c      	beq.n	800111a <HAL_RCC_GetSysClockFreq+0x66>
 80010c0:	2b08      	cmp	r3, #8
 80010c2:	d12c      	bne.n	800111e <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80010c4:	6848      	ldr	r0, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80010c6:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80010c8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80010cc:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80010d0:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 80010d4:	684b      	ldr	r3, [r1, #4]
 80010d6:	fa92 f2a2 	rbit	r2, r2
 80010da:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 80010de:	fab2 f282 	clz	r2, r2
 80010e2:	ea01 0103 	and.w	r1, r1, r3
 80010e6:	fa21 f102 	lsr.w	r1, r1, r2
 80010ea:	bf14      	ite	ne
 80010ec:	4a0e      	ldrne	r2, [pc, #56]	; (8001128 <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 80010ee:	4a0f      	ldreq	r2, [pc, #60]	; (800112c <HAL_RCC_GetSysClockFreq+0x78>)
 80010f0:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 80010f4:	4a0b      	ldr	r2, [pc, #44]	; (8001124 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 80010f6:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 80010fa:	6852      	ldr	r2, [r2, #4]
 80010fc:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001100:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8001104:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001108:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 800110c:	fa22 f000 	lsr.w	r0, r2, r0
 8001110:	3001      	adds	r0, #1
 8001112:	0040      	lsls	r0, r0, #1
 8001114:	fbb3 f0f0 	udiv	r0, r3, r0
 8001118:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800111a:	4803      	ldr	r0, [pc, #12]	; (8001128 <HAL_RCC_GetSysClockFreq+0x74>)
 800111c:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800111e:	4803      	ldr	r0, [pc, #12]	; (800112c <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001120:	4770      	bx	lr
 8001122:	bf00      	nop
 8001124:	40023800 	.word	0x40023800
 8001128:	007a1200 	.word	0x007a1200
 800112c:	00f42400 	.word	0x00f42400

08001130 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001130:	4b55      	ldr	r3, [pc, #340]	; (8001288 <HAL_RCC_ClockConfig+0x158>)
 8001132:	681a      	ldr	r2, [r3, #0]
 8001134:	f002 020f 	and.w	r2, r2, #15
 8001138:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800113a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800113e:	4605      	mov	r5, r0
 8001140:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001142:	d30a      	bcc.n	800115a <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001144:	6829      	ldr	r1, [r5, #0]
 8001146:	0788      	lsls	r0, r1, #30
 8001148:	d511      	bpl.n	800116e <HAL_RCC_ClockConfig+0x3e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800114a:	4850      	ldr	r0, [pc, #320]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 800114c:	6883      	ldr	r3, [r0, #8]
 800114e:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001152:	68ab      	ldr	r3, [r5, #8]
 8001154:	4313      	orrs	r3, r2
 8001156:	6083      	str	r3, [r0, #8]
 8001158:	e009      	b.n	800116e <HAL_RCC_ClockConfig+0x3e>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800115a:	b2ca      	uxtb	r2, r1
 800115c:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800115e:	681b      	ldr	r3, [r3, #0]
 8001160:	f003 030f 	and.w	r3, r3, #15
 8001164:	4299      	cmp	r1, r3
 8001166:	d0ed      	beq.n	8001144 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 8001168:	2001      	movs	r0, #1
 800116a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800116e:	07c9      	lsls	r1, r1, #31
 8001170:	d406      	bmi.n	8001180 <HAL_RCC_ClockConfig+0x50>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8001172:	4b45      	ldr	r3, [pc, #276]	; (8001288 <HAL_RCC_ClockConfig+0x158>)
 8001174:	681a      	ldr	r2, [r3, #0]
 8001176:	f002 020f 	and.w	r2, r2, #15
 800117a:	4296      	cmp	r6, r2
 800117c:	d351      	bcc.n	8001222 <HAL_RCC_ClockConfig+0xf2>
 800117e:	e057      	b.n	8001230 <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001180:	686b      	ldr	r3, [r5, #4]
 8001182:	4a42      	ldr	r2, [pc, #264]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 8001184:	2b01      	cmp	r3, #1
 8001186:	d103      	bne.n	8001190 <HAL_RCC_ClockConfig+0x60>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001188:	6812      	ldr	r2, [r2, #0]
 800118a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 800118e:	e008      	b.n	80011a2 <HAL_RCC_ClockConfig+0x72>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001190:	1e99      	subs	r1, r3, #2
 8001192:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001194:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001196:	d802      	bhi.n	800119e <HAL_RCC_ClockConfig+0x6e>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001198:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 800119c:	e001      	b.n	80011a2 <HAL_RCC_ClockConfig+0x72>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800119e:	f012 0f02 	tst.w	r2, #2
 80011a2:	d0e1      	beq.n	8001168 <HAL_RCC_ClockConfig+0x38>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80011a4:	4c39      	ldr	r4, [pc, #228]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 80011a6:	68a2      	ldr	r2, [r4, #8]
 80011a8:	f022 0203 	bic.w	r2, r2, #3
 80011ac:	4313      	orrs	r3, r2
 80011ae:	60a3      	str	r3, [r4, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80011b0:	f7ff f846 	bl	8000240 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80011b4:	686b      	ldr	r3, [r5, #4]
 80011b6:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80011b8:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80011ba:	f241 3888 	movw	r8, #5000	; 0x1388
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80011be:	d10c      	bne.n	80011da <HAL_RCC_ClockConfig+0xaa>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80011c0:	68a3      	ldr	r3, [r4, #8]
 80011c2:	f003 030c 	and.w	r3, r3, #12
 80011c6:	2b04      	cmp	r3, #4
 80011c8:	d0d3      	beq.n	8001172 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80011ca:	f7ff f839 	bl	8000240 <HAL_GetTick>
 80011ce:	1bc0      	subs	r0, r0, r7
 80011d0:	4540      	cmp	r0, r8
 80011d2:	d9f5      	bls.n	80011c0 <HAL_RCC_ClockConfig+0x90>
        {
          return HAL_TIMEOUT;
 80011d4:	2003      	movs	r0, #3
 80011d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80011da:	2b02      	cmp	r3, #2
 80011dc:	d10a      	bne.n	80011f4 <HAL_RCC_ClockConfig+0xc4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80011de:	68a3      	ldr	r3, [r4, #8]
 80011e0:	f003 030c 	and.w	r3, r3, #12
 80011e4:	2b08      	cmp	r3, #8
 80011e6:	d0c4      	beq.n	8001172 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80011e8:	f7ff f82a 	bl	8000240 <HAL_GetTick>
 80011ec:	1bc0      	subs	r0, r0, r7
 80011ee:	4540      	cmp	r0, r8
 80011f0:	d9f5      	bls.n	80011de <HAL_RCC_ClockConfig+0xae>
 80011f2:	e7ef      	b.n	80011d4 <HAL_RCC_ClockConfig+0xa4>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 80011f4:	2b03      	cmp	r3, #3
 80011f6:	d10f      	bne.n	8001218 <HAL_RCC_ClockConfig+0xe8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 80011f8:	68a3      	ldr	r3, [r4, #8]
 80011fa:	f003 030c 	and.w	r3, r3, #12
 80011fe:	2b0c      	cmp	r3, #12
 8001200:	d0b7      	beq.n	8001172 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001202:	f7ff f81d 	bl	8000240 <HAL_GetTick>
 8001206:	1bc0      	subs	r0, r0, r7
 8001208:	4540      	cmp	r0, r8
 800120a:	d9f5      	bls.n	80011f8 <HAL_RCC_ClockConfig+0xc8>
 800120c:	e7e2      	b.n	80011d4 <HAL_RCC_ClockConfig+0xa4>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800120e:	f7ff f817 	bl	8000240 <HAL_GetTick>
 8001212:	1bc0      	subs	r0, r0, r7
 8001214:	4540      	cmp	r0, r8
 8001216:	d8dd      	bhi.n	80011d4 <HAL_RCC_ClockConfig+0xa4>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001218:	68a3      	ldr	r3, [r4, #8]
 800121a:	f013 0f0c 	tst.w	r3, #12
 800121e:	d1f6      	bne.n	800120e <HAL_RCC_ClockConfig+0xde>
 8001220:	e7a7      	b.n	8001172 <HAL_RCC_ClockConfig+0x42>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001222:	b2f2      	uxtb	r2, r6
 8001224:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001226:	681b      	ldr	r3, [r3, #0]
 8001228:	f003 030f 	and.w	r3, r3, #15
 800122c:	429e      	cmp	r6, r3
 800122e:	d19b      	bne.n	8001168 <HAL_RCC_ClockConfig+0x38>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001230:	6829      	ldr	r1, [r5, #0]
 8001232:	074a      	lsls	r2, r1, #29
 8001234:	d506      	bpl.n	8001244 <HAL_RCC_ClockConfig+0x114>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001236:	4815      	ldr	r0, [pc, #84]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 8001238:	6883      	ldr	r3, [r0, #8]
 800123a:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800123e:	68eb      	ldr	r3, [r5, #12]
 8001240:	4313      	orrs	r3, r2
 8001242:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001244:	070b      	lsls	r3, r1, #28
 8001246:	d507      	bpl.n	8001258 <HAL_RCC_ClockConfig+0x128>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001248:	4a10      	ldr	r2, [pc, #64]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 800124a:	6929      	ldr	r1, [r5, #16]
 800124c:	6893      	ldr	r3, [r2, #8]
 800124e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001252:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001256:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001258:	f7ff ff2c 	bl	80010b4 <HAL_RCC_GetSysClockFreq>
 800125c:	4b0b      	ldr	r3, [pc, #44]	; (800128c <HAL_RCC_ClockConfig+0x15c>)
 800125e:	22f0      	movs	r2, #240	; 0xf0
 8001260:	689b      	ldr	r3, [r3, #8]
 8001262:	fa92 f2a2 	rbit	r2, r2
 8001266:	fab2 f282 	clz	r2, r2
 800126a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800126e:	40d3      	lsrs	r3, r2
 8001270:	4a07      	ldr	r2, [pc, #28]	; (8001290 <HAL_RCC_ClockConfig+0x160>)
 8001272:	5cd3      	ldrb	r3, [r2, r3]
 8001274:	40d8      	lsrs	r0, r3
 8001276:	4b07      	ldr	r3, [pc, #28]	; (8001294 <HAL_RCC_ClockConfig+0x164>)
 8001278:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 800127a:	2000      	movs	r0, #0
 800127c:	f7fe ffaa 	bl	80001d4 <HAL_InitTick>
  
  return HAL_OK;
 8001280:	2000      	movs	r0, #0
}
 8001282:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001286:	bf00      	nop
 8001288:	40023c00 	.word	0x40023c00
 800128c:	40023800 	.word	0x40023800
 8001290:	0800366e 	.word	0x0800366e
 8001294:	20000110 	.word	0x20000110

08001298 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001298:	4b01      	ldr	r3, [pc, #4]	; (80012a0 <HAL_RCC_GetHCLKFreq+0x8>)
 800129a:	6818      	ldr	r0, [r3, #0]
 800129c:	4770      	bx	lr
 800129e:	bf00      	nop
 80012a0:	20000110 	.word	0x20000110

080012a4 <SPI_WaitFlagStateUntilTimeout>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
{
 80012a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012a8:	9e06      	ldr	r6, [sp, #24]
 80012aa:	4604      	mov	r4, r0
 80012ac:	4688      	mov	r8, r1
 80012ae:	4617      	mov	r7, r2
 80012b0:	461d      	mov	r5, r3
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
 80012b2:	6822      	ldr	r2, [r4, #0]
 80012b4:	6893      	ldr	r3, [r2, #8]
 80012b6:	ea38 0303 	bics.w	r3, r8, r3
 80012ba:	bf0c      	ite	eq
 80012bc:	2301      	moveq	r3, #1
 80012be:	2300      	movne	r3, #0
 80012c0:	429f      	cmp	r7, r3
 80012c2:	d033      	beq.n	800132c <SPI_WaitFlagStateUntilTimeout+0x88>
  {
    if(Timeout != HAL_MAX_DELAY)
 80012c4:	1c6b      	adds	r3, r5, #1
 80012c6:	d0f5      	beq.n	80012b4 <SPI_WaitFlagStateUntilTimeout+0x10>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 80012c8:	b94d      	cbnz	r5, 80012de <SPI_WaitFlagStateUntilTimeout+0x3a>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80012ca:	6823      	ldr	r3, [r4, #0]
 80012cc:	685a      	ldr	r2, [r3, #4]
 80012ce:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80012d2:	605a      	str	r2, [r3, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80012d4:	6862      	ldr	r2, [r4, #4]
 80012d6:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80012da:	d111      	bne.n	8001300 <SPI_WaitFlagStateUntilTimeout+0x5c>
 80012dc:	e005      	b.n	80012ea <SPI_WaitFlagStateUntilTimeout+0x46>
{
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 80012de:	f7fe ffaf 	bl	8000240 <HAL_GetTick>
 80012e2:	1b80      	subs	r0, r0, r6
 80012e4:	4285      	cmp	r5, r0
 80012e6:	d8e4      	bhi.n	80012b2 <SPI_WaitFlagStateUntilTimeout+0xe>
 80012e8:	e7ef      	b.n	80012ca <SPI_WaitFlagStateUntilTimeout+0x26>
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80012ea:	68a2      	ldr	r2, [r4, #8]
 80012ec:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80012f0:	d002      	beq.n	80012f8 <SPI_WaitFlagStateUntilTimeout+0x54>
 80012f2:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80012f6:	d103      	bne.n	8001300 <SPI_WaitFlagStateUntilTimeout+0x5c>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 80012f8:	681a      	ldr	r2, [r3, #0]
 80012fa:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80012fe:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001300:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001302:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8001306:	d108      	bne.n	800131a <SPI_WaitFlagStateUntilTimeout+0x76>
        {
          SPI_RESET_CRC(hspi);
 8001308:	6819      	ldr	r1, [r3, #0]
 800130a:	f64d 72ff 	movw	r2, #57343	; 0xdfff
 800130e:	400a      	ands	r2, r1
 8001310:	601a      	str	r2, [r3, #0]
 8001312:	681a      	ldr	r2, [r3, #0]
 8001314:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001318:	601a      	str	r2, [r3, #0]
        }

        hspi->State= HAL_SPI_STATE_READY;
 800131a:	2301      	movs	r3, #1
 800131c:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8001320:	2300      	movs	r3, #0
 8001322:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8001326:	2003      	movs	r0, #3
 8001328:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 800132c:	2000      	movs	r0, #0
}
 800132e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001332 <SPI_CheckFlag_BSY>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001332:	b513      	push	{r0, r1, r4, lr}
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001334:	460b      	mov	r3, r1
 8001336:	9200      	str	r2, [sp, #0]
 8001338:	2180      	movs	r1, #128	; 0x80
 800133a:	2200      	movs	r2, #0
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800133c:	4604      	mov	r4, r0
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800133e:	f7ff ffb1 	bl	80012a4 <SPI_WaitFlagStateUntilTimeout>
 8001342:	b120      	cbz	r0, 800134e <SPI_CheckFlag_BSY+0x1c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001344:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001346:	f043 0320 	orr.w	r3, r3, #32
 800134a:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_TIMEOUT;
 800134c:	2003      	movs	r0, #3
  }
  return HAL_OK;
}
 800134e:	b002      	add	sp, #8
 8001350:	bd10      	pop	{r4, pc}

08001352 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001352:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 8001354:	4604      	mov	r4, r0
 8001356:	2800      	cmp	r0, #0
 8001358:	d036      	beq.n	80013c8 <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800135a:	2300      	movs	r3, #0
 800135c:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 800135e:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8001362:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001366:	b91b      	cbnz	r3, 8001370 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001368:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800136c:	f001 fdec 	bl	8002f48 <HAL_SPI_MspInit>
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001370:	68a1      	ldr	r1, [r4, #8]
 8001372:	6860      	ldr	r0, [r4, #4]
 8001374:	4308      	orrs	r0, r1
 8001376:	68e1      	ldr	r1, [r4, #12]
 8001378:	4308      	orrs	r0, r1
 800137a:	6921      	ldr	r1, [r4, #16]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800137c:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 800137e:	4308      	orrs	r0, r1
 8001380:	6961      	ldr	r1, [r4, #20]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001382:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001386:	6823      	ldr	r3, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001388:	4308      	orrs	r0, r1
 800138a:	69e1      	ldr	r1, [r4, #28]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800138c:	681a      	ldr	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 800138e:	4308      	orrs	r0, r1
 8001390:	6a21      	ldr	r1, [r4, #32]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001392:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001396:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001398:	4308      	orrs	r0, r1
 800139a:	69a2      	ldr	r2, [r4, #24]
 800139c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800139e:	4308      	orrs	r0, r1
 80013a0:	f402 7100 	and.w	r1, r2, #512	; 0x200
 80013a4:	4301      	orrs	r1, r0
 80013a6:	6019      	str	r1, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80013a8:	0c12      	lsrs	r2, r2, #16
 80013aa:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80013ac:	f002 0204 	and.w	r2, r2, #4
 80013b0:	430a      	orrs	r2, r1
 80013b2:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80013b4:	69da      	ldr	r2, [r3, #28]
 80013b6:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80013ba:	61da      	str	r2, [r3, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80013bc:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 80013be:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80013c0:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80013c2:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 80013c6:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 80013c8:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 80013ca:	bd10      	pop	{r4, pc}

080013cc <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80013cc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80013d0:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80013d2:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 80013d6:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80013d8:	4604      	mov	r4, r0
 80013da:	460d      	mov	r5, r1
 80013dc:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80013de:	f000 809e 	beq.w	800151e <HAL_SPI_Transmit+0x152>
 80013e2:	2301      	movs	r3, #1
 80013e4:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80013e8:	f7fe ff2a 	bl	8000240 <HAL_GetTick>
 80013ec:	4607      	mov	r7, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 80013ee:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 80013f2:	b2c0      	uxtb	r0, r0
 80013f4:	2801      	cmp	r0, #1
 80013f6:	f040 808a 	bne.w	800150e <HAL_SPI_Transmit+0x142>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0))
 80013fa:	2d00      	cmp	r5, #0
 80013fc:	f000 8088 	beq.w	8001510 <HAL_SPI_Transmit+0x144>
 8001400:	f1b8 0f00 	cmp.w	r8, #0
 8001404:	f000 8084 	beq.w	8001510 <HAL_SPI_Transmit+0x144>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001408:	2303      	movs	r3, #3
 800140a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800140e:	2300      	movs	r3, #0
 8001410:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001412:	63a3      	str	r3, [r4, #56]	; 0x38
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 8001414:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
 8001418:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800141a:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 800141c:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 800141e:	6423      	str	r3, [r4, #64]	; 0x40

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001420:	68a3      	ldr	r3, [r4, #8]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001422:	6325      	str	r5, [r4, #48]	; 0x30
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001424:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001428:	6823      	ldr	r3, [r4, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 800142a:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800142e:	bf02      	ittt	eq
 8001430:	681a      	ldreq	r2, [r3, #0]
 8001432:	f442 4280 	orreq.w	r2, r2, #16384	; 0x4000
 8001436:	601a      	streq	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001438:	681a      	ldr	r2, [r3, #0]
 800143a:	0652      	lsls	r2, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800143c:	bf5e      	ittt	pl
 800143e:	681a      	ldrpl	r2, [r3, #0]
 8001440:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 8001444:	601a      	strpl	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8001446:	68e2      	ldr	r2, [r4, #12]
 8001448:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800144c:	6862      	ldr	r2, [r4, #4]
 800144e:	d11e      	bne.n	800148e <HAL_SPI_Transmit+0xc2>
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 8001450:	b172      	cbz	r2, 8001470 <HAL_SPI_Transmit+0xa4>
 8001452:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8001454:	b292      	uxth	r2, r2
 8001456:	2a01      	cmp	r2, #1
 8001458:	d103      	bne.n	8001462 <HAL_SPI_Transmit+0x96>
 800145a:	e009      	b.n	8001470 <HAL_SPI_Transmit+0xa4>
          hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800145c:	b1ae      	cbz	r6, 800148a <HAL_SPI_Transmit+0xbe>
 800145e:	1c71      	adds	r1, r6, #1
 8001460:	d10e      	bne.n	8001480 <HAL_SPI_Transmit+0xb4>
      hspi->Instance->DR = *((uint16_t *)pData);
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8001462:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001464:	b29b      	uxth	r3, r3
 8001466:	b1d3      	cbz	r3, 800149e <HAL_SPI_Transmit+0xd2>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8001468:	6823      	ldr	r3, [r4, #0]
 800146a:	689a      	ldr	r2, [r3, #8]
 800146c:	0790      	lsls	r0, r2, #30
 800146e:	d5f5      	bpl.n	800145c <HAL_SPI_Transmit+0x90>
      {
          hspi->Instance->DR = *((uint16_t *)pData);
 8001470:	f835 2b02 	ldrh.w	r2, [r5], #2
 8001474:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount--;
 8001476:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001478:	3b01      	subs	r3, #1
 800147a:	b29b      	uxth	r3, r3
 800147c:	86e3      	strh	r3, [r4, #54]	; 0x36
 800147e:	e7f0      	b.n	8001462 <HAL_SPI_Transmit+0x96>
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8001480:	f7fe fede 	bl	8000240 <HAL_GetTick>
 8001484:	1bc0      	subs	r0, r0, r7
 8001486:	4286      	cmp	r6, r0
 8001488:	d8eb      	bhi.n	8001462 <HAL_SPI_Transmit+0x96>
        {
          errorcode = HAL_TIMEOUT;
 800148a:	2003      	movs	r0, #3
 800148c:	e040      	b.n	8001510 <HAL_SPI_Transmit+0x144>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 800148e:	b1a2      	cbz	r2, 80014ba <HAL_SPI_Transmit+0xee>
 8001490:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8001492:	b292      	uxth	r2, r2
 8001494:	2a01      	cmp	r2, #1
 8001496:	d010      	beq.n	80014ba <HAL_SPI_Transmit+0xee>
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
      pData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while (hspi->TxXferCount > 0U)
 8001498:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800149a:	b29b      	uxth	r3, r3
 800149c:	b94b      	cbnz	r3, 80014b2 <HAL_SPI_Transmit+0xe6>
      }
    }
  }

  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 800149e:	9700      	str	r7, [sp, #0]
 80014a0:	4633      	mov	r3, r6
 80014a2:	2201      	movs	r2, #1
 80014a4:	2102      	movs	r1, #2
 80014a6:	4620      	mov	r0, r4
 80014a8:	f7ff fefc 	bl	80012a4 <SPI_WaitFlagStateUntilTimeout>
 80014ac:	2800      	cmp	r0, #0
 80014ae:	d1ec      	bne.n	800148a <HAL_SPI_Transmit+0xbe>
 80014b0:	e015      	b.n	80014de <HAL_SPI_Transmit+0x112>
      hspi->TxXferCount--;
    }
    while (hspi->TxXferCount > 0U)
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80014b2:	6823      	ldr	r3, [r4, #0]
 80014b4:	689a      	ldr	r2, [r3, #8]
 80014b6:	0792      	lsls	r2, r2, #30
 80014b8:	d507      	bpl.n	80014ca <HAL_SPI_Transmit+0xfe>
      {
        *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
 80014ba:	f815 2b01 	ldrb.w	r2, [r5], #1
 80014be:	731a      	strb	r2, [r3, #12]
        pData += sizeof(uint8_t);
        hspi->TxXferCount--;
 80014c0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80014c2:	3b01      	subs	r3, #1
 80014c4:	b29b      	uxth	r3, r3
 80014c6:	86e3      	strh	r3, [r4, #54]	; 0x36
 80014c8:	e7e6      	b.n	8001498 <HAL_SPI_Transmit+0xcc>
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 80014ca:	2e00      	cmp	r6, #0
 80014cc:	d0dd      	beq.n	800148a <HAL_SPI_Transmit+0xbe>
 80014ce:	1c73      	adds	r3, r6, #1
 80014d0:	d0e2      	beq.n	8001498 <HAL_SPI_Transmit+0xcc>
 80014d2:	f7fe feb5 	bl	8000240 <HAL_GetTick>
 80014d6:	1bc0      	subs	r0, r0, r7
 80014d8:	4286      	cmp	r6, r0
 80014da:	d8dd      	bhi.n	8001498 <HAL_SPI_Transmit+0xcc>
 80014dc:	e7d5      	b.n	800148a <HAL_SPI_Transmit+0xbe>
    errorcode = HAL_TIMEOUT;
    goto error;
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 80014de:	463a      	mov	r2, r7
 80014e0:	4631      	mov	r1, r6
 80014e2:	4620      	mov	r0, r4
 80014e4:	f7ff ff25 	bl	8001332 <SPI_CheckFlag_BSY>
 80014e8:	b118      	cbz	r0, 80014f2 <HAL_SPI_Transmit+0x126>
  {
    errorcode = HAL_ERROR;
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80014ea:	2320      	movs	r3, #32
 80014ec:	6563      	str	r3, [r4, #84]	; 0x54
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
  {
    errorcode = HAL_ERROR;
 80014ee:	2001      	movs	r0, #1
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    goto error;
 80014f0:	e00e      	b.n	8001510 <HAL_SPI_Transmit+0x144>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80014f2:	68a3      	ldr	r3, [r4, #8]
 80014f4:	b933      	cbnz	r3, 8001504 <HAL_SPI_Transmit+0x138>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80014f6:	9303      	str	r3, [sp, #12]
 80014f8:	6823      	ldr	r3, [r4, #0]
 80014fa:	68da      	ldr	r2, [r3, #12]
 80014fc:	9203      	str	r2, [sp, #12]
 80014fe:	689b      	ldr	r3, [r3, #8]
 8001500:	9303      	str	r3, [sp, #12]
 8001502:	9b03      	ldr	r3, [sp, #12]
  {
     SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001504:	6d60      	ldr	r0, [r4, #84]	; 0x54
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8001506:	3000      	adds	r0, #0
 8001508:	bf18      	it	ne
 800150a:	2001      	movne	r0, #1
 800150c:	e000      	b.n	8001510 <HAL_SPI_Transmit+0x144>
 800150e:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 8001510:	2301      	movs	r3, #1
 8001512:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8001516:	2300      	movs	r3, #0
 8001518:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 800151c:	e000      	b.n	8001520 <HAL_SPI_Transmit+0x154>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800151e:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001520:	b004      	add	sp, #16
 8001522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001526 <HAL_SPI_TransmitReceive>:
  * @param  Size: amount of data to be sent and received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8001526:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800152a:	4698      	mov	r8, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800152c:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
  * @param  Size: amount of data to be sent and received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8001530:	b085      	sub	sp, #20

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001532:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent and received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8001534:	4604      	mov	r4, r0
 8001536:	460d      	mov	r5, r1
 8001538:	4616      	mov	r6, r2
 800153a:	9f0c      	ldr	r7, [sp, #48]	; 0x30

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800153c:	f000 80f9 	beq.w	8001732 <HAL_SPI_TransmitReceive+0x20c>
 8001540:	2301      	movs	r3, #1
 8001542:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001546:	f7fe fe7b 	bl	8000240 <HAL_GetTick>
  
  tmp  = hspi->State;
 800154a:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
  tmp1 = hspi->Init.Mode;
 800154e:	6861      	ldr	r1, [r4, #4]
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
  
  tmp  = hspi->State;
 8001550:	b2db      	uxtb	r3, r3
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
 8001552:	2b01      	cmp	r3, #1

  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001554:	4681      	mov	r9, r0
  
  tmp  = hspi->State;
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
 8001556:	d00a      	beq.n	800156e <HAL_SPI_TransmitReceive+0x48>
 8001558:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 800155c:	f040 80df 	bne.w	800171e <HAL_SPI_TransmitReceive+0x1f8>
    ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 8001560:	68a2      	ldr	r2, [r4, #8]
 8001562:	2a00      	cmp	r2, #0
 8001564:	f040 80db 	bne.w	800171e <HAL_SPI_TransmitReceive+0x1f8>
 8001568:	2b04      	cmp	r3, #4
 800156a:	f040 80d8 	bne.w	800171e <HAL_SPI_TransmitReceive+0x1f8>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
 800156e:	2d00      	cmp	r5, #0
 8001570:	f000 80d7 	beq.w	8001722 <HAL_SPI_TransmitReceive+0x1fc>
 8001574:	2e00      	cmp	r6, #0
 8001576:	f000 80d4 	beq.w	8001722 <HAL_SPI_TransmitReceive+0x1fc>
 800157a:	f1b8 0f00 	cmp.w	r8, #0
 800157e:	f000 80d0 	beq.w	8001722 <HAL_SPI_TransmitReceive+0x1fc>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if(hspi->State == HAL_SPI_STATE_READY)
 8001582:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8001586:	63a6      	str	r6, [r4, #56]	; 0x38
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if(hspi->State == HAL_SPI_STATE_READY)
 8001588:	2b01      	cmp	r3, #1
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800158a:	bf04      	itt	eq
 800158c:	2305      	moveq	r3, #5
 800158e:	f884 3051 	strbeq.w	r3, [r4, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001592:	2300      	movs	r3, #0
 8001594:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 8001596:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8001598:	6463      	str	r3, [r4, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 800159a:	6823      	ldr	r3, [r4, #0]
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
 800159c:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
 80015a0:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80015a4:	681a      	ldr	r2, [r3, #0]

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
 80015a6:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80015aa:	0650      	lsls	r0, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80015ac:	bf58      	it	pl
 80015ae:	681a      	ldrpl	r2, [r3, #0]
  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80015b0:	6325      	str	r5, [r4, #48]	; 0x30

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80015b2:	bf58      	it	pl
 80015b4:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;
 80015b8:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80015bc:	bf58      	it	pl
 80015be:	601a      	strpl	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80015c0:	68e2      	ldr	r2, [r4, #12]
 80015c2:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80015c6:	d150      	bne.n	800166a <HAL_SPI_TransmitReceive+0x144>
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80015c8:	b119      	cbz	r1, 80015d2 <HAL_SPI_TransmitReceive+0xac>
 80015ca:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80015cc:	b292      	uxth	r2, r2
 80015ce:	2a01      	cmp	r2, #1
 80015d0:	d106      	bne.n	80015e0 <HAL_SPI_TransmitReceive+0xba>
    {
      hspi->Instance->DR = *((uint16_t *)pTxData);
 80015d2:	f835 2b02 	ldrh.w	r2, [r5], #2
 80015d6:	60da      	str	r2, [r3, #12]
      pTxData += sizeof(uint16_t);
      hspi->TxXferCount--;
 80015d8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80015da:	3b01      	subs	r3, #1
 80015dc:	b29b      	uxth	r3, r3
 80015de:	86e3      	strh	r3, [r4, #54]	; 0x36
      {
        *((uint16_t *)pRxData) = hspi->Instance->DR;
        pRxData += sizeof(uint16_t);
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 80015e0:	f04f 0801 	mov.w	r8, #1
    {
      hspi->Instance->DR = *((uint16_t *)pTxData);
      pTxData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80015e4:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80015e6:	b29b      	uxth	r3, r3
 80015e8:	2b00      	cmp	r3, #0
 80015ea:	d02f      	beq.n	800164c <HAL_SPI_TransmitReceive+0x126>
    {
      /* Check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 80015ec:	f1b8 0f00 	cmp.w	r8, #0
 80015f0:	d012      	beq.n	8001618 <HAL_SPI_TransmitReceive+0xf2>
 80015f2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80015f4:	b29b      	uxth	r3, r3
 80015f6:	b16b      	cbz	r3, 8001614 <HAL_SPI_TransmitReceive+0xee>
 80015f8:	6823      	ldr	r3, [r4, #0]
 80015fa:	689a      	ldr	r2, [r3, #8]
 80015fc:	0791      	lsls	r1, r2, #30
 80015fe:	d509      	bpl.n	8001614 <HAL_SPI_TransmitReceive+0xee>
      {
        hspi->Instance->DR = *((uint16_t *)pTxData);
 8001600:	f835 2b02 	ldrh.w	r2, [r5], #2
 8001604:	60da      	str	r2, [r3, #12]
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount--;
 8001606:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001608:	3b01      	subs	r3, #1
 800160a:	b29b      	uxth	r3, r3
 800160c:	86e3      	strh	r3, [r4, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */ 
        txallowed = 0U;
 800160e:	f04f 0800 	mov.w	r8, #0
 8001612:	e001      	b.n	8001618 <HAL_SPI_TransmitReceive+0xf2>
      hspi->TxXferCount--;
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* Check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 8001614:	f04f 0801 	mov.w	r8, #1
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 8001618:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800161a:	b29b      	uxth	r3, r3
 800161c:	b163      	cbz	r3, 8001638 <HAL_SPI_TransmitReceive+0x112>
 800161e:	6823      	ldr	r3, [r4, #0]
 8001620:	689a      	ldr	r2, [r3, #8]
 8001622:	07d2      	lsls	r2, r2, #31
 8001624:	d508      	bpl.n	8001638 <HAL_SPI_TransmitReceive+0x112>
      {
        *((uint16_t *)pRxData) = hspi->Instance->DR;
 8001626:	68db      	ldr	r3, [r3, #12]
 8001628:	f826 3b02 	strh.w	r3, [r6], #2
        pRxData += sizeof(uint16_t);
        hspi->RxXferCount--;
 800162c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800162e:	3b01      	subs	r3, #1
 8001630:	b29b      	uxth	r3, r3
 8001632:	87e3      	strh	r3, [r4, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 8001634:	f04f 0801 	mov.w	r8, #1
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 8001638:	1c78      	adds	r0, r7, #1
 800163a:	d0d3      	beq.n	80015e4 <HAL_SPI_TransmitReceive+0xbe>
 800163c:	f7fe fe00 	bl	8000240 <HAL_GetTick>
 8001640:	ebc9 0000 	rsb	r0, r9, r0
 8001644:	4287      	cmp	r7, r0
 8001646:	d8cd      	bhi.n	80015e4 <HAL_SPI_TransmitReceive+0xbe>
      {
        errorcode = HAL_TIMEOUT;
 8001648:	2003      	movs	r0, #3
 800164a:	e06b      	b.n	8001724 <HAL_SPI_TransmitReceive+0x1fe>
    {
      hspi->Instance->DR = *((uint16_t *)pTxData);
      pTxData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800164c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800164e:	b29b      	uxth	r3, r3
 8001650:	2b00      	cmp	r3, #0
 8001652:	d1cb      	bne.n	80015ec <HAL_SPI_TransmitReceive+0xc6>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 8001654:	f8cd 9000 	str.w	r9, [sp]
 8001658:	463b      	mov	r3, r7
 800165a:	2201      	movs	r2, #1
 800165c:	2102      	movs	r1, #2
 800165e:	4620      	mov	r0, r4
 8001660:	f7ff fe20 	bl	80012a4 <SPI_WaitFlagStateUntilTimeout>
 8001664:	2800      	cmp	r0, #0
 8001666:	d1ef      	bne.n	8001648 <HAL_SPI_TransmitReceive+0x122>
 8001668:	e045      	b.n	80016f6 <HAL_SPI_TransmitReceive+0x1d0>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 800166a:	b119      	cbz	r1, 8001674 <HAL_SPI_TransmitReceive+0x14e>
 800166c:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 800166e:	b292      	uxth	r2, r2
 8001670:	2a01      	cmp	r2, #1
 8001672:	d106      	bne.n	8001682 <HAL_SPI_TransmitReceive+0x15c>
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
 8001674:	f815 2b01 	ldrb.w	r2, [r5], #1
 8001678:	731a      	strb	r2, [r3, #12]
      pTxData += sizeof(uint8_t);
      hspi->TxXferCount--;
 800167a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800167c:	3b01      	subs	r3, #1
 800167e:	b29b      	uxth	r3, r3
 8001680:	86e3      	strh	r3, [r4, #54]	; 0x36
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
      {
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 8001682:	f04f 0801 	mov.w	r8, #1
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
      pTxData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8001686:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001688:	b29b      	uxth	r3, r3
 800168a:	2b00      	cmp	r3, #0
 800168c:	d02e      	beq.n	80016ec <HAL_SPI_TransmitReceive+0x1c6>
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 800168e:	f1b8 0f00 	cmp.w	r8, #0
 8001692:	d012      	beq.n	80016ba <HAL_SPI_TransmitReceive+0x194>
 8001694:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001696:	b29b      	uxth	r3, r3
 8001698:	b16b      	cbz	r3, 80016b6 <HAL_SPI_TransmitReceive+0x190>
 800169a:	6823      	ldr	r3, [r4, #0]
 800169c:	689a      	ldr	r2, [r3, #8]
 800169e:	0791      	lsls	r1, r2, #30
 80016a0:	d509      	bpl.n	80016b6 <HAL_SPI_TransmitReceive+0x190>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016a2:	782a      	ldrb	r2, [r5, #0]
 80016a4:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 80016a6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80016a8:	3b01      	subs	r3, #1
 80016aa:	b29b      	uxth	r3, r3
 80016ac:	86e3      	strh	r3, [r4, #54]	; 0x36
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016ae:	3501      	adds	r5, #1
        hspi->TxXferCount--;
        /* Next Data is a reception (Rx). Tx not allowed */ 
        txallowed = 0U;
 80016b0:	f04f 0800 	mov.w	r8, #0
 80016b4:	e001      	b.n	80016ba <HAL_SPI_TransmitReceive+0x194>
      hspi->TxXferCount--;
    }
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 80016b6:	f04f 0801 	mov.w	r8, #1
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 80016ba:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016bc:	b29b      	uxth	r3, r3
 80016be:	b163      	cbz	r3, 80016da <HAL_SPI_TransmitReceive+0x1b4>
 80016c0:	6823      	ldr	r3, [r4, #0]
 80016c2:	689a      	ldr	r2, [r3, #8]
 80016c4:	07d2      	lsls	r2, r2, #31
 80016c6:	d508      	bpl.n	80016da <HAL_SPI_TransmitReceive+0x1b4>
      {
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
 80016c8:	68db      	ldr	r3, [r3, #12]
 80016ca:	7033      	strb	r3, [r6, #0]
        hspi->RxXferCount--;
 80016cc:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016ce:	3b01      	subs	r3, #1
 80016d0:	b29b      	uxth	r3, r3
 80016d2:	87e3      	strh	r3, [r4, #62]	; 0x3e
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
      {
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
 80016d4:	3601      	adds	r6, #1
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 80016d6:	f04f 0801 	mov.w	r8, #1
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 80016da:	1c7b      	adds	r3, r7, #1
 80016dc:	d0d3      	beq.n	8001686 <HAL_SPI_TransmitReceive+0x160>
 80016de:	f7fe fdaf 	bl	8000240 <HAL_GetTick>
 80016e2:	ebc9 0000 	rsb	r0, r9, r0
 80016e6:	4287      	cmp	r7, r0
 80016e8:	d8cd      	bhi.n	8001686 <HAL_SPI_TransmitReceive+0x160>
 80016ea:	e7ad      	b.n	8001648 <HAL_SPI_TransmitReceive+0x122>
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
      pTxData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80016ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016ee:	b29b      	uxth	r3, r3
 80016f0:	2b00      	cmp	r3, #0
 80016f2:	d1cc      	bne.n	800168e <HAL_SPI_TransmitReceive+0x168>
 80016f4:	e7ae      	b.n	8001654 <HAL_SPI_TransmitReceive+0x12e>
    errorcode = HAL_TIMEOUT;
    goto error;
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 80016f6:	464a      	mov	r2, r9
 80016f8:	4639      	mov	r1, r7
 80016fa:	4620      	mov	r0, r4
 80016fc:	f7ff fe19 	bl	8001332 <SPI_CheckFlag_BSY>
 8001700:	b110      	cbz	r0, 8001708 <HAL_SPI_TransmitReceive+0x1e2>
  {
    errorcode = HAL_ERROR;
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8001702:	2320      	movs	r3, #32
 8001704:	6563      	str	r3, [r4, #84]	; 0x54
 8001706:	e00c      	b.n	8001722 <HAL_SPI_TransmitReceive+0x1fc>
    goto error;
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001708:	68a3      	ldr	r3, [r4, #8]
 800170a:	b95b      	cbnz	r3, 8001724 <HAL_SPI_TransmitReceive+0x1fe>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800170c:	6822      	ldr	r2, [r4, #0]
 800170e:	9303      	str	r3, [sp, #12]
 8001710:	68d1      	ldr	r1, [r2, #12]
 8001712:	9103      	str	r1, [sp, #12]
 8001714:	6892      	ldr	r2, [r2, #8]
 8001716:	9203      	str	r2, [sp, #12]
 8001718:	9a03      	ldr	r2, [sp, #12]
  __IO uint16_t tmpreg1 = 0U;
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t txallowed = 1U;
  HAL_StatusTypeDef errorcode = HAL_OK;
 800171a:	4618      	mov	r0, r3
 800171c:	e002      	b.n	8001724 <HAL_SPI_TransmitReceive+0x1fe>
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
    ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 800171e:	2002      	movs	r0, #2
 8001720:	e000      	b.n	8001724 <HAL_SPI_TransmitReceive+0x1fe>
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 8001722:	2001      	movs	r0, #1
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
  }
  
error :
  hspi->State = HAL_SPI_STATE_READY;
 8001724:	2301      	movs	r3, #1
 8001726:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 800172a:	2300      	movs	r3, #0
 800172c:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8001730:	e000      	b.n	8001734 <HAL_SPI_TransmitReceive+0x20e>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001732:	2002      	movs	r0, #2
  
error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001734:	b005      	add	sp, #20
 8001736:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800173a <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800173a:	b084      	sub	sp, #16
 800173c:	b538      	push	{r3, r4, r5, lr}
 800173e:	ad05      	add	r5, sp, #20
 8001740:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8001744:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001746:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8001748:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800174a:	d117      	bne.n	800177c <USB_CoreInit+0x42>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800174c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800174e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001752:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8001754:	68c3      	ldr	r3, [r0, #12]
 8001756:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 800175a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800175e:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8001760:	68c3      	ldr	r3, [r0, #12]
 8001762:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001766:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1U)
 8001768:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800176a:	2b01      	cmp	r3, #1
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800176c:	bf02      	ittt	eq
 800176e:	68c3      	ldreq	r3, [r0, #12]
 8001770:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8001774:	60c3      	streq	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8001776:	f000 fc9d 	bl	80020b4 <USB_CoreReset>
 800177a:	e008      	b.n	800178e <USB_CoreInit+0x54>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800177c:	68c3      	ldr	r3, [r0, #12]
 800177e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001782:	60c3      	str	r3, [r0, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8001784:	f000 fc96 	bl	80020b4 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001788:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800178c:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 800178e:	9b08      	ldr	r3, [sp, #32]
 8001790:	2b01      	cmp	r3, #1
 8001792:	d107      	bne.n	80017a4 <USB_CoreInit+0x6a>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8001794:	68a3      	ldr	r3, [r4, #8]
 8001796:	f043 0306 	orr.w	r3, r3, #6
 800179a:	60a3      	str	r3, [r4, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800179c:	68a3      	ldr	r3, [r4, #8]
 800179e:	f043 0320 	orr.w	r3, r3, #32
 80017a2:	60a3      	str	r3, [r4, #8]
  }  

  return HAL_OK;
}
 80017a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80017a8:	2000      	movs	r0, #0
 80017aa:	b004      	add	sp, #16
 80017ac:	4770      	bx	lr

080017ae <USB_EnableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80017ae:	6883      	ldr	r3, [r0, #8]
 80017b0:	f043 0301 	orr.w	r3, r3, #1
 80017b4:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 80017b6:	2000      	movs	r0, #0
 80017b8:	4770      	bx	lr

080017ba <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80017ba:	6883      	ldr	r3, [r0, #8]
 80017bc:	f023 0301 	bic.w	r3, r3, #1
 80017c0:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 80017c2:	2000      	movs	r0, #0
 80017c4:	4770      	bx	lr

080017c6 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 80017c6:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 80017c8:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 80017ca:	2901      	cmp	r1, #1
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 80017cc:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80017d0:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 80017d2:	d104      	bne.n	80017de <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 80017d4:	68c3      	ldr	r3, [r0, #12]
 80017d6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80017da:	60c3      	str	r3, [r0, #12]
 80017dc:	e004      	b.n	80017e8 <USB_SetCurrentMode+0x22>
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 80017de:	b919      	cbnz	r1, 80017e8 <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 80017e0:	68c3      	ldr	r3, [r0, #12]
 80017e2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80017e6:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 80017e8:	2032      	movs	r0, #50	; 0x32
 80017ea:	f7fe fd2f 	bl	800024c <HAL_Delay>
  
  return HAL_OK;
}
 80017ee:	2000      	movs	r0, #0
 80017f0:	bd08      	pop	{r3, pc}
	...

080017f4 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80017f4:	b084      	sub	sp, #16
 80017f6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80017fa:	4604      	mov	r4, r0
 80017fc:	a807      	add	r0, sp, #28
 80017fe:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 8001802:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8001804:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8001806:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001808:	4688      	mov	r8, r1
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  if (cfg.vbus_sensing_enable == 0U)
 800180a:	b91e      	cbnz	r6, 8001814 <USB_DevInit+0x20>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800180c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001810:	63a3      	str	r3, [r4, #56]	; 0x38
 8001812:	e002      	b.n	800181a <USB_DevInit+0x26>
  }
  else
  {
    /* Enable VBUS */
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8001814:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001818:	63a3      	str	r3, [r4, #56]	; 0x38
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx || STM32F413xx || STM32F423xx  */
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800181a:	2300      	movs	r3, #0
 800181c:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001820:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001824:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001828:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800182a:	2b01      	cmp	r3, #1
  
  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
  
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800182c:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001830:	d106      	bne.n	8001840 <USB_DevInit+0x4c>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8001832:	9909      	ldr	r1, [sp, #36]	; 0x24
 8001834:	b129      	cbz	r1, 8001842 <USB_DevInit+0x4e>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8001836:	4619      	mov	r1, r3
 8001838:	4620      	mov	r0, r4
 800183a:	f000 f897 	bl	800196c <USB_SetDevSpeed>
 800183e:	e003      	b.n	8001848 <USB_DevInit+0x54>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 8001840:	2103      	movs	r1, #3
 8001842:	4620      	mov	r0, r4
 8001844:	f000 f892 	bl	800196c <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 8001848:	2110      	movs	r1, #16
 800184a:	4620      	mov	r0, r4
 800184c:	f000 f86c 	bl	8001928 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8001850:	4620      	mov	r0, r4
 8001852:	f000 f87b 	bl	800194c <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001856:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001858:	f04f 32ff 	mov.w	r2, #4294967295
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 800185c:	612b      	str	r3, [r5, #16]
 800185e:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0U;
 8001860:	616b      	str	r3, [r5, #20]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8001862:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001866:	61aa      	str	r2, [r5, #24]
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001868:	f04f 0eff 	mov.w	lr, #255	; 0xff
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 800186c:	61eb      	str	r3, [r5, #28]
 800186e:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001872:	4543      	cmp	r3, r8
 8001874:	d00c      	beq.n	8001890 <USB_DevInit+0x9c>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8001876:	f8d2 c000 	ldr.w	ip, [r2]
 800187a:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800187e:	bfb4      	ite	lt
 8001880:	6010      	strlt	r0, [r2, #0]
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8001882:	6011      	strge	r1, [r2, #0]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001884:	3301      	adds	r3, #1
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8001886:	6111      	str	r1, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8001888:	f8c2 e008 	str.w	lr, [r2, #8]
 800188c:	3220      	adds	r2, #32
 800188e:	e7f0      	b.n	8001872 <USB_DevInit+0x7e>
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001890:	2200      	movs	r2, #0
 8001892:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 8001896:	4611      	mov	r1, r2
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001898:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 800189c:	f04f 0eff 	mov.w	lr, #255	; 0xff
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80018a0:	4542      	cmp	r2, r8
 80018a2:	d00c      	beq.n	80018be <USB_DevInit+0xca>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80018a4:	f8d3 c000 	ldr.w	ip, [r3]
 80018a8:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 80018ac:	bfb4      	ite	lt
 80018ae:	6018      	strlt	r0, [r3, #0]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80018b0:	6019      	strge	r1, [r3, #0]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80018b2:	3201      	adds	r2, #1
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 80018b4:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 80018b6:	f8c3 e008 	str.w	lr, [r3, #8]
 80018ba:	3320      	adds	r3, #32
 80018bc:	e7f0      	b.n	80018a0 <USB_DevInit+0xac>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80018be:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 80018c0:	2f01      	cmp	r7, #1
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80018c2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80018c6:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 80018c8:	d108      	bne.n	80018dc <USB_DevInit+0xe8>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 80018ca:	4b15      	ldr	r3, [pc, #84]	; (8001920 <USB_DevInit+0x12c>)
 80018cc:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 80018ce:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80018d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80018d4:	f043 0303 	orr.w	r3, r3, #3
 80018d8:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 80018da:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 80018dc:	2300      	movs	r3, #0
 80018de:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 80018e0:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 80018e4:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 80018e6:	b91f      	cbnz	r7, 80018f0 <USB_DevInit+0xfc>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 80018e8:	69a3      	ldr	r3, [r4, #24]
 80018ea:	f043 0310 	orr.w	r3, r3, #16
 80018ee:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 80018f0:	69a2      	ldr	r2, [r4, #24]
 80018f2:	4b0c      	ldr	r3, [pc, #48]	; (8001924 <USB_DevInit+0x130>)
 80018f4:	4313      	orrs	r3, r2
 80018f6:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 80018f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80018fa:	b11b      	cbz	r3, 8001904 <USB_DevInit+0x110>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80018fc:	69a3      	ldr	r3, [r4, #24]
 80018fe:	f043 0308 	orr.w	r3, r3, #8
 8001902:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8001904:	2e01      	cmp	r6, #1
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8001906:	bf01      	itttt	eq
 8001908:	69a3      	ldreq	r3, [r4, #24]
 800190a:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 800190e:	f043 0304 	orreq.w	r3, r3, #4
 8001912:	61a3      	streq	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 8001914:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001918:	2000      	movs	r0, #0
 800191a:	b004      	add	sp, #16
 800191c:	4770      	bx	lr
 800191e:	bf00      	nop
 8001920:	00800100 	.word	0x00800100
 8001924:	803c3800 	.word	0x803c3800

08001928 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8001928:	0189      	lsls	r1, r1, #6
 800192a:	f041 0120 	orr.w	r1, r1, #32
 800192e:	4a06      	ldr	r2, [pc, #24]	; (8001948 <USB_FlushTxFifo+0x20>)
 8001930:	6101      	str	r1, [r0, #16]
  
  do
  {
    if (++count > 200000)
 8001932:	3a01      	subs	r2, #1
 8001934:	d005      	beq.n	8001942 <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8001936:	6903      	ldr	r3, [r0, #16]
 8001938:	f013 0320 	ands.w	r3, r3, #32
 800193c:	d1f9      	bne.n	8001932 <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 800193e:	4618      	mov	r0, r3
 8001940:	4770      	bx	lr
  
  do
  {
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
 8001942:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 8001944:	4770      	bx	lr
 8001946:	bf00      	nop
 8001948:	00030d41 	.word	0x00030d41

0800194c <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800194c:	2310      	movs	r3, #16
 800194e:	4a06      	ldr	r2, [pc, #24]	; (8001968 <USB_FlushRxFifo+0x1c>)
 8001950:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000)
 8001952:	3a01      	subs	r2, #1
 8001954:	d005      	beq.n	8001962 <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8001956:	6903      	ldr	r3, [r0, #16]
 8001958:	f013 0310 	ands.w	r3, r3, #16
 800195c:	d1f9      	bne.n	8001952 <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 800195e:	4618      	mov	r0, r3
 8001960:	4770      	bx	lr
  
  do
  {
    if (++count > 200000)
    {
      return HAL_TIMEOUT;
 8001962:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 8001964:	4770      	bx	lr
 8001966:	bf00      	nop
 8001968:	00030d41 	.word	0x00030d41

0800196c <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 800196c:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001970:	4319      	orrs	r1, r3
 8001972:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 8001976:	2000      	movs	r0, #0
 8001978:	4770      	bx	lr

0800197a <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800197a:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 800197e:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 8001982:	f013 0006 	ands.w	r0, r3, #6
 8001986:	d012      	beq.n	80019ae <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001988:	6893      	ldr	r3, [r2, #8]
 800198a:	f003 0306 	and.w	r3, r3, #6
 800198e:	2b02      	cmp	r3, #2
 8001990:	d00c      	beq.n	80019ac <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8001992:	6893      	ldr	r3, [r2, #8]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8001994:	f003 0306 	and.w	r3, r3, #6
 8001998:	2b06      	cmp	r3, #6
 800199a:	d007      	beq.n	80019ac <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800199c:	6893      	ldr	r3, [r2, #8]
 800199e:	f003 0306 	and.w	r3, r3, #6
 80019a2:	2b04      	cmp	r3, #4
  {
    speed = USB_OTG_SPEED_LOW;
 80019a4:	bf14      	ite	ne
 80019a6:	2000      	movne	r0, #0
 80019a8:	2002      	moveq	r0, #2
 80019aa:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 80019ac:	2003      	movs	r0, #3
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 80019ae:	4770      	bx	lr

080019b0 <USB_ActivateEndpoint>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 80019b0:	784b      	ldrb	r3, [r1, #1]
 80019b2:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 80019b6:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80019b8:	b570      	push	{r4, r5, r6, lr}
 80019ba:	780e      	ldrb	r6, [r1, #0]
  if (ep->is_in == 1U)
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 80019bc:	69d4      	ldr	r4, [r2, #28]
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 80019be:	d11b      	bne.n	80019f8 <USB_ActivateEndpoint+0x48>
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 80019c0:	40b3      	lsls	r3, r6
 80019c2:	b29b      	uxth	r3, r3
 80019c4:	4323      	orrs	r3, r4
 80019c6:	61d3      	str	r3, [r2, #28]
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 80019c8:	780e      	ldrb	r6, [r1, #0]
 80019ca:	f44f 6510 	mov.w	r5, #2304	; 0x900
 80019ce:	eb05 1546 	add.w	r5, r5, r6, lsl #5
 80019d2:	582b      	ldr	r3, [r5, r0]
 80019d4:	041a      	lsls	r2, r3, #16
 80019d6:	d42a      	bmi.n	8001a2e <USB_ActivateEndpoint+0x7e>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 80019d8:	582c      	ldr	r4, [r5, r0]
 80019da:	688a      	ldr	r2, [r1, #8]
 80019dc:	f044 5380 	orr.w	r3, r4, #268435456	; 0x10000000
 80019e0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80019e4:	f3c2 020a 	ubfx	r2, r2, #0, #11
 80019e8:	431a      	orrs	r2, r3
 80019ea:	78cb      	ldrb	r3, [r1, #3]
 80019ec:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
 80019f0:	ea43 5386 	orr.w	r3, r3, r6, lsl #22
 80019f4:	502b      	str	r3, [r5, r0]
 80019f6:	e01a      	b.n	8001a2e <USB_ActivateEndpoint+0x7e>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 80019f8:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 80019fc:	fa05 f306 	lsl.w	r3, r5, r6
 8001a00:	4323      	orrs	r3, r4
 8001a02:	61d3      	str	r3, [r2, #28]
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8001a04:	780c      	ldrb	r4, [r1, #0]
 8001a06:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001a0a:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8001a0e:	5823      	ldr	r3, [r4, r0]
 8001a10:	041b      	lsls	r3, r3, #16
 8001a12:	d40c      	bmi.n	8001a2e <USB_ActivateEndpoint+0x7e>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8001a14:	5822      	ldr	r2, [r4, r0]
 8001a16:	688b      	ldr	r3, [r1, #8]
 8001a18:	f3c3 050a 	ubfx	r5, r3, #0, #11
 8001a1c:	f042 5380 	orr.w	r3, r2, #268435456	; 0x10000000
 8001a20:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001a24:	78ca      	ldrb	r2, [r1, #3]
 8001a26:	432b      	orrs	r3, r5
 8001a28:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8001a2c:	5023      	str	r3, [r4, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 8001a2e:	2000      	movs	r0, #0
 8001a30:	bd70      	pop	{r4, r5, r6, pc}

08001a32 <USB_DeactivateEndpoint>:
 8001a32:	f000 b801 	b.w	8001a38 <USB_DeactivateDedicatedEndpoint>
	...

08001a38 <USB_DeactivateDedicatedEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
 8001a3a:	784b      	ldrb	r3, [r1, #1]
 8001a3c:	780a      	ldrb	r2, [r1, #0]
 8001a3e:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001a40:	4604      	mov	r4, r0
 8001a42:	460e      	mov	r6, r1
 8001a44:	f04f 0320 	mov.w	r3, #32
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
 8001a48:	d131      	bne.n	8001aae <USB_DeactivateDedicatedEndpoint+0x76>
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  
 8001a4a:	f44f 6110 	mov.w	r1, #2304	; 0x900
 8001a4e:	fb13 1202 	smlabb	r2, r3, r2, r1
    
    /* sets the NAK bit for the IN endpoint */
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
    
    /* Disable IN endpoint */
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;
 8001a52:	4f2f      	ldr	r7, [pc, #188]	; (8001b10 <USB_DeactivateDedicatedEndpoint+0xd8>)
  uint32_t count = 0U;
  
  /* Disable the IN endpoint */
  if (ep->is_in == 1U)
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_USBAEP;  
 8001a54:	5810      	ldr	r0, [r2, r0]
 8001a56:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8001a5a:	5110      	str	r0, [r2, r4]
    
    /* sets the NAK bit for the IN endpoint */
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8001a5c:	7832      	ldrb	r2, [r6, #0]
 8001a5e:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001a62:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8001a66:	5110      	str	r0, [r2, r4]
    
    /* Disable IN endpoint */
    USBx_INEP(ep->num)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS;
 8001a68:	7832      	ldrb	r2, [r6, #0]
 8001a6a:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001a6e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001a72:	5110      	str	r0, [r2, r4]
    
    do
    {
      if (++count > 200000U)
 8001a74:	3f01      	subs	r7, #1
 8001a76:	d101      	bne.n	8001a7c <USB_DeactivateDedicatedEndpoint+0x44>
      {
        return HAL_TIMEOUT;
 8001a78:	2003      	movs	r0, #3
 8001a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
    }
    
    /*Wait for  EPDISD endpoint disabled interrupt*/ 
    while ((USBx_INEP(ep->num)->DIEPINT & USB_OTG_DIEPCTL_EPDIS) == USB_OTG_DIEPCTL_EPDIS);
 8001a7c:	7832      	ldrb	r2, [r6, #0]
 8001a7e:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001a82:	4422      	add	r2, r4
 8001a84:	6890      	ldr	r0, [r2, #8]
 8001a86:	f010 4580 	ands.w	r5, r0, #1073741824	; 0x40000000
 8001a8a:	d1f3      	bne.n	8001a74 <USB_DeactivateDedicatedEndpoint+0x3c>
    
    
    /* Flush any data remaining in the TxFIFO */
    USB_FlushTxFifo(USBx , 0x10U);
 8001a8c:	2110      	movs	r1, #16
 8001a8e:	4620      	mov	r0, r4
 8001a90:	f7ff ff4a 	bl	8001928 <USB_FlushTxFifo>
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 8001a94:	7833      	ldrb	r3, [r6, #0]
 8001a96:	f8d4 181c 	ldr.w	r1, [r4, #2076]	; 0x81c
 8001a9a:	2201      	movs	r2, #1
 8001a9c:	fa02 f303 	lsl.w	r3, r2, r3
 8001aa0:	b29b      	uxth	r3, r3
 8001aa2:	ea21 0303 	bic.w	r3, r1, r3
 8001aa6:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
  }
  return HAL_OK;
 8001aaa:	4628      	mov	r0, r5
 8001aac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  
  }
  else /* Disable the OUT endpoint */
  {
    
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  
 8001aae:	f44f 6130 	mov.w	r1, #2816	; 0xb00
 8001ab2:	fb13 1202 	smlabb	r2, r3, r2, r1
    
    /* sets the NAK bit for the OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
    
    /* Disable OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;
 8001ab6:	4d16      	ldr	r5, [pc, #88]	; (8001b10 <USB_DeactivateDedicatedEndpoint+0xd8>)
  
  }
  else /* Disable the OUT endpoint */
  {
    
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;  
 8001ab8:	5880      	ldr	r0, [r0, r2]
 8001aba:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8001abe:	50a0      	str	r0, [r4, r2]
    
    /* sets the NAK bit for the OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8001ac0:	7832      	ldrb	r2, [r6, #0]
 8001ac2:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001ac6:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8001aca:	50a0      	str	r0, [r4, r2]
    
    /* Disable OUT endpoint */
    USBx_OUTEP(ep->num)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS;
 8001acc:	7832      	ldrb	r2, [r6, #0]
 8001ace:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001ad2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001ad6:	50a0      	str	r0, [r4, r2]
    
    do
    {
      if (++count > 200000U)
 8001ad8:	3d01      	subs	r5, #1
 8001ada:	d0cd      	beq.n	8001a78 <USB_DeactivateDedicatedEndpoint+0x40>
        return HAL_TIMEOUT;
      }
    }
    
    /*Wait for  EPDISD endpoint disabled interrupt*/ 
    while ((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS);
 8001adc:	7832      	ldrb	r2, [r6, #0]
 8001ade:	fb13 1202 	smlabb	r2, r3, r2, r1
 8001ae2:	4422      	add	r2, r4
 8001ae4:	6890      	ldr	r0, [r2, #8]
 8001ae6:	f010 0010 	ands.w	r0, r0, #16
 8001aea:	d1f5      	bne.n	8001ad8 <USB_DeactivateDedicatedEndpoint+0xa0>
    
    /* Set the "Clear the Global OUT NAK bit" to disable global OUT NAK mode */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8001aec:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
 8001af0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001af4:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
    
    /* Disable endpoint interrupts */
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));         
 8001af8:	7831      	ldrb	r1, [r6, #0]
 8001afa:	f8d4 281c 	ldr.w	r2, [r4, #2076]	; 0x81c
 8001afe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001b02:	408b      	lsls	r3, r1
 8001b04:	ea22 0303 	bic.w	r3, r2, r3
 8001b08:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
  }
  return HAL_OK;

}
 8001b0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001b0e:	bf00      	nop
 8001b10:	00030d41 	.word	0x00030d41

08001b14 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001b14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001b18:	784b      	ldrb	r3, [r1, #1]
 8001b1a:	780c      	ldrb	r4, [r1, #0]
 8001b1c:	2b01      	cmp	r3, #1
 8001b1e:	f04f 0520 	mov.w	r5, #32
 8001b22:	694b      	ldr	r3, [r1, #20]
 8001b24:	f040 809b 	bne.w	8001c5e <USB_EPStartXfer+0x14a>
 8001b28:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001b2c:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001b30:	4404      	add	r4, r0
 8001b32:	6927      	ldr	r7, [r4, #16]
  
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8001b34:	b9ab      	cbnz	r3, 8001b62 <USB_EPStartXfer+0x4e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001b36:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8001b3a:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8001b3e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001b40:	780c      	ldrb	r4, [r1, #0]
 8001b42:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001b46:	4404      	add	r4, r0
 8001b48:	6927      	ldr	r7, [r4, #16]
 8001b4a:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8001b4e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8001b50:	780c      	ldrb	r4, [r1, #0]
 8001b52:	fb15 6504 	smlabb	r5, r5, r4, r6
 8001b56:	4405      	add	r5, r0
 8001b58:	692c      	ldr	r4, [r5, #16]
 8001b5a:	0ce4      	lsrs	r4, r4, #19
 8001b5c:	04e4      	lsls	r4, r4, #19
 8001b5e:	612c      	str	r4, [r5, #16]
 8001b60:	e03f      	b.n	8001be2 <USB_EPStartXfer+0xce>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8001b62:	0cff      	lsrs	r7, r7, #19
 8001b64:	04ff      	lsls	r7, r7, #19
 8001b66:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001b68:	780c      	ldrb	r4, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8001b6a:	f8d1 c008 	ldr.w	ip, [r1, #8]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001b6e:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001b72:	4404      	add	r4, r0
 8001b74:	6927      	ldr	r7, [r4, #16]
 8001b76:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8001b7a:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8001b7e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8001b80:	780f      	ldrb	r7, [r1, #0]
 8001b82:	fb15 6707 	smlabb	r7, r5, r7, r6
 8001b86:	4407      	add	r7, r0
 8001b88:	eb03 040c 	add.w	r4, r3, ip
 8001b8c:	3c01      	subs	r4, #1
 8001b8e:	fbb4 f4fc 	udiv	r4, r4, ip
 8001b92:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8001d48 <USB_EPStartXfer+0x234>
 8001b96:	f8d7 e010 	ldr.w	lr, [r7, #16]
 8001b9a:	04e4      	lsls	r4, r4, #19
 8001b9c:	ea04 0c0c 	and.w	ip, r4, ip
 8001ba0:	ea4c 040e 	orr.w	r4, ip, lr
 8001ba4:	613c      	str	r4, [r7, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8001ba6:	780c      	ldrb	r4, [r1, #0]
 8001ba8:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001bac:	4404      	add	r4, r0
 8001bae:	f3c3 0e12 	ubfx	lr, r3, #0, #19
 8001bb2:	6927      	ldr	r7, [r4, #16]
 8001bb4:	ea4e 0707 	orr.w	r7, lr, r7
 8001bb8:	6127      	str	r7, [r4, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 8001bba:	78cc      	ldrb	r4, [r1, #3]
 8001bbc:	2c01      	cmp	r4, #1
 8001bbe:	f040 80ba 	bne.w	8001d36 <USB_EPStartXfer+0x222>
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 8001bc2:	780c      	ldrb	r4, [r1, #0]
 8001bc4:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001bc8:	4404      	add	r4, r0
 8001bca:	6927      	ldr	r7, [r4, #16]
 8001bcc:	f027 47c0 	bic.w	r7, r7, #1610612736	; 0x60000000
 8001bd0:	6127      	str	r7, [r4, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 8001bd2:	780c      	ldrb	r4, [r1, #0]
 8001bd4:	fb15 6504 	smlabb	r5, r5, r4, r6
 8001bd8:	4405      	add	r5, r0
 8001bda:	692c      	ldr	r4, [r5, #16]
 8001bdc:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8001be0:	612c      	str	r4, [r5, #16]
      }       
    }

    if (dma == 1U)
 8001be2:	2a01      	cmp	r2, #1
 8001be4:	d106      	bne.n	8001bf4 <USB_EPStartXfer+0xe0>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8001be6:	780c      	ldrb	r4, [r1, #0]
 8001be8:	690d      	ldr	r5, [r1, #16]
 8001bea:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8001bee:	f8c4 5914 	str.w	r5, [r4, #2324]	; 0x914
 8001bf2:	e00b      	b.n	8001c0c <USB_EPStartXfer+0xf8>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8001bf4:	78cc      	ldrb	r4, [r1, #3]
 8001bf6:	2c01      	cmp	r4, #1
 8001bf8:	d00b      	beq.n	8001c12 <USB_EPStartXfer+0xfe>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8001bfa:	b13b      	cbz	r3, 8001c0c <USB_EPStartXfer+0xf8>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 8001bfc:	780f      	ldrb	r7, [r1, #0]
 8001bfe:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8001c02:	2401      	movs	r4, #1
 8001c04:	40bc      	lsls	r4, r7
 8001c06:	432c      	orrs	r4, r5
 8001c08:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8001c0c:	78cc      	ldrb	r4, [r1, #3]
 8001c0e:	2c01      	cmp	r4, #1
 8001c10:	d111      	bne.n	8001c36 <USB_EPStartXfer+0x122>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8001c12:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 8001c16:	f414 7f80 	tst.w	r4, #256	; 0x100
 8001c1a:	780c      	ldrb	r4, [r1, #0]
 8001c1c:	f04f 0520 	mov.w	r5, #32
 8001c20:	f44f 6610 	mov.w	r6, #2304	; 0x900
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8001c24:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001c28:	5825      	ldr	r5, [r4, r0]
 8001c2a:	bf0c      	ite	eq
 8001c2c:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8001c30:	f045 5580 	orrne.w	r5, r5, #268435456	; 0x10000000
 8001c34:	5025      	str	r5, [r4, r0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8001c36:	780d      	ldrb	r5, [r1, #0]
 8001c38:	f44f 6410 	mov.w	r4, #2304	; 0x900
 8001c3c:	eb04 1445 	add.w	r4, r4, r5, lsl #5
 8001c40:	5905      	ldr	r5, [r0, r4]
 8001c42:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 8001c46:	5105      	str	r5, [r0, r4]
    
    if (ep->type == EP_TYPE_ISOC)
 8001c48:	78cc      	ldrb	r4, [r1, #3]
 8001c4a:	2c01      	cmp	r4, #1
 8001c4c:	d177      	bne.n	8001d3e <USB_EPStartXfer+0x22a>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 8001c4e:	780c      	ldrb	r4, [r1, #0]
 8001c50:	9200      	str	r2, [sp, #0]
 8001c52:	b29b      	uxth	r3, r3
 8001c54:	4622      	mov	r2, r4
 8001c56:	68c9      	ldr	r1, [r1, #12]
 8001c58:	f000 f921 	bl	8001e9e <USB_WritePacket>
 8001c5c:	e06f      	b.n	8001d3e <USB_EPStartXfer+0x22a>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001c5e:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 8001c62:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001c66:	4404      	add	r4, r0
 8001c68:	6927      	ldr	r7, [r4, #16]
 8001c6a:	0cff      	lsrs	r7, r7, #19
 8001c6c:	04ff      	lsls	r7, r7, #19
 8001c6e:	6127      	str	r7, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001c70:	780c      	ldrb	r4, [r1, #0]
 8001c72:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001c76:	4404      	add	r4, r0
 8001c78:	6927      	ldr	r7, [r4, #16]
 8001c7a:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8001c7e:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8001c82:	6127      	str	r7, [r4, #16]
 8001c84:	780c      	ldrb	r4, [r1, #0]
 8001c86:	688f      	ldr	r7, [r1, #8]

    if (ep->xfer_len == 0U)
 8001c88:	b983      	cbnz	r3, 8001cac <USB_EPStartXfer+0x198>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001c8a:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001c8e:	4404      	add	r4, r0
 8001c90:	f3c7 0712 	ubfx	r7, r7, #0, #19
 8001c94:	6923      	ldr	r3, [r4, #16]
 8001c96:	431f      	orrs	r7, r3
 8001c98:	6127      	str	r7, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001c9a:	780b      	ldrb	r3, [r1, #0]
 8001c9c:	fb15 6503 	smlabb	r5, r5, r3, r6
 8001ca0:	4405      	add	r5, r0
 8001ca2:	692b      	ldr	r3, [r5, #16]
 8001ca4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001ca8:	612b      	str	r3, [r5, #16]
 8001caa:	e01d      	b.n	8001ce8 <USB_EPStartXfer+0x1d4>
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001cac:	fb15 6404 	smlabb	r4, r5, r4, r6
 8001cb0:	4404      	add	r4, r0
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8001cb2:	443b      	add	r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001cb4:	f8df c090 	ldr.w	ip, [pc, #144]	; 8001d48 <USB_EPStartXfer+0x234>
 8001cb8:	f8d4 e010 	ldr.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8001cbc:	3b01      	subs	r3, #1
 8001cbe:	fbb3 f3f7 	udiv	r3, r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001cc2:	ea4f 48c3 	mov.w	r8, r3, lsl #19
 8001cc6:	ea08 0c0c 	and.w	ip, r8, ip
 8001cca:	ea4c 0e0e 	orr.w	lr, ip, lr
 8001cce:	f8c4 e010 	str.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 8001cd2:	780c      	ldrb	r4, [r1, #0]
 8001cd4:	fb15 6504 	smlabb	r5, r5, r4, r6
 8001cd8:	4405      	add	r5, r0
 8001cda:	b29b      	uxth	r3, r3
 8001cdc:	692c      	ldr	r4, [r5, #16]
 8001cde:	435f      	muls	r7, r3
 8001ce0:	f3c7 0712 	ubfx	r7, r7, #0, #19
 8001ce4:	4327      	orrs	r7, r4
 8001ce6:	612f      	str	r7, [r5, #16]
    }

    if (dma == 1U)
 8001ce8:	2a01      	cmp	r2, #1
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8001cea:	bf01      	itttt	eq
 8001cec:	780b      	ldrbeq	r3, [r1, #0]
 8001cee:	68ca      	ldreq	r2, [r1, #12]
 8001cf0:	eb00 1343 	addeq.w	r3, r0, r3, lsl #5
 8001cf4:	f8c3 2b14 	streq.w	r2, [r3, #2836]	; 0xb14
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8001cf8:	78cb      	ldrb	r3, [r1, #3]
 8001cfa:	2b01      	cmp	r3, #1
 8001cfc:	d111      	bne.n	8001d22 <USB_EPStartXfer+0x20e>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8001cfe:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001d02:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001d06:	780b      	ldrb	r3, [r1, #0]
 8001d08:	f04f 0220 	mov.w	r2, #32
 8001d0c:	f44f 6430 	mov.w	r4, #2816	; 0xb00
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8001d10:	fb12 4303 	smlabb	r3, r2, r3, r4
 8001d14:	58c2      	ldr	r2, [r0, r3]
 8001d16:	bf0c      	ite	eq
 8001d18:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8001d1c:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 8001d20:	50c2      	str	r2, [r0, r3]
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8001d22:	780a      	ldrb	r2, [r1, #0]
 8001d24:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001d28:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001d2c:	58c2      	ldr	r2, [r0, r3]
 8001d2e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001d32:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
 8001d34:	e003      	b.n	8001d3e <USB_EPStartXfer+0x22a>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
      }       
    }

    if (dma == 1U)
 8001d36:	2a01      	cmp	r2, #1
 8001d38:	f47f af5f 	bne.w	8001bfa <USB_EPStartXfer+0xe6>
 8001d3c:	e753      	b.n	8001be6 <USB_EPStartXfer+0xd2>
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
  }
  return HAL_OK;
}
 8001d3e:	2000      	movs	r0, #0
 8001d40:	b002      	add	sp, #8
 8001d42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001d46:	bf00      	nop
 8001d48:	1ff80000 	.word	0x1ff80000

08001d4c <USB_EP0StartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001d4c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001d4e:	784b      	ldrb	r3, [r1, #1]
 8001d50:	694d      	ldr	r5, [r1, #20]
 8001d52:	2b01      	cmp	r3, #1
 8001d54:	f04f 0420 	mov.w	r4, #32
 8001d58:	780b      	ldrb	r3, [r1, #0]
 8001d5a:	d162      	bne.n	8001e22 <USB_EP0StartXfer+0xd6>
 8001d5c:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001d60:	fb14 6303 	smlabb	r3, r4, r3, r6
 8001d64:	4403      	add	r3, r0
{
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8001d66:	b9b5      	cbnz	r5, 8001d96 <USB_EP0StartXfer+0x4a>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001d68:	691d      	ldr	r5, [r3, #16]
 8001d6a:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 8001d6e:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 8001d72:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001d74:	780b      	ldrb	r3, [r1, #0]
 8001d76:	fb14 6303 	smlabb	r3, r4, r3, r6
 8001d7a:	4403      	add	r3, r0
 8001d7c:	691d      	ldr	r5, [r3, #16]
 8001d7e:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8001d82:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8001d84:	780b      	ldrb	r3, [r1, #0]
 8001d86:	fb14 6403 	smlabb	r4, r4, r3, r6
 8001d8a:	4404      	add	r4, r0
 8001d8c:	6923      	ldr	r3, [r4, #16]
 8001d8e:	0cdb      	lsrs	r3, r3, #19
 8001d90:	04db      	lsls	r3, r3, #19
 8001d92:	6123      	str	r3, [r4, #16]
 8001d94:	e026      	b.n	8001de4 <USB_EP0StartXfer+0x98>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8001d96:	691f      	ldr	r7, [r3, #16]
 8001d98:	0cff      	lsrs	r7, r7, #19
 8001d9a:	04ff      	lsls	r7, r7, #19
 8001d9c:	611f      	str	r7, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001d9e:	780b      	ldrb	r3, [r1, #0]
 8001da0:	fb14 6403 	smlabb	r4, r4, r3, r6
 8001da4:	4404      	add	r4, r0
 8001da6:	6923      	ldr	r3, [r4, #16]
 8001da8:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8001dac:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8001db0:	6123      	str	r3, [r4, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 8001db2:	688b      	ldr	r3, [r1, #8]
 8001db4:	429d      	cmp	r5, r3
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001db6:	780d      	ldrb	r5, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 8001db8:	bf88      	it	hi
 8001dba:	614b      	strhi	r3, [r1, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001dbc:	2420      	movs	r4, #32
 8001dbe:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001dc2:	fb14 3505 	smlabb	r5, r4, r5, r3
 8001dc6:	4405      	add	r5, r0
 8001dc8:	692e      	ldr	r6, [r5, #16]
 8001dca:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8001dce:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8001dd0:	780d      	ldrb	r5, [r1, #0]
 8001dd2:	fb14 3305 	smlabb	r3, r4, r5, r3
 8001dd6:	4403      	add	r3, r0
 8001dd8:	694c      	ldr	r4, [r1, #20]
 8001dda:	691d      	ldr	r5, [r3, #16]
 8001ddc:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8001de0:	432c      	orrs	r4, r5
 8001de2:	611c      	str	r4, [r3, #16]
    
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);     
 8001de4:	780c      	ldrb	r4, [r1, #0]
 8001de6:	2320      	movs	r3, #32
 8001de8:	f44f 6610 	mov.w	r6, #2304	; 0x900
 8001dec:	fb13 6404 	smlabb	r4, r3, r4, r6
    
    if (dma == 1)
 8001df0:	2a01      	cmp	r2, #1
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);     
 8001df2:	5825      	ldr	r5, [r4, r0]
 8001df4:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 8001df8:	5025      	str	r5, [r4, r0]
    
    if (dma == 1)
 8001dfa:	d106      	bne.n	8001e0a <USB_EP0StartXfer+0xbe>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8001dfc:	780a      	ldrb	r2, [r1, #0]
 8001dfe:	fb13 6302 	smlabb	r3, r3, r2, r6
 8001e02:	4418      	add	r0, r3
 8001e04:	690b      	ldr	r3, [r1, #16]
 8001e06:	6143      	str	r3, [r0, #20]
 8001e08:	e047      	b.n	8001e9a <USB_EP0StartXfer+0x14e>
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 8001e0a:	694b      	ldr	r3, [r1, #20]
 8001e0c:	2b00      	cmp	r3, #0
 8001e0e:	d044      	beq.n	8001e9a <USB_EP0StartXfer+0x14e>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 8001e10:	7809      	ldrb	r1, [r1, #0]
 8001e12:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8001e16:	2301      	movs	r3, #1
 8001e18:	408b      	lsls	r3, r1
 8001e1a:	4313      	orrs	r3, r2
 8001e1c:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
 8001e20:	e03b      	b.n	8001e9a <USB_EP0StartXfer+0x14e>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001e22:	f44f 6730 	mov.w	r7, #2816	; 0xb00
 8001e26:	fb14 7303 	smlabb	r3, r4, r3, r7
 8001e2a:	4403      	add	r3, r0
 8001e2c:	691e      	ldr	r6, [r3, #16]
 8001e2e:	0cf6      	lsrs	r6, r6, #19
 8001e30:	04f6      	lsls	r6, r6, #19
 8001e32:	611e      	str	r6, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001e34:	780b      	ldrb	r3, [r1, #0]
 8001e36:	fb14 7303 	smlabb	r3, r4, r3, r7
 8001e3a:	4403      	add	r3, r0
 8001e3c:	691e      	ldr	r6, [r3, #16]
 8001e3e:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8001e42:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8001e46:	611e      	str	r6, [r3, #16]
 8001e48:	688e      	ldr	r6, [r1, #8]
      
    if (ep->xfer_len > 0U)
 8001e4a:	b105      	cbz	r5, 8001e4e <USB_EP0StartXfer+0x102>
    {
      ep->xfer_len = ep->maxpacket;
 8001e4c:	614e      	str	r6, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001e4e:	780b      	ldrb	r3, [r1, #0]
 8001e50:	f44f 6530 	mov.w	r5, #2816	; 0xb00
 8001e54:	fb14 5303 	smlabb	r3, r4, r3, r5
 8001e58:	4403      	add	r3, r0
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001e5a:	f3c6 0612 	ubfx	r6, r6, #0, #19
    if (ep->xfer_len > 0U)
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001e5e:	691f      	ldr	r7, [r3, #16]
 8001e60:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8001e64:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001e66:	780b      	ldrb	r3, [r1, #0]
 8001e68:	fb14 5403 	smlabb	r4, r4, r3, r5
 8001e6c:	4404      	add	r4, r0
    

    if (dma == 1U)
 8001e6e:	2a01      	cmp	r2, #1
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001e70:	6923      	ldr	r3, [r4, #16]
 8001e72:	ea46 0603 	orr.w	r6, r6, r3
 8001e76:	6126      	str	r6, [r4, #16]
    

    if (dma == 1U)
 8001e78:	d106      	bne.n	8001e88 <USB_EP0StartXfer+0x13c>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8001e7a:	780b      	ldrb	r3, [r1, #0]
 8001e7c:	2220      	movs	r2, #32
 8001e7e:	fb12 5303 	smlabb	r3, r2, r3, r5
 8001e82:	4403      	add	r3, r0
 8001e84:	68ca      	ldr	r2, [r1, #12]
 8001e86:	615a      	str	r2, [r3, #20]
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 8001e88:	780a      	ldrb	r2, [r1, #0]
 8001e8a:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001e8e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001e92:	58c2      	ldr	r2, [r0, r3]
 8001e94:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001e98:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8001e9a:	2000      	movs	r0, #0
 8001e9c:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001e9e <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8001e9e:	b510      	push	{r4, lr}
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 8001ea0:	f89d 4008 	ldrb.w	r4, [sp, #8]
 8001ea4:	b96c      	cbnz	r4, 8001ec2 <USB_WritePacket+0x24>
 8001ea6:	3303      	adds	r3, #3
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8001ea8:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8001eac:	f023 0303 	bic.w	r3, r3, #3
 8001eb0:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 8001eb4:	440b      	add	r3, r1
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
 8001eb6:	4299      	cmp	r1, r3
 8001eb8:	d003      	beq.n	8001ec2 <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8001eba:	f851 0b04 	ldr.w	r0, [r1], #4
 8001ebe:	6010      	str	r0, [r2, #0]
 8001ec0:	e7f9      	b.n	8001eb6 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 8001ec2:	2000      	movs	r0, #0
 8001ec4:	bd10      	pop	{r4, pc}

08001ec6 <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8001ec6:	3203      	adds	r2, #3
 8001ec8:	f022 0203 	bic.w	r2, r2, #3
 8001ecc:	440a      	add	r2, r1
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 8001ece:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 8001ed2:	4291      	cmp	r1, r2
 8001ed4:	d003      	beq.n	8001ede <USB_ReadPacket+0x18>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 8001ed6:	6803      	ldr	r3, [r0, #0]
 8001ed8:	f841 3b04 	str.w	r3, [r1], #4
 8001edc:	e7f9      	b.n	8001ed2 <USB_ReadPacket+0xc>
    
  }
  return ((void *)dest);
}
 8001ede:	4608      	mov	r0, r1
 8001ee0:	4770      	bx	lr

08001ee2 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8001ee2:	784b      	ldrb	r3, [r1, #1]
 8001ee4:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 8001ee6:	b510      	push	{r4, lr}
 8001ee8:	f04f 0220 	mov.w	r2, #32
 8001eec:	780c      	ldrb	r4, [r1, #0]
  if (ep->is_in == 1U)
 8001eee:	d114      	bne.n	8001f1a <USB_EPSetStall+0x38>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 8001ef0:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001ef4:	fb12 3304 	smlabb	r3, r2, r4, r3
 8001ef8:	58c2      	ldr	r2, [r0, r3]
 8001efa:	2a00      	cmp	r2, #0
    {
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 8001efc:	bfa2      	ittt	ge
 8001efe:	58c2      	ldrge	r2, [r0, r3]
 8001f00:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 8001f04:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8001f06:	780a      	ldrb	r2, [r1, #0]
 8001f08:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001f0c:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001f10:	58c2      	ldr	r2, [r0, r3]
 8001f12:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001f16:	50c2      	str	r2, [r0, r3]
 8001f18:	e013      	b.n	8001f42 <USB_EPSetStall+0x60>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 8001f1a:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001f1e:	fb12 3304 	smlabb	r3, r2, r4, r3
 8001f22:	58c2      	ldr	r2, [r0, r3]
 8001f24:	2a00      	cmp	r2, #0
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8001f26:	bfa2      	ittt	ge
 8001f28:	58c2      	ldrge	r2, [r0, r3]
 8001f2a:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 8001f2e:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8001f30:	780a      	ldrb	r2, [r1, #0]
 8001f32:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001f36:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001f3a:	58c2      	ldr	r2, [r0, r3]
 8001f3c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001f40:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8001f42:	2000      	movs	r0, #0
 8001f44:	bd10      	pop	{r4, pc}

08001f46 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8001f46:	784b      	ldrb	r3, [r1, #1]
 8001f48:	2b01      	cmp	r3, #1
 8001f4a:	780b      	ldrb	r3, [r1, #0]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001f4c:	b530      	push	{r4, r5, lr}
 8001f4e:	f04f 0220 	mov.w	r2, #32
  if (ep->is_in == 1U)
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8001f52:	bf0c      	ite	eq
 8001f54:	f44f 6510 	moveq.w	r5, #2304	; 0x900
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8001f58:	f44f 6530 	movne.w	r5, #2816	; 0xb00
 8001f5c:	fb12 5303 	smlabb	r3, r2, r3, r5
 8001f60:	581c      	ldr	r4, [r3, r0]
 8001f62:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
 8001f66:	501c      	str	r4, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8001f68:	78cb      	ldrb	r3, [r1, #3]
 8001f6a:	3b02      	subs	r3, #2
 8001f6c:	2b01      	cmp	r3, #1
 8001f6e:	d806      	bhi.n	8001f7e <USB_EPClearStall+0x38>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8001f70:	780b      	ldrb	r3, [r1, #0]
 8001f72:	fb12 5203 	smlabb	r2, r2, r3, r5
 8001f76:	5813      	ldr	r3, [r2, r0]
 8001f78:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001f7c:	5013      	str	r3, [r2, r0]
    }    
  }
  return HAL_OK;
}
 8001f7e:	2000      	movs	r0, #0
 8001f80:	bd30      	pop	{r4, r5, pc}

08001f82 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 8001f82:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001f86:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8001f8a:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 8001f8e:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001f92:	0109      	lsls	r1, r1, #4
 8001f94:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 8001f98:	430b      	orrs	r3, r1
 8001f9a:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 8001f9e:	2000      	movs	r0, #0
 8001fa0:	4770      	bx	lr

08001fa2 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 8001fa2:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 8001fa4:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001fa8:	f023 0302 	bic.w	r3, r3, #2
 8001fac:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8001fb0:	2003      	movs	r0, #3
 8001fb2:	f7fe f94b 	bl	800024c <HAL_Delay>
  
  return HAL_OK;  
}
 8001fb6:	2000      	movs	r0, #0
 8001fb8:	bd08      	pop	{r3, pc}

08001fba <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 8001fba:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 8001fbc:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001fc0:	f043 0302 	orr.w	r3, r3, #2
 8001fc4:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8001fc8:	2003      	movs	r0, #3
 8001fca:	f7fe f93f 	bl	800024c <HAL_Delay>
  
  return HAL_OK;  
}
 8001fce:	2000      	movs	r0, #0
 8001fd0:	bd08      	pop	{r3, pc}

08001fd2 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 8001fd2:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 8001fd4:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 8001fd6:	4010      	ands	r0, r2
 8001fd8:	4770      	bx	lr

08001fda <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8001fda:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8001fde:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 8001fe2:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xffff0000U) >> 16U);
 8001fe4:	4018      	ands	r0, r3
}
 8001fe6:	0c00      	lsrs	r0, r0, #16
 8001fe8:	4770      	bx	lr

08001fea <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8001fea:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8001fee:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 8001ff2:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xFFFFU));
 8001ff4:	4018      	ands	r0, r3
}
 8001ff6:	b280      	uxth	r0, r0
 8001ff8:	4770      	bx	lr

08001ffa <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8001ffa:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8001ffe:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 8002002:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8002006:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 8002008:	6940      	ldr	r0, [r0, #20]
  return v;
}
 800200a:	4010      	ands	r0, r2
 800200c:	4770      	bx	lr

0800200e <USB_ReadDevInEPInterrupt>:
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 800200e:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8002012:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8002016:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 800201a:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  return v;
 800201e:	fa23 f101 	lsr.w	r1, r3, r1
 8002022:	01c9      	lsls	r1, r1, #7
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8002024:	6880      	ldr	r0, [r0, #8]
  return v;
 8002026:	b2c9      	uxtb	r1, r1
 8002028:	4311      	orrs	r1, r2
}
 800202a:	4008      	ands	r0, r1
 800202c:	4770      	bx	lr

0800202e <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 800202e:	6940      	ldr	r0, [r0, #20]
}
 8002030:	f000 0001 	and.w	r0, r0, #1
 8002034:	4770      	bx	lr

08002036 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8002036:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800203a:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800203e:	f023 0307 	bic.w	r3, r3, #7
 8002042:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8002046:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 800204a:	689a      	ldr	r2, [r3, #8]
 800204c:	f002 0206 	and.w	r2, r2, #6
 8002050:	2a04      	cmp	r2, #4
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
 8002052:	bf02      	ittt	eq
 8002054:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 8002058:	f042 0203 	orreq.w	r2, r2, #3
 800205c:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8002060:	685a      	ldr	r2, [r3, #4]
 8002062:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002066:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 8002068:	2000      	movs	r0, #0
 800206a:	4770      	bx	lr

0800206c <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 800206c:	b510      	push	{r4, lr}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800206e:	2400      	movs	r4, #0
 8002070:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 8002074:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8002078:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 800207c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8002080:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8002084:	f044 0418 	orr.w	r4, r4, #24
 8002088:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800208c:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 8002090:	2901      	cmp	r1, #1
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8002092:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8002096:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 800209a:	bf08      	it	eq
 800209c:	f04f 2380 	moveq.w	r3, #2147516416	; 0x80008000
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80020a0:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80020a4:	bf04      	itt	eq
 80020a6:	f8c0 2b14 	streq.w	r2, [r0, #2836]	; 0xb14
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80020aa:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 80020ae:	2000      	movs	r0, #0
 80020b0:	bd10      	pop	{r4, pc}
	...

080020b4 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80020b4:	4b0a      	ldr	r3, [pc, #40]	; (80020e0 <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 80020b6:	3b01      	subs	r3, #1
 80020b8:	d101      	bne.n	80020be <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 80020ba:	2003      	movs	r0, #3
 80020bc:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80020be:	6902      	ldr	r2, [r0, #16]
 80020c0:	2a00      	cmp	r2, #0
 80020c2:	daf8      	bge.n	80020b6 <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80020c4:	6903      	ldr	r3, [r0, #16]
 80020c6:	4a06      	ldr	r2, [pc, #24]	; (80020e0 <USB_CoreReset+0x2c>)
 80020c8:	f043 0301 	orr.w	r3, r3, #1
 80020cc:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 80020ce:	3a01      	subs	r2, #1
 80020d0:	d0f3      	beq.n	80020ba <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80020d2:	6903      	ldr	r3, [r0, #16]
 80020d4:	f013 0301 	ands.w	r3, r3, #1
 80020d8:	d1f9      	bne.n	80020ce <USB_CoreReset+0x1a>
  
  return HAL_OK;
 80020da:	4618      	mov	r0, r3
}
 80020dc:	4770      	bx	lr
 80020de:	bf00      	nop
 80020e0:	00030d41 	.word	0x00030d41

080020e4 <USBD_CDC_DataIn>:
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80020e4:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if(pdev->pClassData != NULL)
 80020e8:	b11b      	cbz	r3, 80020f2 <USBD_CDC_DataIn+0xe>
  {
    
    hcdc->TxState = 0;
 80020ea:	2000      	movs	r0, #0
 80020ec:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214

    return USBD_OK;
 80020f0:	4770      	bx	lr
  }
  else
  {
    return USBD_FAIL;
 80020f2:	2002      	movs	r0, #2
  }
}
 80020f4:	4770      	bx	lr

080020f6 <USBD_CDC_EP0_RxReady>:
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 80020f6:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
 80020fa:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80020fc:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 8002100:	b15b      	cbz	r3, 800211a <USBD_CDC_EP0_RxReady+0x24>
 8002102:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8002106:	28ff      	cmp	r0, #255	; 0xff
 8002108:	d007      	beq.n	800211a <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 800210a:	689b      	ldr	r3, [r3, #8]
 800210c:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 8002110:	4621      	mov	r1, r4
 8002112:	4798      	blx	r3
                                                      (uint8_t *)hcdc->data,
                                                      hcdc->CmdLength);
      hcdc->CmdOpCode = 0xFF; 
 8002114:	23ff      	movs	r3, #255	; 0xff
 8002116:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
      
  }
  return USBD_OK;
}
 800211a:	2000      	movs	r0, #0
 800211c:	bd10      	pop	{r4, pc}
	...

08002120 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgFSDesc);
 8002120:	2343      	movs	r3, #67	; 0x43
 8002122:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 8002124:	4800      	ldr	r0, [pc, #0]	; (8002128 <USBD_CDC_GetFSCfgDesc+0x8>)
 8002126:	4770      	bx	lr
 8002128:	20000000 	.word	0x20000000

0800212c <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgHSDesc);
 800212c:	2343      	movs	r3, #67	; 0x43
 800212e:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 8002130:	4800      	ldr	r0, [pc, #0]	; (8002134 <USBD_CDC_GetHSCfgDesc+0x8>)
 8002132:	4770      	bx	lr
 8002134:	200000cc 	.word	0x200000cc

08002138 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_OtherSpeedCfgDesc);
 8002138:	2343      	movs	r3, #67	; 0x43
 800213a:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 800213c:	4800      	ldr	r0, [pc, #0]	; (8002140 <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 800213e:	4770      	bx	lr
 8002140:	20000088 	.word	0x20000088

08002144 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_CDC_DeviceQualifierDesc);
 8002144:	230a      	movs	r3, #10
 8002146:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 8002148:	4800      	ldr	r0, [pc, #0]	; (800214c <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 800214a:	4770      	bx	lr
 800214c:	2000007c 	.word	0x2000007c

08002150 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
 8002150:	b538      	push	{r3, r4, r5, lr}
 8002152:	4605      	mov	r5, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8002154:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8002158:	f001 f8ea 	bl	8003330 <USBD_LL_GetRxDataSize>
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 800215c:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8002160:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 8002164:	b14b      	cbz	r3, 800217a <USBD_CDC_DataOut+0x2a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8002166:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 800216a:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 800216e:	68db      	ldr	r3, [r3, #12]
 8002170:	f504 7103 	add.w	r1, r4, #524	; 0x20c
 8002174:	4798      	blx	r3

    return USBD_OK;
 8002176:	2000      	movs	r0, #0
 8002178:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    return USBD_FAIL;
 800217a:	2002      	movs	r0, #2
  }
}
 800217c:	bd38      	pop	{r3, r4, r5, pc}
	...

08002180 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8002180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002182:	780f      	ldrb	r7, [r1, #0]
 8002184:	f017 0360 	ands.w	r3, r7, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8002188:	4606      	mov	r6, r0
 800218a:	460c      	mov	r4, r1
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800218c:	d022      	beq.n	80021d4 <USBD_CDC_Setup+0x54>
 800218e:	2b20      	cmp	r3, #32
 8002190:	d127      	bne.n	80021e2 <USBD_CDC_Setup+0x62>
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
 8002192:	88ca      	ldrh	r2, [r1, #6]
 8002194:	784b      	ldrb	r3, [r1, #1]
 8002196:	b1ba      	cbz	r2, 80021c8 <USBD_CDC_Setup+0x48>
    {
      if (req->bmRequest & 0x80)
 8002198:	0639      	lsls	r1, r7, #24
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 800219a:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
    {
      if (req->bmRequest & 0x80)
 800219e:	d509      	bpl.n	80021b4 <USBD_CDC_Setup+0x34>
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 80021a0:	f8d0 121c 	ldr.w	r1, [r0, #540]	; 0x21c
 80021a4:	4618      	mov	r0, r3
 80021a6:	688f      	ldr	r7, [r1, #8]
 80021a8:	4629      	mov	r1, r5
 80021aa:	47b8      	blx	r7
                                                          (uint8_t *)hcdc->data,
                                                          req->wLength);
          USBD_CtlSendData (pdev, 
 80021ac:	88e2      	ldrh	r2, [r4, #6]
 80021ae:	4629      	mov	r1, r5
 80021b0:	4630      	mov	r0, r6
 80021b2:	e014      	b.n	80021de <USBD_CDC_Setup+0x5e>
                            (uint8_t *)hcdc->data,
                            req->wLength);
      }
      else
      {
        hcdc->CmdOpCode = req->bRequest;
 80021b4:	f885 3200 	strb.w	r3, [r5, #512]	; 0x200
        hcdc->CmdLength = req->wLength;
 80021b8:	88e3      	ldrh	r3, [r4, #6]
 80021ba:	f885 3201 	strb.w	r3, [r5, #513]	; 0x201
        
        USBD_CtlPrepareRx (pdev, 
 80021be:	88e2      	ldrh	r2, [r4, #6]
 80021c0:	4629      	mov	r1, r5
 80021c2:	f000 fbb7 	bl	8002934 <USBD_CtlPrepareRx>
 80021c6:	e00c      	b.n	80021e2 <USBD_CDC_Setup+0x62>
      }
      
    }
    else
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 80021c8:	f8d0 021c 	ldr.w	r0, [r0, #540]	; 0x21c
 80021cc:	6884      	ldr	r4, [r0, #8]
 80021ce:	4618      	mov	r0, r3
 80021d0:	47a0      	blx	r4
 80021d2:	e006      	b.n	80021e2 <USBD_CDC_Setup+0x62>
                                                        0);
    }
    break;

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 80021d4:	784b      	ldrb	r3, [r1, #1]
 80021d6:	2b0a      	cmp	r3, #10
 80021d8:	d103      	bne.n	80021e2 <USBD_CDC_Setup+0x62>
    {      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 80021da:	4903      	ldr	r1, [pc, #12]	; (80021e8 <USBD_CDC_Setup+0x68>)
 80021dc:	2201      	movs	r2, #1
 80021de:	f000 fb94 	bl	800290a <USBD_CtlSendData>
 
  default: 
    break;
  }
  return USBD_OK;
}
 80021e2:	2000      	movs	r0, #0
 80021e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021e6:	bf00      	nop
 80021e8:	200001d8 	.word	0x200001d8

080021ec <USBD_CDC_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 80021ec:	b510      	push	{r4, lr}
  uint8_t ret = 0;
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 80021ee:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 80021f0:	4604      	mov	r4, r0
  uint8_t ret = 0;
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 80021f2:	f001 f835 	bl	8003260 <USBD_LL_CloseEP>
              CDC_IN_EP);
  
  /* Open EP OUT */
  USBD_LL_CloseEP(pdev,
 80021f6:	2101      	movs	r1, #1
 80021f8:	4620      	mov	r0, r4
 80021fa:	f001 f831 	bl	8003260 <USBD_LL_CloseEP>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  USBD_LL_CloseEP(pdev,
 80021fe:	2182      	movs	r1, #130	; 0x82
 8002200:	4620      	mov	r0, r4
 8002202:	f001 f82d 	bl	8003260 <USBD_LL_CloseEP>
              CDC_CMD_EP);
  
  
  /* DeInit  physical Interface components */
  if(pdev->pClassData != NULL)
 8002206:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800220a:	b153      	cbz	r3, 8002222 <USBD_CDC_DeInit+0x36>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 800220c:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8002210:	685b      	ldr	r3, [r3, #4]
 8002212:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8002214:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 8002218:	f001 f93a 	bl	8003490 <free>
    pdev->pClassData = NULL;
 800221c:	2300      	movs	r3, #0
 800221e:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  }
  
  return ret;
}
 8002222:	2000      	movs	r0, #0
 8002224:	bd10      	pop	{r4, pc}

08002226 <USBD_CDC_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 8002226:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8002228:	7c03      	ldrb	r3, [r0, #16]
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 800222a:	4604      	mov	r4, r0
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 800222c:	b943      	cbnz	r3, 8002240 <USBD_CDC_Init+0x1a>
  {  
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 800222e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002232:	2202      	movs	r2, #2
 8002234:	2181      	movs	r1, #129	; 0x81
 8002236:	f001 f803 	bl	8003240 <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_HS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 800223a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800223e:	e005      	b.n	800224c <USBD_CDC_Init+0x26>
    
  }
  else
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8002240:	2340      	movs	r3, #64	; 0x40
 8002242:	2202      	movs	r2, #2
 8002244:	2181      	movs	r1, #129	; 0x81
 8002246:	f000 fffb 	bl	8003240 <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 800224a:	2340      	movs	r3, #64	; 0x40
 800224c:	2202      	movs	r2, #2
 800224e:	2101      	movs	r1, #1
 8002250:	4620      	mov	r0, r4
 8002252:	f000 fff5 	bl	8003240 <USBD_LL_OpenEP>
                   CDC_OUT_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_OUT_PACKET_SIZE);
  }
  /* Open Command IN EP */
  USBD_LL_OpenEP(pdev,
 8002256:	2308      	movs	r3, #8
 8002258:	2203      	movs	r2, #3
 800225a:	2182      	movs	r1, #130	; 0x82
 800225c:	4620      	mov	r0, r4
 800225e:	f000 ffef 	bl	8003240 <USBD_LL_OpenEP>
                 CDC_CMD_EP,
                 USBD_EP_TYPE_INTR,
                 CDC_CMD_PACKET_SIZE);
  
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
 8002262:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8002266:	f001 f90b 	bl	8003480 <malloc>
 800226a:	4606      	mov	r6, r0
 800226c:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 8002270:	b1e8      	cbz	r0, 80022ae <USBD_CDC_Init+0x88>
  else
  {
    hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8002272:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8002276:	681b      	ldr	r3, [r3, #0]
 8002278:	4798      	blx	r3
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 800227a:	7c27      	ldrb	r7, [r4, #16]
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
    
    /* Init Xfer states */
    hcdc->TxState =0;
 800227c:	2500      	movs	r5, #0
 800227e:	f8c6 5214 	str.w	r5, [r6, #532]	; 0x214
    hcdc->RxState =0;
 8002282:	f8c6 5218 	str.w	r5, [r6, #536]	; 0x218
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8002286:	b94f      	cbnz	r7, 800229c <USBD_CDC_Init+0x76>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8002288:	f44f 7300 	mov.w	r3, #512	; 0x200
 800228c:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 8002290:	2101      	movs	r1, #1
 8002292:	4620      	mov	r0, r4
 8002294:	f001 f83e 	bl	8003314 <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 8002298:	4638      	mov	r0, r7
 800229a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800229c:	2340      	movs	r3, #64	; 0x40
 800229e:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 80022a2:	2101      	movs	r1, #1
 80022a4:	4620      	mov	r0, r4
 80022a6:	f001 f835 	bl	8003314 <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 80022aa:	4628      	mov	r0, r5
 80022ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
  
  if(pdev->pClassData == NULL)
  {
    ret = 1; 
 80022ae:	2001      	movs	r0, #1
    }
    
    
  }
  return ret;
}
 80022b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080022b2 <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
  
  if(fops != NULL)
 80022b2:	b119      	cbz	r1, 80022bc <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 80022b4:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;    
 80022b8:	2000      	movs	r0, #0
 80022ba:	4770      	bx	lr
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
 80022bc:	2002      	movs	r0, #2
    pdev->pUserData= fops;
    ret = USBD_OK;    
  }
  
  return ret;
}
 80022be:	4770      	bx	lr

080022c0 <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80022c0:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;  
  
  return USBD_OK;  
}
 80022c4:	2000      	movs	r0, #0
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->TxBuffer = pbuff;
 80022c6:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;  
 80022ca:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  
  return USBD_OK;  
}
 80022ce:	4770      	bx	lr

080022d0 <USBD_CDC_SetRxBuffer>:
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 80022d0:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  return USBD_OK;
}
 80022d4:	2000      	movs	r0, #0
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 80022d6:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
  
  return USBD_OK;
}
 80022da:	4770      	bx	lr

080022dc <USBD_CDC_TransmitPacket>:
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80022dc:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
 80022e0:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if(pdev->pClassData != NULL)
 80022e2:	b172      	cbz	r2, 8002302 <USBD_CDC_TransmitPacket+0x26>
  {
    if(hcdc->TxState == 0)
 80022e4:	f8d2 4214 	ldr.w	r4, [r2, #532]	; 0x214
 80022e8:	2301      	movs	r3, #1
 80022ea:	b964      	cbnz	r4, 8002306 <USBD_CDC_TransmitPacket+0x2a>
    {
      /* Tx Transfer in progress */
      hcdc->TxState = 1;
 80022ec:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
      
      /* Transmit next packet */
      USBD_LL_Transmit(pdev,
 80022f0:	2181      	movs	r1, #129	; 0x81
 80022f2:	f8b2 3210 	ldrh.w	r3, [r2, #528]	; 0x210
 80022f6:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
 80022fa:	f000 fffd 	bl	80032f8 <USBD_LL_Transmit>
                       CDC_IN_EP,
                       hcdc->TxBuffer,
                       hcdc->TxLength);
      
      return USBD_OK;
 80022fe:	4620      	mov	r0, r4
 8002300:	bd10      	pop	{r4, pc}
      return USBD_BUSY;
    }
  }
  else
  {
    return USBD_FAIL;
 8002302:	2002      	movs	r0, #2
 8002304:	bd10      	pop	{r4, pc}
      
      return USBD_OK;
    }
    else
    {
      return USBD_BUSY;
 8002306:	4618      	mov	r0, r3
  }
  else
  {
    return USBD_FAIL;
  }
}
 8002308:	bd10      	pop	{r4, pc}

0800230a <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 800230a:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
 800230e:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
 8002310:	b162      	cbz	r2, 800232c <USBD_CDC_ReceivePacket+0x22>
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8002312:	7c04      	ldrb	r4, [r0, #16]
 8002314:	b914      	cbnz	r4, 800231c <USBD_CDC_ReceivePacket+0x12>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8002316:	f44f 7300 	mov.w	r3, #512	; 0x200
 800231a:	e000      	b.n	800231e <USBD_CDC_ReceivePacket+0x14>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800231c:	2340      	movs	r3, #64	; 0x40
 800231e:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 8002322:	2101      	movs	r1, #1
 8002324:	f000 fff6 	bl	8003314 <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 8002328:	2000      	movs	r0, #0
 800232a:	bd10      	pop	{r4, pc}
  }
  else
  {
    return USBD_FAIL;
 800232c:	2002      	movs	r0, #2
  }
}
 800232e:	bd10      	pop	{r4, pc}

08002330 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8002330:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8002332:	b180      	cbz	r0, 8002356 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8002334:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002338:	b113      	cbz	r3, 8002340 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 800233a:	2300      	movs	r3, #0
 800233c:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8002340:	b109      	cbz	r1, 8002346 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8002342:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8002346:	2301      	movs	r3, #1
 8002348:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 800234c:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 800234e:	f000 ff39 	bl	80031c4 <USBD_LL_Init>
  
  return USBD_OK; 
 8002352:	2000      	movs	r0, #0
 8002354:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 8002356:	2002      	movs	r0, #2
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
 8002358:	bd08      	pop	{r3, pc}

0800235a <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 800235a:	b119      	cbz	r1, 8002364 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 800235c:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8002360:	2000      	movs	r0, #0
 8002362:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8002364:	2002      	movs	r0, #2
  }
  
  return status;
}
 8002366:	4770      	bx	lr

08002368 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8002368:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 800236a:	f000 ff5b 	bl	8003224 <USBD_LL_Start>
  
  return USBD_OK;  
}
 800236e:	2000      	movs	r0, #0
 8002370:	bd08      	pop	{r3, pc}

08002372 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002372:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8002374:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002378:	b90b      	cbnz	r3, 800237e <USBD_SetClassConfig+0xc>
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
 800237a:	2002      	movs	r0, #2
 800237c:	bd08      	pop	{r3, pc}
  
  if(pdev->pClass != NULL)
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 800237e:	681b      	ldr	r3, [r3, #0]
 8002380:	4798      	blx	r3
 8002382:	2800      	cmp	r0, #0
 8002384:	d1f9      	bne.n	800237a <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 8002386:	bd08      	pop	{r3, pc}

08002388 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8002388:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 800238a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800238e:	685b      	ldr	r3, [r3, #4]
 8002390:	4798      	blx	r3
  return USBD_OK;
}
 8002392:	2000      	movs	r0, #0
 8002394:	bd08      	pop	{r3, pc}

08002396 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8002396:	b538      	push	{r3, r4, r5, lr}
 8002398:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800239a:	f500 7502 	add.w	r5, r0, #520	; 0x208
 800239e:	4628      	mov	r0, r5
 80023a0:	f000 f8f3 	bl	800258a <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 80023a4:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 80023a6:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 80023aa:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 80023ae:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 80023b2:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 80023b6:	f001 031f 	and.w	r3, r1, #31
 80023ba:	2b01      	cmp	r3, #1
 80023bc:	d00c      	beq.n	80023d8 <USBD_LL_SetupStage+0x42>
 80023be:	d306      	bcc.n	80023ce <USBD_LL_SetupStage+0x38>
 80023c0:	2b02      	cmp	r3, #2
 80023c2:	d10e      	bne.n	80023e2 <USBD_LL_SetupStage+0x4c>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 80023c4:	4629      	mov	r1, r5
 80023c6:	4620      	mov	r0, r4
 80023c8:	f000 fa20 	bl	800280c <USBD_StdEPReq>
    break;
 80023cc:	e00e      	b.n	80023ec <USBD_LL_SetupStage+0x56>
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 80023ce:	4629      	mov	r1, r5
 80023d0:	4620      	mov	r0, r4
 80023d2:	f000 f8f9 	bl	80025c8 <USBD_StdDevReq>
    break;
 80023d6:	e009      	b.n	80023ec <USBD_LL_SetupStage+0x56>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 80023d8:	4629      	mov	r1, r5
 80023da:	4620      	mov	r0, r4
 80023dc:	f000 f9fe 	bl	80027dc <USBD_StdItfReq>
    break;
 80023e0:	e004      	b.n	80023ec <USBD_LL_SetupStage+0x56>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 80023e2:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80023e6:	4620      	mov	r0, r4
 80023e8:	f000 ff48 	bl	800327c <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 80023ec:	2000      	movs	r0, #0
 80023ee:	bd38      	pop	{r3, r4, r5, pc}

080023f0 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 80023f0:	b538      	push	{r3, r4, r5, lr}
 80023f2:	4604      	mov	r4, r0
 80023f4:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 80023f6:	bb09      	cbnz	r1, 800243c <USBD_LL_DataOutStage+0x4c>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 80023f8:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 80023fc:	2b03      	cmp	r3, #3
 80023fe:	d126      	bne.n	800244e <USBD_LL_DataOutStage+0x5e>
    {
      if(pep->rem_length > pep->maxpacket)
 8002400:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8002404:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8002408:	4291      	cmp	r1, r2
 800240a:	d90a      	bls.n	8002422 <USBD_LL_DataOutStage+0x32>
      {
        pep->rem_length -=  pep->maxpacket;
 800240c:	1a8b      	subs	r3, r1, r2
       
        USBD_CtlContinueRx (pdev, 
 800240e:	429a      	cmp	r2, r3
 8002410:	bf28      	it	cs
 8002412:	461a      	movcs	r2, r3
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8002414:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
       
        USBD_CtlContinueRx (pdev, 
 8002418:	b292      	uxth	r2, r2
 800241a:	4629      	mov	r1, r5
 800241c:	f000 fa99 	bl	8002952 <USBD_CtlContinueRx>
 8002420:	e015      	b.n	800244e <USBD_LL_DataOutStage+0x5e>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8002422:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002426:	691b      	ldr	r3, [r3, #16]
 8002428:	b123      	cbz	r3, 8002434 <USBD_LL_DataOutStage+0x44>
 800242a:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800242e:	2a03      	cmp	r2, #3
 8002430:	d100      	bne.n	8002434 <USBD_LL_DataOutStage+0x44>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8002432:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8002434:	4620      	mov	r0, r4
 8002436:	f000 fa94 	bl	8002962 <USBD_CtlSendStatus>
 800243a:	e008      	b.n	800244e <USBD_LL_DataOutStage+0x5e>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 800243c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002440:	699b      	ldr	r3, [r3, #24]
 8002442:	b123      	cbz	r3, 800244e <USBD_LL_DataOutStage+0x5e>
 8002444:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002448:	2a03      	cmp	r2, #3
 800244a:	d100      	bne.n	800244e <USBD_LL_DataOutStage+0x5e>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 800244c:	4798      	blx	r3
  }  
  return USBD_OK;
}
 800244e:	2000      	movs	r0, #0
 8002450:	bd38      	pop	{r3, r4, r5, pc}

08002452 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8002452:	b570      	push	{r4, r5, r6, lr}
 8002454:	4613      	mov	r3, r2
 8002456:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8002458:	460e      	mov	r6, r1
 800245a:	2900      	cmp	r1, #0
 800245c:	d13c      	bne.n	80024d8 <USBD_LL_DataInStage+0x86>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 800245e:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8002462:	2a02      	cmp	r2, #2
 8002464:	d130      	bne.n	80024c8 <USBD_LL_DataInStage+0x76>
    {
      if(pep->rem_length > pep->maxpacket)
 8002466:	69c5      	ldr	r5, [r0, #28]
 8002468:	6a02      	ldr	r2, [r0, #32]
 800246a:	4295      	cmp	r5, r2
 800246c:	d907      	bls.n	800247e <USBD_LL_DataInStage+0x2c>
      {
        pep->rem_length -=  pep->maxpacket;
 800246e:	1aaa      	subs	r2, r5, r2
 8002470:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8002472:	4619      	mov	r1, r3
 8002474:	b292      	uxth	r2, r2
 8002476:	f000 fa55 	bl	8002924 <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 800247a:	4633      	mov	r3, r6
 800247c:	e011      	b.n	80024a2 <USBD_LL_DataInStage+0x50>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 800247e:	6983      	ldr	r3, [r0, #24]
 8002480:	fbb3 f5f2 	udiv	r5, r3, r2
 8002484:	fb02 3515 	mls	r5, r2, r5, r3
 8002488:	b98d      	cbnz	r5, 80024ae <USBD_LL_DataInStage+0x5c>
 800248a:	429a      	cmp	r2, r3
 800248c:	d80f      	bhi.n	80024ae <USBD_LL_DataInStage+0x5c>
           (pep->total_length >= pep->maxpacket) &&
 800248e:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 8002492:	4293      	cmp	r3, r2
 8002494:	d20b      	bcs.n	80024ae <USBD_LL_DataInStage+0x5c>
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8002496:	462a      	mov	r2, r5
 8002498:	f000 fa44 	bl	8002924 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 800249c:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 80024a0:	462b      	mov	r3, r5
 80024a2:	461a      	mov	r2, r3
 80024a4:	4619      	mov	r1, r3
 80024a6:	4620      	mov	r0, r4
 80024a8:	f000 ff34 	bl	8003314 <USBD_LL_PrepareReceive>
 80024ac:	e00c      	b.n	80024c8 <USBD_LL_DataInStage+0x76>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 80024ae:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80024b2:	68db      	ldr	r3, [r3, #12]
 80024b4:	b12b      	cbz	r3, 80024c2 <USBD_LL_DataInStage+0x70>
 80024b6:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 80024ba:	2a03      	cmp	r2, #3
 80024bc:	d101      	bne.n	80024c2 <USBD_LL_DataInStage+0x70>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 80024be:	4620      	mov	r0, r4
 80024c0:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 80024c2:	4620      	mov	r0, r4
 80024c4:	f000 fa58 	bl	8002978 <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 80024c8:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 80024cc:	2b01      	cmp	r3, #1
 80024ce:	d10c      	bne.n	80024ea <USBD_LL_DataInStage+0x98>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 80024d0:	2300      	movs	r3, #0
 80024d2:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 80024d6:	e008      	b.n	80024ea <USBD_LL_DataInStage+0x98>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 80024d8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80024dc:	695b      	ldr	r3, [r3, #20]
 80024de:	b123      	cbz	r3, 80024ea <USBD_LL_DataInStage+0x98>
 80024e0:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80024e4:	2a03      	cmp	r2, #3
 80024e6:	d100      	bne.n	80024ea <USBD_LL_DataInStage+0x98>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 80024e8:	4798      	blx	r3
  }  
  return USBD_OK;
}
 80024ea:	2000      	movs	r0, #0
 80024ec:	bd70      	pop	{r4, r5, r6, pc}

080024ee <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80024ee:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80024f0:	2200      	movs	r2, #0
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80024f2:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80024f4:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80024f6:	2540      	movs	r5, #64	; 0x40
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80024f8:	2340      	movs	r3, #64	; 0x40
 80024fa:	f000 fea1 	bl	8003240 <USBD_LL_OpenEP>
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 80024fe:	462b      	mov	r3, r5
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8002500:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8002504:	2200      	movs	r2, #0
 8002506:	2180      	movs	r1, #128	; 0x80
 8002508:	4620      	mov	r0, r4
 800250a:	f000 fe99 	bl	8003240 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800250e:	2301      	movs	r3, #1
 8002510:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8002514:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8002518:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pClassData) 
 800251a:	b12b      	cbz	r3, 8002528 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 800251c:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002520:	7921      	ldrb	r1, [r4, #4]
 8002522:	685b      	ldr	r3, [r3, #4]
 8002524:	4620      	mov	r0, r4
 8002526:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8002528:	2000      	movs	r0, #0
 800252a:	bd38      	pop	{r3, r4, r5, pc}

0800252c <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 800252c:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 800252e:	2000      	movs	r0, #0
 8002530:	4770      	bx	lr

08002532 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8002532:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002536:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 800253a:	2304      	movs	r3, #4
 800253c:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8002540:	2000      	movs	r0, #0
 8002542:	4770      	bx	lr

08002544 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8002544:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8002548:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 800254c:	2000      	movs	r0, #0
 800254e:	4770      	bx	lr

08002550 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8002550:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002552:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002556:	2a03      	cmp	r2, #3
 8002558:	d104      	bne.n	8002564 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 800255a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800255e:	69db      	ldr	r3, [r3, #28]
 8002560:	b103      	cbz	r3, 8002564 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8002562:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8002564:	2000      	movs	r0, #0
 8002566:	bd08      	pop	{r3, pc}

08002568 <USBD_LL_IsoINIncomplete>:
 8002568:	2000      	movs	r0, #0
 800256a:	4770      	bx	lr

0800256c <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 800256c:	2000      	movs	r0, #0
 800256e:	4770      	bx	lr

08002570 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8002570:	2000      	movs	r0, #0
 8002572:	4770      	bx	lr

08002574 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8002574:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8002576:	2201      	movs	r2, #1
 8002578:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 800257c:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8002580:	7901      	ldrb	r1, [r0, #4]
 8002582:	6852      	ldr	r2, [r2, #4]
 8002584:	4790      	blx	r2
   
  return USBD_OK;
}
 8002586:	2000      	movs	r0, #0
 8002588:	bd08      	pop	{r3, pc}

0800258a <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 800258a:	780b      	ldrb	r3, [r1, #0]
 800258c:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 800258e:	784b      	ldrb	r3, [r1, #1]
 8002590:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8002592:	78ca      	ldrb	r2, [r1, #3]
 8002594:	788b      	ldrb	r3, [r1, #2]
 8002596:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800259a:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 800259c:	794a      	ldrb	r2, [r1, #5]
 800259e:	790b      	ldrb	r3, [r1, #4]
 80025a0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80025a4:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 80025a6:	79ca      	ldrb	r2, [r1, #7]
 80025a8:	798b      	ldrb	r3, [r1, #6]
 80025aa:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80025ae:	80c3      	strh	r3, [r0, #6]
 80025b0:	4770      	bx	lr

080025b2 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 80025b2:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 80025b4:	2180      	movs	r1, #128	; 0x80
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 80025b6:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 80025b8:	f000 fe60 	bl	800327c <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80025bc:	4620      	mov	r0, r4
 80025be:	2100      	movs	r1, #0
}
 80025c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
 80025c4:	f000 be5a 	b.w	800327c <USBD_LL_StallEP>

080025c8 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80025c8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 80025ca:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80025cc:	4604      	mov	r4, r0
 80025ce:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 80025d0:	2b09      	cmp	r3, #9
 80025d2:	f200 80f9 	bhi.w	80027c8 <USBD_StdDevReq+0x200>
 80025d6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80025da:	00cb      	.short	0x00cb
 80025dc:	00f700e2 	.word	0x00f700e2
 80025e0:	00f700de 	.word	0x00f700de
 80025e4:	000a0075 	.word	0x000a0075
 80025e8:	00bb00f7 	.word	0x00bb00f7
 80025ec:	0091      	.short	0x0091
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 80025ee:	884b      	ldrh	r3, [r1, #2]
 80025f0:	0a1a      	lsrs	r2, r3, #8
 80025f2:	3a01      	subs	r2, #1
 80025f4:	2a06      	cmp	r2, #6
 80025f6:	f200 80e7 	bhi.w	80027c8 <USBD_StdDevReq+0x200>
 80025fa:	e8df f012 	tbh	[pc, r2, lsl #1]
 80025fe:	0007      	.short	0x0007
 8002600:	0017000b 	.word	0x0017000b
 8002604:	00e500e5 	.word	0x00e500e5
 8002608:	0047003c 	.word	0x0047003c
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800260c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002610:	681b      	ldr	r3, [r3, #0]
 8002612:	e017      	b.n	8002644 <USBD_StdDevReq+0x7c>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8002614:	7c02      	ldrb	r2, [r0, #16]
 8002616:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800261a:	b90a      	cbnz	r2, 8002620 <USBD_StdDevReq+0x58>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 800261c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800261e:	e000      	b.n	8002622 <USBD_StdDevReq+0x5a>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8002620:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002622:	f10d 0006 	add.w	r0, sp, #6
 8002626:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8002628:	2302      	movs	r3, #2
 800262a:	e03a      	b.n	80026a2 <USBD_StdDevReq+0xda>
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 800262c:	b2db      	uxtb	r3, r3
 800262e:	2b05      	cmp	r3, #5
 8002630:	f200 80ca 	bhi.w	80027c8 <USBD_StdDevReq+0x200>
 8002634:	e8df f003 	tbb	[pc, r3]
 8002638:	130f0b03 	.word	0x130f0b03
 800263c:	1b17      	.short	0x1b17
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 800263e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002642:	685b      	ldr	r3, [r3, #4]
 8002644:	7c20      	ldrb	r0, [r4, #16]
 8002646:	f10d 0106 	add.w	r1, sp, #6
 800264a:	4798      	blx	r3
 800264c:	e02a      	b.n	80026a4 <USBD_StdDevReq+0xdc>
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 800264e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002652:	689b      	ldr	r3, [r3, #8]
 8002654:	e7f6      	b.n	8002644 <USBD_StdDevReq+0x7c>
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8002656:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800265a:	68db      	ldr	r3, [r3, #12]
 800265c:	e7f2      	b.n	8002644 <USBD_StdDevReq+0x7c>
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 800265e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002662:	691b      	ldr	r3, [r3, #16]
 8002664:	e7ee      	b.n	8002644 <USBD_StdDevReq+0x7c>
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8002666:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800266a:	695b      	ldr	r3, [r3, #20]
 800266c:	e7ea      	b.n	8002644 <USBD_StdDevReq+0x7c>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 800266e:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002672:	699b      	ldr	r3, [r3, #24]
 8002674:	e7e6      	b.n	8002644 <USBD_StdDevReq+0x7c>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8002676:	7c03      	ldrb	r3, [r0, #16]
 8002678:	2b00      	cmp	r3, #0
 800267a:	f040 80a5 	bne.w	80027c8 <USBD_StdDevReq+0x200>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 800267e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002682:	f10d 0006 	add.w	r0, sp, #6
 8002686:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002688:	4798      	blx	r3
 800268a:	e00b      	b.n	80026a4 <USBD_StdDevReq+0xdc>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 800268c:	7c03      	ldrb	r3, [r0, #16]
 800268e:	2b00      	cmp	r3, #0
 8002690:	f040 809a 	bne.w	80027c8 <USBD_StdDevReq+0x200>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8002694:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002698:	f10d 0006 	add.w	r0, sp, #6
 800269c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800269e:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80026a0:	2307      	movs	r3, #7
 80026a2:	7043      	strb	r3, [r0, #1]
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80026a4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80026a8:	2a00      	cmp	r2, #0
 80026aa:	f000 8091 	beq.w	80027d0 <USBD_StdDevReq+0x208>
 80026ae:	88eb      	ldrh	r3, [r5, #6]
 80026b0:	2b00      	cmp	r3, #0
 80026b2:	f000 808d 	beq.w	80027d0 <USBD_StdDevReq+0x208>
  {
    
    len = MIN(len , req->wLength);
 80026b6:	429a      	cmp	r2, r3
 80026b8:	bf28      	it	cs
 80026ba:	461a      	movcs	r2, r3
 80026bc:	f8ad 2006 	strh.w	r2, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 80026c0:	4601      	mov	r1, r0
 80026c2:	e064      	b.n	800278e <USBD_StdDevReq+0x1c6>
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 80026c4:	888b      	ldrh	r3, [r1, #4]
 80026c6:	2b00      	cmp	r3, #0
 80026c8:	d17e      	bne.n	80027c8 <USBD_StdDevReq+0x200>
 80026ca:	88cb      	ldrh	r3, [r1, #6]
 80026cc:	2b00      	cmp	r3, #0
 80026ce:	d17b      	bne.n	80027c8 <USBD_StdDevReq+0x200>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 80026d0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80026d4:	788e      	ldrb	r6, [r1, #2]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 80026d6:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 80026d8:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 80026dc:	d074      	beq.n	80027c8 <USBD_StdDevReq+0x200>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 80026de:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 80026e2:	4631      	mov	r1, r6
 80026e4:	f000 fdfa 	bl	80032dc <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 80026e8:	4620      	mov	r0, r4
 80026ea:	f000 f93a 	bl	8002962 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 80026ee:	b10e      	cbz	r6, 80026f4 <USBD_StdDevReq+0x12c>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 80026f0:	2302      	movs	r3, #2
 80026f2:	e000      	b.n	80026f6 <USBD_StdDevReq+0x12e>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 80026f4:	2301      	movs	r3, #1
 80026f6:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 80026fa:	e069      	b.n	80027d0 <USBD_StdDevReq+0x208>
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 80026fc:	7889      	ldrb	r1, [r1, #2]
 80026fe:	4e36      	ldr	r6, [pc, #216]	; (80027d8 <USBD_StdDevReq+0x210>)
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8002700:	2901      	cmp	r1, #1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8002702:	7031      	strb	r1, [r6, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8002704:	d860      	bhi.n	80027c8 <USBD_StdDevReq+0x200>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 8002706:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800270a:	2b02      	cmp	r3, #2
 800270c:	d002      	beq.n	8002714 <USBD_StdDevReq+0x14c>
 800270e:	2b03      	cmp	r3, #3
 8002710:	d008      	beq.n	8002724 <USBD_StdDevReq+0x15c>
 8002712:	e059      	b.n	80027c8 <USBD_StdDevReq+0x200>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 8002714:	2900      	cmp	r1, #0
 8002716:	d053      	beq.n	80027c0 <USBD_StdDevReq+0x1f8>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8002718:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800271a:	2303      	movs	r3, #3
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 800271c:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800271e:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
 8002722:	e00f      	b.n	8002744 <USBD_StdDevReq+0x17c>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 8002724:	b931      	cbnz	r1, 8002734 <USBD_StdDevReq+0x16c>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8002726:	2302      	movs	r3, #2
 8002728:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 800272c:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 800272e:	f7ff fe2b 	bl	8002388 <USBD_ClrClassConfig>
 8002732:	e045      	b.n	80027c0 <USBD_StdDevReq+0x1f8>
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 8002734:	6841      	ldr	r1, [r0, #4]
 8002736:	2901      	cmp	r1, #1
 8002738:	d042      	beq.n	80027c0 <USBD_StdDevReq+0x1f8>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 800273a:	b2c9      	uxtb	r1, r1
 800273c:	f7ff fe24 	bl	8002388 <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 8002740:	7831      	ldrb	r1, [r6, #0]
 8002742:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8002744:	4620      	mov	r0, r4
 8002746:	f7ff fe14 	bl	8002372 <USBD_SetClassConfig>
 800274a:	2802      	cmp	r0, #2
 800274c:	d138      	bne.n	80027c0 <USBD_StdDevReq+0x1f8>
 800274e:	e03b      	b.n	80027c8 <USBD_StdDevReq+0x200>
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 8002750:	88ca      	ldrh	r2, [r1, #6]
 8002752:	2a01      	cmp	r2, #1
 8002754:	d138      	bne.n	80027c8 <USBD_StdDevReq+0x200>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 8002756:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800275a:	2b02      	cmp	r3, #2
 800275c:	d003      	beq.n	8002766 <USBD_StdDevReq+0x19e>
 800275e:	2b03      	cmp	r3, #3
 8002760:	d132      	bne.n	80027c8 <USBD_StdDevReq+0x200>
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 8002762:	1d01      	adds	r1, r0, #4
 8002764:	e013      	b.n	800278e <USBD_StdDevReq+0x1c6>
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 8002766:	4601      	mov	r1, r0
 8002768:	2300      	movs	r3, #0
 800276a:	f841 3f08 	str.w	r3, [r1, #8]!
 800276e:	e00e      	b.n	800278e <USBD_StdDevReq+0x1c6>
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 8002770:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002774:	3b02      	subs	r3, #2
 8002776:	2b01      	cmp	r3, #1
 8002778:	d826      	bhi.n	80027c8 <USBD_StdDevReq+0x200>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 800277a:	2301      	movs	r3, #1
 800277c:	60c3      	str	r3, [r0, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 800277e:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8002782:	b10b      	cbz	r3, 8002788 <USBD_StdDevReq+0x1c0>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8002784:	2303      	movs	r3, #3
 8002786:	60c3      	str	r3, [r0, #12]
    }
    
    USBD_CtlSendData (pdev, 
 8002788:	2202      	movs	r2, #2
 800278a:	f104 010c 	add.w	r1, r4, #12
 800278e:	4620      	mov	r0, r4
 8002790:	f000 f8bb 	bl	800290a <USBD_CtlSendData>
 8002794:	e01c      	b.n	80027d0 <USBD_StdDevReq+0x208>
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8002796:	884b      	ldrh	r3, [r1, #2]
 8002798:	2b01      	cmp	r3, #1
 800279a:	d119      	bne.n	80027d0 <USBD_StdDevReq+0x208>
 800279c:	e008      	b.n	80027b0 <USBD_StdDevReq+0x1e8>
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
 800279e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80027a2:	3b02      	subs	r3, #2
 80027a4:	2b01      	cmp	r3, #1
 80027a6:	d80f      	bhi.n	80027c8 <USBD_StdDevReq+0x200>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80027a8:	884b      	ldrh	r3, [r1, #2]
 80027aa:	2b01      	cmp	r3, #1
 80027ac:	d110      	bne.n	80027d0 <USBD_StdDevReq+0x208>
    {
      pdev->dev_remote_wakeup = 0; 
 80027ae:	2300      	movs	r3, #0
 80027b0:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80027b4:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80027b8:	4629      	mov	r1, r5
 80027ba:	689b      	ldr	r3, [r3, #8]
 80027bc:	4620      	mov	r0, r4
 80027be:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80027c0:	4620      	mov	r0, r4
 80027c2:	f000 f8ce 	bl	8002962 <USBD_CtlSendStatus>
 80027c6:	e003      	b.n	80027d0 <USBD_StdDevReq+0x208>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 80027c8:	4629      	mov	r1, r5
 80027ca:	4620      	mov	r0, r4
 80027cc:	f7ff fef1 	bl	80025b2 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 80027d0:	2000      	movs	r0, #0
 80027d2:	b002      	add	sp, #8
 80027d4:	bd70      	pop	{r4, r5, r6, pc}
 80027d6:	bf00      	nop
 80027d8:	200001d9 	.word	0x200001d9

080027dc <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80027dc:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80027de:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80027e2:	2b03      	cmp	r3, #3
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80027e4:	4604      	mov	r4, r0
 80027e6:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80027e8:	d10c      	bne.n	8002804 <USBD_StdItfReq+0x28>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 80027ea:	790b      	ldrb	r3, [r1, #4]
 80027ec:	2b01      	cmp	r3, #1
 80027ee:	d809      	bhi.n	8002804 <USBD_StdItfReq+0x28>
    {
      pdev->pClass->Setup (pdev, req); 
 80027f0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80027f4:	689b      	ldr	r3, [r3, #8]
 80027f6:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 80027f8:	88eb      	ldrh	r3, [r5, #6]
 80027fa:	b92b      	cbnz	r3, 8002808 <USBD_StdItfReq+0x2c>
      {
         USBD_CtlSendStatus(pdev);
 80027fc:	4620      	mov	r0, r4
 80027fe:	f000 f8b0 	bl	8002962 <USBD_CtlSendStatus>
 8002802:	e001      	b.n	8002808 <USBD_StdItfReq+0x2c>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 8002804:	f7ff fed5 	bl	80025b2 <USBD_CtlError>
    break;
  }
  return USBD_OK;
}
 8002808:	2000      	movs	r0, #0
 800280a:	bd38      	pop	{r3, r4, r5, pc}

0800280c <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800280c:	b570      	push	{r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800280e:	780a      	ldrb	r2, [r1, #0]
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 8002810:	888e      	ldrh	r6, [r1, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8002812:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8002816:	2a20      	cmp	r2, #32
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8002818:	4604      	mov	r4, r0
 800281a:	460d      	mov	r5, r1
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 800281c:	b2f3      	uxtb	r3, r6
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800281e:	d104      	bne.n	800282a <USBD_StdEPReq+0x1e>
  {
    pdev->pClass->Setup (pdev, req);
 8002820:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002824:	689b      	ldr	r3, [r3, #8]
 8002826:	4798      	blx	r3
    
    return USBD_OK;
 8002828:	e051      	b.n	80028ce <USBD_StdEPReq+0xc2>
  }
  
  switch (req->bRequest) 
 800282a:	784a      	ldrb	r2, [r1, #1]
 800282c:	2a01      	cmp	r2, #1
 800282e:	d010      	beq.n	8002852 <USBD_StdEPReq+0x46>
 8002830:	d326      	bcc.n	8002880 <USBD_StdEPReq+0x74>
 8002832:	2a03      	cmp	r2, #3
 8002834:	d14b      	bne.n	80028ce <USBD_StdEPReq+0xc2>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 8002836:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800283a:	2a02      	cmp	r2, #2
 800283c:	d027      	beq.n	800288e <USBD_StdEPReq+0x82>
 800283e:	2a03      	cmp	r2, #3
 8002840:	d143      	bne.n	80028ca <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8002842:	884a      	ldrh	r2, [r1, #2]
 8002844:	b992      	cbnz	r2, 800286c <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8002846:	065e      	lsls	r6, r3, #25
 8002848:	d010      	beq.n	800286c <USBD_StdEPReq+0x60>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 800284a:	4619      	mov	r1, r3
 800284c:	f000 fd16 	bl	800327c <USBD_LL_StallEP>
 8002850:	e00c      	b.n	800286c <USBD_StdEPReq+0x60>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 8002852:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002856:	2a02      	cmp	r2, #2
 8002858:	d019      	beq.n	800288e <USBD_StdEPReq+0x82>
 800285a:	2a03      	cmp	r2, #3
 800285c:	d135      	bne.n	80028ca <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 800285e:	884a      	ldrh	r2, [r1, #2]
 8002860:	bbaa      	cbnz	r2, 80028ce <USBD_StdEPReq+0xc2>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 8002862:	0659      	lsls	r1, r3, #25
 8002864:	d008      	beq.n	8002878 <USBD_StdEPReq+0x6c>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8002866:	4619      	mov	r1, r3
 8002868:	f000 fd16 	bl	8003298 <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 800286c:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002870:	4629      	mov	r1, r5
 8002872:	689b      	ldr	r3, [r3, #8]
 8002874:	4620      	mov	r0, r4
 8002876:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8002878:	4620      	mov	r0, r4
 800287a:	f000 f872 	bl	8002962 <USBD_CtlSendStatus>
 800287e:	e026      	b.n	80028ce <USBD_StdEPReq+0xc2>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 8002880:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002884:	2a02      	cmp	r2, #2
 8002886:	d002      	beq.n	800288e <USBD_StdEPReq+0x82>
 8002888:	2a03      	cmp	r2, #3
 800288a:	d006      	beq.n	800289a <USBD_StdEPReq+0x8e>
 800288c:	e01d      	b.n	80028ca <USBD_StdEPReq+0xbe>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 800288e:	065a      	lsls	r2, r3, #25
 8002890:	d01d      	beq.n	80028ce <USBD_StdEPReq+0xc2>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 8002892:	4619      	mov	r1, r3
 8002894:	f000 fcf2 	bl	800327c <USBD_LL_StallEP>
 8002898:	e019      	b.n	80028ce <USBD_StdEPReq+0xc2>
 800289a:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 800289e:	f016 0f80 	tst.w	r6, #128	; 0x80
 80028a2:	eb00 1505 	add.w	r5, r0, r5, lsl #4
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80028a6:	4619      	mov	r1, r3
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80028a8:	bf14      	ite	ne
 80028aa:	3514      	addne	r5, #20
 80028ac:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80028b0:	f000 fd00 	bl	80032b4 <USBD_LL_IsStallEP>
 80028b4:	b110      	cbz	r0, 80028bc <USBD_StdEPReq+0xb0>
      {
        pep->status = 0x0001;     
 80028b6:	2301      	movs	r3, #1
 80028b8:	602b      	str	r3, [r5, #0]
 80028ba:	e000      	b.n	80028be <USBD_StdEPReq+0xb2>
      }
      else
      {
        pep->status = 0x0000;  
 80028bc:	6028      	str	r0, [r5, #0]
      }
      
      USBD_CtlSendData (pdev,
 80028be:	2202      	movs	r2, #2
 80028c0:	4629      	mov	r1, r5
 80028c2:	4620      	mov	r0, r4
 80028c4:	f000 f821 	bl	800290a <USBD_CtlSendData>
                        (uint8_t *)&pep->status,
                        2);
      break;
 80028c8:	e001      	b.n	80028ce <USBD_StdEPReq+0xc2>
      
    default:                         
      USBD_CtlError(pdev , req);
 80028ca:	f7ff fe72 	bl	80025b2 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 80028ce:	2000      	movs	r0, #0
 80028d0:	bd70      	pop	{r4, r5, r6, pc}

080028d2 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80028d2:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 80028d4:	b1c0      	cbz	r0, 8002908 <USBD_GetString+0x36>
 80028d6:	4605      	mov	r5, r0
 80028d8:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 80028da:	f815 4b01 	ldrb.w	r4, [r5], #1
 80028de:	b2db      	uxtb	r3, r3
 80028e0:	2c00      	cmp	r4, #0
 80028e2:	d1f9      	bne.n	80028d8 <USBD_GetString+0x6>
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80028e4:	005b      	lsls	r3, r3, #1
 80028e6:	3302      	adds	r3, #2
 80028e8:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 80028ea:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80028ec:	2303      	movs	r3, #3
 80028ee:	704b      	strb	r3, [r1, #1]
 80028f0:	3801      	subs	r0, #1
 80028f2:	2302      	movs	r3, #2
    
    while (*desc != '\0') 
 80028f4:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 80028f8:	b135      	cbz	r5, 8002908 <USBD_GetString+0x36>
    {
      unicode[idx++] = *desc++;
 80028fa:	1c5a      	adds	r2, r3, #1
 80028fc:	b2d2      	uxtb	r2, r2
 80028fe:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 8002900:	3302      	adds	r3, #2
 8002902:	b2db      	uxtb	r3, r3
 8002904:	548c      	strb	r4, [r1, r2]
 8002906:	e7f5      	b.n	80028f4 <USBD_GetString+0x22>
 8002908:	bd30      	pop	{r4, r5, pc}

0800290a <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800290a:	b510      	push	{r4, lr}
 800290c:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 800290e:	2202      	movs	r2, #2
 8002910:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8002914:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8002916:	460a      	mov	r2, r1
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 8002918:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 800291a:	2100      	movs	r1, #0
 800291c:	f000 fcec 	bl	80032f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002920:	2000      	movs	r0, #0
 8002922:	bd10      	pop	{r4, pc}

08002924 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8002924:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8002926:	4613      	mov	r3, r2
 8002928:	460a      	mov	r2, r1
 800292a:	2100      	movs	r1, #0
 800292c:	f000 fce4 	bl	80032f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002930:	2000      	movs	r0, #0
 8002932:	bd08      	pop	{r3, pc}

08002934 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8002934:	b510      	push	{r4, lr}
 8002936:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8002938:	2203      	movs	r2, #3
 800293a:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 800293e:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8002942:	460a      	mov	r2, r1
                                  uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
  pdev->ep_out[0].total_length = len;
  pdev->ep_out[0].rem_length   = len;
 8002944:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8002948:	2100      	movs	r1, #0
 800294a:	f000 fce3 	bl	8003314 <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 800294e:	2000      	movs	r0, #0
 8002950:	bd10      	pop	{r4, pc}

08002952 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8002952:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8002954:	4613      	mov	r3, r2
 8002956:	460a      	mov	r2, r1
 8002958:	2100      	movs	r1, #0
 800295a:	f000 fcdb 	bl	8003314 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 800295e:	2000      	movs	r0, #0
 8002960:	bd08      	pop	{r3, pc}

08002962 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8002962:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8002964:	2304      	movs	r3, #4
 8002966:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 800296a:	2300      	movs	r3, #0
 800296c:	461a      	mov	r2, r3
 800296e:	4619      	mov	r1, r3
 8002970:	f000 fcc2 	bl	80032f8 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002974:	2000      	movs	r0, #0
 8002976:	bd08      	pop	{r3, pc}

08002978 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8002978:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 800297a:	2305      	movs	r3, #5
 800297c:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8002980:	2300      	movs	r3, #0
 8002982:	461a      	mov	r2, r3
 8002984:	4619      	mov	r1, r3
 8002986:	f000 fcc5 	bl	8003314 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 800298a:	2000      	movs	r0, #0
 800298c:	bd08      	pop	{r3, pc}
	...

08002990 <L3GD20_SetSPI>:
 * @brief	Assign the SPI handle (if initialization was done outside
 * @param	SPI handler pointer
 * @retval	None
 */
void L3GD20_SetSPI(SPI_HandleTypeDef h)
{
 8002990:	b084      	sub	sp, #16
 8002992:	b508      	push	{r3, lr}
 8002994:	f10d 0e08 	add.w	lr, sp, #8
 8002998:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
	hspi1 = h;
 800299c:	4671      	mov	r1, lr
 800299e:	2258      	movs	r2, #88	; 0x58
 80029a0:	4803      	ldr	r0, [pc, #12]	; (80029b0 <L3GD20_SetSPI+0x20>)
 80029a2:	f000 fd7d 	bl	80034a0 <memcpy>
}
 80029a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80029aa:	b004      	add	sp, #16
 80029ac:	4770      	bx	lr
 80029ae:	bf00      	nop
 80029b0:	200001ec 	.word	0x200001ec

080029b4 <L3GD20_Write>:
  * @param  pBuffer : the data to be written to the L3GD20.
  * @param  WriteAddr : L3GD20's internal address to write to.
  * @retval None
  */
void L3GD20_Write(uint8_t buffer, uint8_t WriteAddr)
{
 80029b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();
 80029b6:	4c0d      	ldr	r4, [pc, #52]	; (80029ec <L3GD20_Write+0x38>)
  * @param  pBuffer : the data to be written to the L3GD20.
  * @param  WriteAddr : L3GD20's internal address to write to.
  * @retval None
  */
void L3GD20_Write(uint8_t buffer, uint8_t WriteAddr)
{
 80029b8:	4605      	mov	r5, r0
 80029ba:	460e      	mov	r6, r1
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();
 80029bc:	4620      	mov	r0, r4
 80029be:	2200      	movs	r2, #0
 80029c0:	2108      	movs	r1, #8
 80029c2:	f7fd fd9b 	bl	80004fc <HAL_GPIO_WritePin>

  uint8_t cmd[2] = {0x00 | WriteAddr, buffer};
  HAL_SPI_Transmit(&hspi1,cmd,2,L3GD20_FLAG_TIMEOUT);
 80029c6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80029ca:	a901      	add	r1, sp, #4
 80029cc:	2202      	movs	r2, #2
 80029ce:	4808      	ldr	r0, [pc, #32]	; (80029f0 <L3GD20_Write+0x3c>)
void L3GD20_Write(uint8_t buffer, uint8_t WriteAddr)
{
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();

  uint8_t cmd[2] = {0x00 | WriteAddr, buffer};
 80029d0:	f88d 6004 	strb.w	r6, [sp, #4]
 80029d4:	f88d 5005 	strb.w	r5, [sp, #5]
  HAL_SPI_Transmit(&hspi1,cmd,2,L3GD20_FLAG_TIMEOUT);
 80029d8:	f7fe fcf8 	bl	80013cc <HAL_SPI_Transmit>

  L3GD20_CS_HIGH();
 80029dc:	2201      	movs	r2, #1
 80029de:	2108      	movs	r1, #8
 80029e0:	4620      	mov	r0, r4
 80029e2:	f7fd fd8b 	bl	80004fc <HAL_GPIO_WritePin>
}
 80029e6:	b002      	add	sp, #8
 80029e8:	bd70      	pop	{r4, r5, r6, pc}
 80029ea:	bf00      	nop
 80029ec:	40021000 	.word	0x40021000
 80029f0:	200001ec 	.word	0x200001ec

080029f4 <L3GD20_Read>:
  * @param  ReadAddr : L3GD20's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer,uint8_t ReadAddr, uint16_t NumByteToRead)
{
 80029f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80029f6:	b083      	sub	sp, #12
 80029f8:	460d      	mov	r5, r1
 80029fa:	af02      	add	r7, sp, #8
 80029fc:	4614      	mov	r4, r2
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();
 80029fe:	2108      	movs	r1, #8
  * @param  ReadAddr : L3GD20's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the L3GD20.
  * @retval None
  */
void L3GD20_Read(uint8_t* pBuffer,uint8_t ReadAddr, uint16_t NumByteToRead)
{
 8002a00:	4606      	mov	r6, r0
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();
 8002a02:	2200      	movs	r2, #0
 8002a04:	4813      	ldr	r0, [pc, #76]	; (8002a54 <L3GD20_Read+0x60>)
 8002a06:	f7fd fd79 	bl	80004fc <HAL_GPIO_WritePin>

  /* Format HAL command */
  uint8_t cmd[1+NumByteToRead];// = {READWRITE_CMD | WriteAddr, pBuffer[0]};
 8002a0a:	f104 0308 	add.w	r3, r4, #8
 8002a0e:	f023 0307 	bic.w	r3, r3, #7
 8002a12:	ebad 0d03 	sub.w	sp, sp, r3
  cmd[0] = READWRITE_CMD | MULTIPLEBYTE_CMD | ReadAddr;
 8002a16:	f065 053f 	orn	r5, r5, #63	; 0x3f
{
  /* Chip select (CS) to begin */
  L3GD20_CS_LOW();

  /* Format HAL command */
  uint8_t cmd[1+NumByteToRead];// = {READWRITE_CMD | WriteAddr, pBuffer[0]};
 8002a1a:	a902      	add	r1, sp, #8
  cmd[0] = READWRITE_CMD | MULTIPLEBYTE_CMD | ReadAddr;
 8002a1c:	f88d 5008 	strb.w	r5, [sp, #8]
 8002a20:	f10d 0309 	add.w	r3, sp, #9
  for(int i = 1; i <= NumByteToRead; i++)
	  cmd[i] = DUMMY_BYTE;
 8002a24:	2000      	movs	r0, #0
  L3GD20_CS_LOW();

  /* Format HAL command */
  uint8_t cmd[1+NumByteToRead];// = {READWRITE_CMD | WriteAddr, pBuffer[0]};
  cmd[0] = READWRITE_CMD | MULTIPLEBYTE_CMD | ReadAddr;
  for(int i = 1; i <= NumByteToRead; i++)
 8002a26:	1a5a      	subs	r2, r3, r1
 8002a28:	4294      	cmp	r4, r2
 8002a2a:	db02      	blt.n	8002a32 <L3GD20_Read+0x3e>
	  cmd[i] = DUMMY_BYTE;
 8002a2c:	f803 0b01 	strb.w	r0, [r3], #1
 8002a30:	e7f9      	b.n	8002a26 <L3GD20_Read+0x32>
  /* Transmit/Receive over SPI */
  HAL_SPI_TransmitReceive(&hspi1,cmd,pBuffer,NumByteToRead+1,L3GD20_FLAG_TIMEOUT);
 8002a32:	1c63      	adds	r3, r4, #1
 8002a34:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002a38:	9200      	str	r2, [sp, #0]
 8002a3a:	b29b      	uxth	r3, r3
 8002a3c:	4632      	mov	r2, r6
 8002a3e:	4806      	ldr	r0, [pc, #24]	; (8002a58 <L3GD20_Read+0x64>)
 8002a40:	f7fe fd71 	bl	8001526 <HAL_SPI_TransmitReceive>

  L3GD20_CS_HIGH();
 8002a44:	2201      	movs	r2, #1
 8002a46:	2108      	movs	r1, #8
 8002a48:	4802      	ldr	r0, [pc, #8]	; (8002a54 <L3GD20_Read+0x60>)
 8002a4a:	f7fd fd57 	bl	80004fc <HAL_GPIO_WritePin>
}
 8002a4e:	3704      	adds	r7, #4
 8002a50:	46bd      	mov	sp, r7
 8002a52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002a54:	40021000 	.word	0x40021000
 8002a58:	200001ec 	.word	0x200001ec

08002a5c <L3GD20_GetAngularRateX>:
 * @brief Reads the x-axis angular rate data and returns it as a float
 * @param None
 * @retval X-axis angular rate
 */
float L3GD20_GetAngularRateX(float sensitivity)
{
 8002a5c:	b500      	push	{lr}
 8002a5e:	ed2d 8b02 	vpush	{d8}
 8002a62:	b083      	sub	sp, #12
	float ang = 0;
	uint8_t x_buffer[3] = {0,0,0};
 8002a64:	2300      	movs	r3, #0
	int16_t xdata_raw = 0;

	L3GD20_Read(x_buffer, L3GD20_OUT_X_L_ADDR, 2);
 8002a66:	2202      	movs	r2, #2
 8002a68:	2128      	movs	r1, #40	; 0x28
 8002a6a:	a801      	add	r0, sp, #4
 * @brief Reads the x-axis angular rate data and returns it as a float
 * @param None
 * @retval X-axis angular rate
 */
float L3GD20_GetAngularRateX(float sensitivity)
{
 8002a6c:	eeb0 8a40 	vmov.f32	s16, s0
	float ang = 0;
	uint8_t x_buffer[3] = {0,0,0};
 8002a70:	f88d 3004 	strb.w	r3, [sp, #4]
 8002a74:	f88d 3005 	strb.w	r3, [sp, #5]
 8002a78:	f88d 3006 	strb.w	r3, [sp, #6]
	int16_t xdata_raw = 0;

	L3GD20_Read(x_buffer, L3GD20_OUT_X_L_ADDR, 2);
 8002a7c:	f7ff ffba 	bl	80029f4 <L3GD20_Read>

	xdata_raw = (int16_t)( (uint16_t)(x_buffer[2] << 8) + x_buffer[1] );
	ang = (float)xdata_raw/sensitivity;
 8002a80:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8002a84:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8002a88:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002a8c:	b21b      	sxth	r3, r3
 8002a8e:	ee07 3a90 	vmov	s15, r3
 8002a92:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
	return ang;
}
 8002a96:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8002a9a:	b003      	add	sp, #12
 8002a9c:	ecbd 8b02 	vpop	{d8}
 8002aa0:	f85d fb04 	ldr.w	pc, [sp], #4

08002aa4 <L3GD20_GetAngularRateY>:
 * @brief Reads the y-axis angular rate data and returns it as a float
 * @param None
 * @retval Y-axis angular rate
 */
float L3GD20_GetAngularRateY(float sensitivity)
{
 8002aa4:	b500      	push	{lr}
 8002aa6:	ed2d 8b02 	vpush	{d8}
 8002aaa:	b083      	sub	sp, #12
	float ang = 0;
	uint8_t y_buffer[3];
	int16_t ydata_raw = 0;

	L3GD20_Read(y_buffer, L3GD20_OUT_Y_L_ADDR, 2);
 8002aac:	2202      	movs	r2, #2
 8002aae:	212a      	movs	r1, #42	; 0x2a
 8002ab0:	a801      	add	r0, sp, #4
 * @brief Reads the y-axis angular rate data and returns it as a float
 * @param None
 * @retval Y-axis angular rate
 */
float L3GD20_GetAngularRateY(float sensitivity)
{
 8002ab2:	eeb0 8a40 	vmov.f32	s16, s0
	float ang = 0;
	uint8_t y_buffer[3];
	int16_t ydata_raw = 0;

	L3GD20_Read(y_buffer, L3GD20_OUT_Y_L_ADDR, 2);
 8002ab6:	f7ff ff9d 	bl	80029f4 <L3GD20_Read>

	ydata_raw = (int16_t)( (uint16_t)(y_buffer[2] << 8) + y_buffer[1] );
	ang = (float)ydata_raw/sensitivity;
 8002aba:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8002abe:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8002ac2:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002ac6:	b21b      	sxth	r3, r3
 8002ac8:	ee07 3a90 	vmov	s15, r3
 8002acc:	eeb8 0ae7 	vcvt.f32.s32	s0, s15

	return ang;
}
 8002ad0:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8002ad4:	b003      	add	sp, #12
 8002ad6:	ecbd 8b02 	vpop	{d8}
 8002ada:	f85d fb04 	ldr.w	pc, [sp], #4

08002ade <L3GD20_GetAngularRateZ>:
 * @brief Reads the z-axis angular rate data and returns it as a float
 * @param None
 * @retval Z-axis angular rate
 */
float L3GD20_GetAngularRateZ(float sensitivity)
{
 8002ade:	b500      	push	{lr}
 8002ae0:	ed2d 8b02 	vpush	{d8}
 8002ae4:	b083      	sub	sp, #12
	float ang = 0;
	uint8_t z_buffer[3];
	int16_t zdata_raw = 0;

	L3GD20_Read(z_buffer, L3GD20_OUT_Z_L_ADDR, 2);
 8002ae6:	2202      	movs	r2, #2
 8002ae8:	212c      	movs	r1, #44	; 0x2c
 8002aea:	a801      	add	r0, sp, #4
 * @brief Reads the z-axis angular rate data and returns it as a float
 * @param None
 * @retval Z-axis angular rate
 */
float L3GD20_GetAngularRateZ(float sensitivity)
{
 8002aec:	eeb0 8a40 	vmov.f32	s16, s0
	float ang = 0;
	uint8_t z_buffer[3];
	int16_t zdata_raw = 0;

	L3GD20_Read(z_buffer, L3GD20_OUT_Z_L_ADDR, 2);
 8002af0:	f7ff ff80 	bl	80029f4 <L3GD20_Read>

	zdata_raw = (int16_t)( (uint16_t)(z_buffer[2] << 8) + z_buffer[1] );
	ang = (float)zdata_raw/sensitivity;
 8002af4:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8002af8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8002afc:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002b00:	b21b      	sxth	r3, r3
 8002b02:	ee07 3a90 	vmov	s15, r3
 8002b06:	eeb8 0ae7 	vcvt.f32.s32	s0, s15

	return ang;
}
 8002b0a:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8002b0e:	b003      	add	sp, #12
 8002b10:	ecbd 8b02 	vpop	{d8}
 8002b14:	f85d fb04 	ldr.w	pc, [sp], #4

08002b18 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8002b18:	b530      	push	{r4, r5, lr}
 8002b1a:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 8002b1c:	4b28      	ldr	r3, [pc, #160]	; (8002bc0 <SystemClock_Config+0xa8>)
 8002b1e:	2100      	movs	r1, #0
 8002b20:	9101      	str	r1, [sp, #4]
 8002b22:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002b24:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002b28:	641a      	str	r2, [r3, #64]	; 0x40
 8002b2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8002b2c:	4a25      	ldr	r2, [pc, #148]	; (8002bc4 <SystemClock_Config+0xac>)
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 8002b2e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002b32:	9301      	str	r3, [sp, #4]
 8002b34:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8002b36:	9102      	str	r1, [sp, #8]
 8002b38:	6813      	ldr	r3, [r2, #0]
 8002b3a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002b3e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b42:	6013      	str	r3, [r2, #0]
 8002b44:	6813      	ldr	r3, [r2, #0]
 8002b46:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8002b4a:	9302      	str	r3, [sp, #8]
 8002b4c:	9b02      	ldr	r3, [sp, #8]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8002b4e:	2301      	movs	r3, #1
 8002b50:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8002b52:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8002b56:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002b58:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8002b5c:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 72;
 8002b5e:	2348      	movs	r3, #72	; 0x48

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002b60:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
 8002b62:	2504      	movs	r5, #4
  RCC_OscInitStruct.PLL.PLLN = 72;
 8002b64:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002b66:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 72;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
 8002b68:	2303      	movs	r3, #3

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002b6a:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
 8002b6c:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 72;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8002b6e:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 3;
 8002b70:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002b72:	f7fe f911 	bl	8000d98 <HAL_RCC_OscConfig>
 8002b76:	b100      	cbz	r0, 8002b7a <SystemClock_Config+0x62>
 8002b78:	e7fe      	b.n	8002b78 <SystemClock_Config+0x60>
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002b7a:	230f      	movs	r3, #15
 8002b7c:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002b7e:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8;
 8002b80:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV8;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8002b84:	4621      	mov	r1, r4
 8002b86:	a803      	add	r0, sp, #12

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002b88:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8;
 8002b8a:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV8;
 8002b8c:	9307      	str	r3, [sp, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8002b8e:	f7fe facf 	bl	8001130 <HAL_RCC_ClockConfig>
 8002b92:	4604      	mov	r4, r0
 8002b94:	b100      	cbz	r0, 8002b98 <SystemClock_Config+0x80>
 8002b96:	e7fe      	b.n	8002b96 <SystemClock_Config+0x7e>
    Error_Handler();
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8002b98:	f7fe fb7e 	bl	8001298 <HAL_RCC_GetHCLKFreq>
 8002b9c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002ba0:	fbb0 f0f3 	udiv	r0, r0, r3
 8002ba4:	f7fd fbb4 	bl	8000310 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8002ba8:	4628      	mov	r0, r5
 8002baa:	f7fd fbc7 	bl	800033c <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002bae:	4622      	mov	r2, r4
 8002bb0:	4621      	mov	r1, r4
 8002bb2:	f04f 30ff 	mov.w	r0, #4294967295
 8002bb6:	f7fd fb6b 	bl	8000290 <HAL_NVIC_SetPriority>
}
 8002bba:	b015      	add	sp, #84	; 0x54
 8002bbc:	bd30      	pop	{r4, r5, pc}
 8002bbe:	bf00      	nop
 8002bc0:	40023800 	.word	0x40023800
 8002bc4:	40007000 	.word	0x40007000

08002bc8 <getInt16Str>:
void getInt16Str(int16_t d, char * data_str)
{
	//Max number is 32768 (16 bit), 5 digits and sign (+/-)
	//Instead of processing binary data in Octave we'll send a string
	//Strip the bits, +48 for ASCII 0 - 9, manually to avoid pow()
	if(d > 0)
 8002bc8:	2800      	cmp	r0, #0
}

/* USER CODE BEGIN 4 */

void getInt16Str(int16_t d, char * data_str)
{
 8002bca:	b570      	push	{r4, r5, r6, lr}
	//Max number is 32768 (16 bit), 5 digits and sign (+/-)
	//Instead of processing binary data in Octave we'll send a string
	//Strip the bits, +48 for ASCII 0 - 9, manually to avoid pow()
	if(d > 0)
 8002bcc:	dd32      	ble.n	8002c34 <getInt16Str+0x6c>
	{
		data_str[5] = d%10+48;
 8002bce:	250a      	movs	r5, #10
 8002bd0:	fb90 f3f5 	sdiv	r3, r0, r5
 8002bd4:	fb05 0313 	mls	r3, r5, r3, r0
 8002bd8:	b21a      	sxth	r2, r3
 8002bda:	f102 0330 	add.w	r3, r2, #48	; 0x30
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002bde:	2664      	movs	r6, #100	; 0x64
	//Max number is 32768 (16 bit), 5 digits and sign (+/-)
	//Instead of processing binary data in Octave we'll send a string
	//Strip the bits, +48 for ASCII 0 - 9, manually to avoid pow()
	if(d > 0)
	{
		data_str[5] = d%10+48;
 8002be0:	714b      	strb	r3, [r1, #5]
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002be2:	fb90 f3f6 	sdiv	r3, r0, r6
 8002be6:	fb06 0313 	mls	r3, r6, r3, r0
 8002bea:	b21c      	sxth	r4, r3
 8002bec:	1aa2      	subs	r2, r4, r2
 8002bee:	fb92 f2f5 	sdiv	r2, r2, r5
		data_str[3] = (d%1000 - d%100)/100 + 48;
 8002bf2:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
	//Instead of processing binary data in Octave we'll send a string
	//Strip the bits, +48 for ASCII 0 - 9, manually to avoid pow()
	if(d > 0)
	{
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002bf6:	3230      	adds	r2, #48	; 0x30
		data_str[3] = (d%1000 - d%100)/100 + 48;
 8002bf8:	fb90 f3f5 	sdiv	r3, r0, r5
 8002bfc:	fb05 0313 	mls	r3, r5, r3, r0
	//Instead of processing binary data in Octave we'll send a string
	//Strip the bits, +48 for ASCII 0 - 9, manually to avoid pow()
	if(d > 0)
	{
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002c00:	710a      	strb	r2, [r1, #4]
		data_str[3] = (d%1000 - d%100)/100 + 48;
 8002c02:	b21a      	sxth	r2, r3
 8002c04:	1b14      	subs	r4, r2, r4
 8002c06:	fb94 f4f6 	sdiv	r4, r4, r6
 8002c0a:	3430      	adds	r4, #48	; 0x30
 8002c0c:	70cc      	strb	r4, [r1, #3]
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c0e:	f242 7410 	movw	r4, #10000	; 0x2710
 8002c12:	fb90 f3f4 	sdiv	r3, r0, r4
 8002c16:	fb04 0313 	mls	r3, r4, r3, r0
 8002c1a:	b21b      	sxth	r3, r3
 8002c1c:	1a9a      	subs	r2, r3, r2
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c1e:	1ac0      	subs	r0, r0, r3
	if(d > 0)
	{
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c20:	fb92 f2f5 	sdiv	r2, r2, r5
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c24:	fb90 f0f4 	sdiv	r0, r0, r4
	if(d > 0)
	{
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c28:	3230      	adds	r2, #48	; 0x30
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c2a:	3030      	adds	r0, #48	; 0x30
	if(d > 0)
	{
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c2c:	708a      	strb	r2, [r1, #2]
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c2e:	7048      	strb	r0, [r1, #1]
		data_str[0] = '+';
 8002c30:	232b      	movs	r3, #43	; 0x2b
 8002c32:	e034      	b.n	8002c9e <getInt16Str+0xd6>
	}
	else if(d < 0)
 8002c34:	d034      	beq.n	8002ca0 <getInt16Str+0xd8>
	{
		d = -d;
 8002c36:	4240      	negs	r0, r0
 8002c38:	b200      	sxth	r0, r0
		data_str[5] = d%10+48;
 8002c3a:	260a      	movs	r6, #10
 8002c3c:	fb90 f3f6 	sdiv	r3, r0, r6
 8002c40:	fb06 0313 	mls	r3, r6, r3, r0
 8002c44:	b21a      	sxth	r2, r3
 8002c46:	f102 0330 	add.w	r3, r2, #48	; 0x30
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002c4a:	2564      	movs	r5, #100	; 0x64
		data_str[0] = '+';
	}
	else if(d < 0)
	{
		d = -d;
		data_str[5] = d%10+48;
 8002c4c:	714b      	strb	r3, [r1, #5]
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002c4e:	fb90 f3f5 	sdiv	r3, r0, r5
 8002c52:	fb05 0313 	mls	r3, r5, r3, r0
 8002c56:	b21c      	sxth	r4, r3
 8002c58:	1aa2      	subs	r2, r4, r2
 8002c5a:	fb92 f2f6 	sdiv	r2, r2, r6
		data_str[3] = (d%1000 - d%100)/100 + 48;
 8002c5e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
	}
	else if(d < 0)
	{
		d = -d;
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
 8002c62:	3230      	adds	r2, #48	; 0x30
 8002c64:	710a      	strb	r2, [r1, #4]
		data_str[3] = (d%1000 - d%100)/100 + 48;
 8002c66:	fb90 f2f6 	sdiv	r2, r0, r6
 8002c6a:	fb06 0212 	mls	r2, r6, r2, r0
 8002c6e:	b213      	sxth	r3, r2
 8002c70:	1b1c      	subs	r4, r3, r4
 8002c72:	fb94 f4f5 	sdiv	r4, r4, r5
 8002c76:	3430      	adds	r4, #48	; 0x30
 8002c78:	70cc      	strb	r4, [r1, #3]
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c7a:	f242 7410 	movw	r4, #10000	; 0x2710
 8002c7e:	fb90 f2f4 	sdiv	r2, r0, r4
 8002c82:	fb04 0212 	mls	r2, r4, r2, r0
 8002c86:	b212      	sxth	r2, r2
 8002c88:	1ad3      	subs	r3, r2, r3
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c8a:	1a80      	subs	r0, r0, r2
	{
		d = -d;
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c8c:	fb93 f3f6 	sdiv	r3, r3, r6
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c90:	fb90 f0f4 	sdiv	r0, r0, r4
	{
		d = -d;
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c94:	3330      	adds	r3, #48	; 0x30
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c96:	3030      	adds	r0, #48	; 0x30
	{
		d = -d;
		data_str[5] = d%10+48;
		data_str[4] = (d%100 - d%10)/10 + 48;
		data_str[3] = (d%1000 - d%100)/100 + 48;
		data_str[2] = (d%10000 - d%1000)/1000 + 48;
 8002c98:	708b      	strb	r3, [r1, #2]
		data_str[1] = (d%100000 - d%10000)/10000 + 48;
 8002c9a:	7048      	strb	r0, [r1, #1]
		data_str[0] = '-';
 8002c9c:	232d      	movs	r3, #45	; 0x2d
 8002c9e:	700b      	strb	r3, [r1, #0]
 8002ca0:	bd70      	pop	{r4, r5, r6, pc}
	...

08002ca4 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8002ca4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002ca8:	b0a4      	sub	sp, #144	; 0x90
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8002caa:	2500      	movs	r5, #0
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8002cac:	f7fd faa6 	bl	80001fc <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 8002cb0:	f7ff ff32 	bl	8002b18 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8002cb4:	4b84      	ldr	r3, [pc, #528]	; (8002ec8 <main+0x224>)
 8002cb6:	9517      	str	r5, [sp, #92]	; 0x5c
 8002cb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
 8002cba:	4884      	ldr	r0, [pc, #528]	; (8002ecc <main+0x228>)

/* SPI1 init function */
static void MX_SPI1_Init(void)
{

  hspiloc.Instance = SPI1;
 8002cbc:	4c84      	ldr	r4, [pc, #528]	; (8002ed0 <main+0x22c>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8002cbe:	f042 0210 	orr.w	r2, r2, #16
 8002cc2:	631a      	str	r2, [r3, #48]	; 0x30
 8002cc4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cc6:	f002 0210 	and.w	r2, r2, #16
 8002cca:	9217      	str	r2, [sp, #92]	; 0x5c
 8002ccc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8002cce:	9518      	str	r5, [sp, #96]	; 0x60
 8002cd0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cd2:	f042 0208 	orr.w	r2, r2, #8
 8002cd6:	631a      	str	r2, [r3, #48]	; 0x30
 8002cd8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cda:	f002 0208 	and.w	r2, r2, #8
 8002cde:	9218      	str	r2, [sp, #96]	; 0x60
 8002ce0:	9a18      	ldr	r2, [sp, #96]	; 0x60
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8002ce2:	9519      	str	r5, [sp, #100]	; 0x64
 8002ce4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ce6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002cea:	631a      	str	r2, [r3, #48]	; 0x30
 8002cec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cee:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8002cf2:	9219      	str	r2, [sp, #100]	; 0x64
 8002cf4:	9a19      	ldr	r2, [sp, #100]	; 0x64
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cf6:	951a      	str	r5, [sp, #104]	; 0x68
 8002cf8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cfa:	f042 0201 	orr.w	r2, r2, #1
 8002cfe:	631a      	str	r2, [r3, #48]	; 0x30
 8002d00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d02:	f003 0301 	and.w	r3, r3, #1

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
 8002d06:	2201      	movs	r2, #1

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8002d08:	931a      	str	r3, [sp, #104]	; 0x68

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
 8002d0a:	2108      	movs	r1, #8

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8002d0c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);

  /*Configure GPIO pin : PE3 (CS)*/
  GPIO_InitStruct.Pin = GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8002d0e:	2601      	movs	r6, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
 8002d10:	f7fd fbf4 	bl	80004fc <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PE3 (CS)*/
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8002d14:	f04f 0808 	mov.w	r8, #8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002d18:	a91f      	add	r1, sp, #124	; 0x7c
 8002d1a:	486c      	ldr	r0, [pc, #432]	; (8002ecc <main+0x228>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);

  /*Configure GPIO pin : PE3 (CS)*/
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8002d1c:	f8cd 807c 	str.w	r8, [sp, #124]	; 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8002d20:	9620      	str	r6, [sp, #128]	; 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002d22:	9521      	str	r5, [sp, #132]	; 0x84
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8002d24:	9522      	str	r5, [sp, #136]	; 0x88
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002d26:	f7fd fb1b 	bl	8000360 <HAL_GPIO_Init>

  /*Configure GPIO pins : PE0 PE1 (INT) */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8002d2a:	2303      	movs	r3, #3
 8002d2c:	931f      	str	r3, [sp, #124]	; 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002d2e:	a91f      	add	r1, sp, #124	; 0x7c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : PE0 PE1 (INT) */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8002d30:	4b68      	ldr	r3, [pc, #416]	; (8002ed4 <main+0x230>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002d32:	4866      	ldr	r0, [pc, #408]	; (8002ecc <main+0x228>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : PE0 PE1 (INT) */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8002d34:	9320      	str	r3, [sp, #128]	; 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002d36:	9521      	str	r5, [sp, #132]	; 0x84
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pin : PD12 (LED)*/
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 8002d38:	f44f 5780 	mov.w	r7, #4096	; 0x1000

  /*Configure GPIO pins : PE0 PE1 (INT) */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002d3c:	f7fd fb10 	bl	8000360 <HAL_GPIO_Init>
  /*Configure GPIO pin : PD12 (LED)*/
  GPIO_InitStruct.Pin = GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002d40:	4865      	ldr	r0, [pc, #404]	; (8002ed8 <main+0x234>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pin : PD12 (LED)*/
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 8002d42:	971f      	str	r7, [sp, #124]	; 0x7c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002d44:	a91f      	add	r1, sp, #124	; 0x7c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pin : PD12 (LED)*/
  GPIO_InitStruct.Pin = GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8002d46:	9620      	str	r6, [sp, #128]	; 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002d48:	9521      	str	r5, [sp, #132]	; 0x84
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8002d4a:	9522      	str	r5, [sp, #136]	; 0x88
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002d4c:	f7fd fb08 	bl	8000360 <HAL_GPIO_Init>
  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USB_DEVICE_Init();
 8002d50:	f000 f956 	bl	8003000 <MX_USB_DEVICE_Init>
/* SPI1 init function */
static void MX_SPI1_Init(void)
{

  hspiloc.Instance = SPI1;
  hspiloc.Init.Mode = SPI_MODE_MASTER;
 8002d54:	4a61      	ldr	r2, [pc, #388]	; (8002edc <main+0x238>)
  hspiloc.Init.Direction = SPI_DIRECTION_2LINES;
 8002d56:	60a5      	str	r5, [r4, #8]
/* SPI1 init function */
static void MX_SPI1_Init(void)
{

  hspiloc.Instance = SPI1;
  hspiloc.Init.Mode = SPI_MODE_MASTER;
 8002d58:	f44f 7382 	mov.w	r3, #260	; 0x104
 8002d5c:	e884 000c 	stmia.w	r4, {r2, r3}
  hspiloc.Init.Direction = SPI_DIRECTION_2LINES;
  hspiloc.Init.DataSize = SPI_DATASIZE_8BIT;
  hspiloc.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspiloc.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspiloc.Init.NSS = SPI_NSS_SOFT;
 8002d60:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002d64:	61a3      	str	r3, [r4, #24]
  hspiloc.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8002d66:	2310      	movs	r3, #16
 8002d68:	61e3      	str	r3, [r4, #28]
  hspiloc.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspiloc.Init.TIMode = SPI_TIMODE_DISABLE;
  hspiloc.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspiloc.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspiloc) != HAL_OK)
 8002d6a:	4620      	mov	r0, r4
  hspiloc.Init.NSS = SPI_NSS_SOFT;
  hspiloc.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspiloc.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspiloc.Init.TIMode = SPI_TIMODE_DISABLE;
  hspiloc.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspiloc.Init.CRCPolynomial = 10;
 8002d6c:	230a      	movs	r3, #10
{

  hspiloc.Instance = SPI1;
  hspiloc.Init.Mode = SPI_MODE_MASTER;
  hspiloc.Init.Direction = SPI_DIRECTION_2LINES;
  hspiloc.Init.DataSize = SPI_DATASIZE_8BIT;
 8002d6e:	60e5      	str	r5, [r4, #12]
  hspiloc.Init.CLKPolarity = SPI_POLARITY_LOW;
 8002d70:	6125      	str	r5, [r4, #16]
  hspiloc.Init.CLKPhase = SPI_PHASE_1EDGE;
 8002d72:	6165      	str	r5, [r4, #20]
  hspiloc.Init.NSS = SPI_NSS_SOFT;
  hspiloc.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspiloc.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8002d74:	6225      	str	r5, [r4, #32]
  hspiloc.Init.TIMode = SPI_TIMODE_DISABLE;
 8002d76:	6265      	str	r5, [r4, #36]	; 0x24
  hspiloc.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002d78:	62a5      	str	r5, [r4, #40]	; 0x28
  hspiloc.Init.CRCPolynomial = 10;
 8002d7a:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (HAL_SPI_Init(&hspiloc) != HAL_OK)
 8002d7c:	f7fe fae9 	bl	8001352 <HAL_SPI_Init>
 8002d80:	b100      	cbz	r0, 8002d84 <main+0xe0>
 8002d82:	e7fe      	b.n	8002d82 <main+0xde>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USB_DEVICE_Init();
  MX_SPI1_Init();
  L3GD20_SetSPI(hspiloc); //Set the SPI handler
 8002d84:	2248      	movs	r2, #72	; 0x48
 8002d86:	f104 0110 	add.w	r1, r4, #16
 8002d8a:	4668      	mov	r0, sp
 8002d8c:	f000 fb88 	bl	80034a0 <memcpy>
 8002d90:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8002d94:	f7ff fdfc 	bl	8002990 <L3GD20_SetSPI>
  uint8_t readxyz_cmd[7] = {READWRITE_CMD | MULTIPLEBYTE_CMD | L3GD20_OUT_X_L_ADDR, DUMMY_BYTE, DUMMY_BYTE, DUMMY_BYTE, DUMMY_BYTE, DUMMY_BYTE, DUMMY_BYTE};
  uint8_t startbyte[5] = {'s','t','a','r','t'};
  float sensitivity_250 = 114.285f;

  //Initialize clock select (!CS) to HIGH
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
 8002d98:	4632      	mov	r2, r6
 8002d9a:	4641      	mov	r1, r8
 8002d9c:	484b      	ldr	r0, [pc, #300]	; (8002ecc <main+0x228>)
 8002d9e:	f7fd fbad 	bl	80004fc <HAL_GPIO_WritePin>

  //Initialize control registers in L3GD20=========
  //Check for Who Am I, should turn on green LED
  L3GD20_Read(whoami_buf, L3GD20_WHO_AM_I_ADDR,1);
 8002da2:	4632      	mov	r2, r6
 8002da4:	210f      	movs	r1, #15
 8002da6:	a815      	add	r0, sp, #84	; 0x54
 8002da8:	f7ff fe24 	bl	80029f4 <L3GD20_Read>
  if(whoami_buf[1] == I_AM_L3GD20)
 8002dac:	f89d 3055 	ldrb.w	r3, [sp, #85]	; 0x55
 8002db0:	2bd4      	cmp	r3, #212	; 0xd4
 8002db2:	d104      	bne.n	8002dbe <main+0x11a>
	  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 8002db4:	4632      	mov	r2, r6
 8002db6:	4639      	mov	r1, r7
 8002db8:	4847      	ldr	r0, [pc, #284]	; (8002ed8 <main+0x234>)
 8002dba:	f7fd fb9f 	bl	80004fc <HAL_GPIO_WritePin>

  //Set control register 1
  L3GD20_Write(ctrl1_cmd,L3GD20_CTRL_REG1_ADDR);
 8002dbe:	200f      	movs	r0, #15
 8002dc0:	2120      	movs	r1, #32
 8002dc2:	f7ff fdf7 	bl	80029b4 <L3GD20_Write>
  int16_t xdata = 0;
  int16_t ydata = 0;
  int16_t zdata = 0;
  uint8_t send = 1; //Send or don't send flag

  volatile char xdata_str[6] = {'0','0','0','0','0','0'};
 8002dc6:	4b46      	ldr	r3, [pc, #280]	; (8002ee0 <main+0x23c>)
 8002dc8:	6818      	ldr	r0, [r3, #0]
 8002dca:	889b      	ldrh	r3, [r3, #4]
 8002dcc:	901b      	str	r0, [sp, #108]	; 0x6c
  while (1)
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  lRxData = 1;
 8002dce:	2401      	movs	r4, #1
  int16_t xdata = 0;
  int16_t ydata = 0;
  int16_t zdata = 0;
  uint8_t send = 1; //Send or don't send flag

  volatile char xdata_str[6] = {'0','0','0','0','0','0'};
 8002dd0:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
  volatile char ydata_str[6] = {'0','0','0','0','0','0'};
 8002dd4:	901d      	str	r0, [sp, #116]	; 0x74
 8002dd6:	f8ad 3078 	strh.w	r3, [sp, #120]	; 0x78
  volatile char zdata_str[6] = {'0','0','0','0','0','0'};
 8002dda:	901f      	str	r0, [sp, #124]	; 0x7c
 8002ddc:	f8ad 3080 	strh.w	r3, [sp, #128]	; 0x80
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  lRxData = 1;
	  CDC_Receive_FS(&rxData, &lRxData);
 8002de0:	a916      	add	r1, sp, #88	; 0x58
 8002de2:	f10d 0053 	add.w	r0, sp, #83	; 0x53
  while (1)
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  lRxData = 1;
 8002de6:	9416      	str	r4, [sp, #88]	; 0x58
	  CDC_Receive_FS(&rxData, &lRxData);
 8002de8:	f000 f93e 	bl	8003068 <CDC_Receive_FS>
	  if(rxData == 'x')
 8002dec:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
 8002df0:	2b78      	cmp	r3, #120	; 0x78
 8002df2:	d11f      	bne.n	8002e34 <main+0x190>
	  {
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 8002df4:	2200      	movs	r2, #0
 8002df6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002dfa:	4837      	ldr	r0, [pc, #220]	; (8002ed8 <main+0x234>)
 8002dfc:	f7fd fb7e 	bl	80004fc <HAL_GPIO_WritePin>
		  xdata = (int16_t)L3GD20_GetAngularRateX(1); //No sensitivity adjustment
 8002e00:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8002e04:	f7ff fe2a 	bl	8002a5c <L3GD20_GetAngularRateX>
		  getInt16Str(xdata,xdata_str);
 8002e08:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8002e0c:	a91b      	add	r1, sp, #108	; 0x6c
 8002e0e:	edcd 7a13 	vstr	s15, [sp, #76]	; 0x4c
 8002e12:	f9bd 004c 	ldrsh.w	r0, [sp, #76]	; 0x4c
 8002e16:	f7ff fed7 	bl	8002bc8 <getInt16Str>
		  CDC_Transmit_FS(xdata_str,6);
 8002e1a:	2106      	movs	r1, #6
 8002e1c:	a81b      	add	r0, sp, #108	; 0x6c
 8002e1e:	f000 f931 	bl	8003084 <CDC_Transmit_FS>
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 8002e22:	482d      	ldr	r0, [pc, #180]	; (8002ed8 <main+0x234>)
 8002e24:	2201      	movs	r2, #1
 8002e26:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002e2a:	f7fd fb67 	bl	80004fc <HAL_GPIO_WritePin>
		  HAL_Delay(1);
 8002e2e:	2001      	movs	r0, #1
 8002e30:	f7fd fa0c 	bl	800024c <HAL_Delay>
	  }
	  if(rxData == 'y')
 8002e34:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
 8002e38:	2b79      	cmp	r3, #121	; 0x79
 8002e3a:	d11f      	bne.n	8002e7c <main+0x1d8>
	  {
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 8002e3c:	2200      	movs	r2, #0
 8002e3e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002e42:	4825      	ldr	r0, [pc, #148]	; (8002ed8 <main+0x234>)
 8002e44:	f7fd fb5a 	bl	80004fc <HAL_GPIO_WritePin>
		  ydata = (int16_t)L3GD20_GetAngularRateY(1); //No sensitivity adjustment
 8002e48:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8002e4c:	f7ff fe2a 	bl	8002aa4 <L3GD20_GetAngularRateY>
		  getInt16Str(ydata,ydata_str);
 8002e50:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8002e54:	a91d      	add	r1, sp, #116	; 0x74
 8002e56:	edcd 7a13 	vstr	s15, [sp, #76]	; 0x4c
 8002e5a:	f9bd 004c 	ldrsh.w	r0, [sp, #76]	; 0x4c
 8002e5e:	f7ff feb3 	bl	8002bc8 <getInt16Str>
		  CDC_Transmit_FS(ydata_str,6);
 8002e62:	2106      	movs	r1, #6
 8002e64:	a81d      	add	r0, sp, #116	; 0x74
 8002e66:	f000 f90d 	bl	8003084 <CDC_Transmit_FS>
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 8002e6a:	481b      	ldr	r0, [pc, #108]	; (8002ed8 <main+0x234>)
 8002e6c:	2201      	movs	r2, #1
 8002e6e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002e72:	f7fd fb43 	bl	80004fc <HAL_GPIO_WritePin>
		  HAL_Delay(1);
 8002e76:	2001      	movs	r0, #1
 8002e78:	f7fd f9e8 	bl	800024c <HAL_Delay>
	  }
	  if(rxData == 'z')
 8002e7c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
 8002e80:	2b7a      	cmp	r3, #122	; 0x7a
 8002e82:	d1ad      	bne.n	8002de0 <main+0x13c>
	  {
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
 8002e84:	2200      	movs	r2, #0
 8002e86:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002e8a:	4813      	ldr	r0, [pc, #76]	; (8002ed8 <main+0x234>)
 8002e8c:	f7fd fb36 	bl	80004fc <HAL_GPIO_WritePin>
		  zdata = (int16_t)L3GD20_GetAngularRateZ(1); //No sensitivity adjustment
 8002e90:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8002e94:	f7ff fe23 	bl	8002ade <L3GD20_GetAngularRateZ>
		  getInt16Str(zdata,zdata_str);
 8002e98:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8002e9c:	a91f      	add	r1, sp, #124	; 0x7c
 8002e9e:	edcd 7a13 	vstr	s15, [sp, #76]	; 0x4c
 8002ea2:	f9bd 004c 	ldrsh.w	r0, [sp, #76]	; 0x4c
 8002ea6:	f7ff fe8f 	bl	8002bc8 <getInt16Str>
		  CDC_Transmit_FS(zdata_str,6);
 8002eaa:	2106      	movs	r1, #6
 8002eac:	a81f      	add	r0, sp, #124	; 0x7c
 8002eae:	f000 f8e9 	bl	8003084 <CDC_Transmit_FS>
		  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
 8002eb2:	2201      	movs	r2, #1
 8002eb4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002eb8:	4807      	ldr	r0, [pc, #28]	; (8002ed8 <main+0x234>)
 8002eba:	f7fd fb1f 	bl	80004fc <HAL_GPIO_WritePin>
		  HAL_Delay(1);
 8002ebe:	2001      	movs	r0, #1
 8002ec0:	f7fd f9c4 	bl	800024c <HAL_Delay>
 8002ec4:	e78c      	b.n	8002de0 <main+0x13c>
 8002ec6:	bf00      	nop
 8002ec8:	40023800 	.word	0x40023800
 8002ecc:	40021000 	.word	0x40021000
 8002ed0:	20000244 	.word	0x20000244
 8002ed4:	10110000 	.word	0x10110000
 8002ed8:	40020c00 	.word	0x40020c00
 8002edc:	40013000 	.word	0x40013000
 8002ee0:	08003668 	.word	0x08003668

08002ee4 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 8002ee4:	e7fe      	b.n	8002ee4 <Error_Handler>

08002ee6 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8002ee6:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8002ee8:	2007      	movs	r0, #7
 8002eea:	f7fd f9bf 	bl	800026c <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8002eee:	2200      	movs	r2, #0
 8002ef0:	4611      	mov	r1, r2
 8002ef2:	f06f 000b 	mvn.w	r0, #11
 8002ef6:	f7fd f9cb 	bl	8000290 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8002efa:	2200      	movs	r2, #0
 8002efc:	4611      	mov	r1, r2
 8002efe:	f06f 000a 	mvn.w	r0, #10
 8002f02:	f7fd f9c5 	bl	8000290 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8002f06:	2200      	movs	r2, #0
 8002f08:	4611      	mov	r1, r2
 8002f0a:	f06f 0009 	mvn.w	r0, #9
 8002f0e:	f7fd f9bf 	bl	8000290 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8002f12:	2200      	movs	r2, #0
 8002f14:	4611      	mov	r1, r2
 8002f16:	f06f 0004 	mvn.w	r0, #4
 8002f1a:	f7fd f9b9 	bl	8000290 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8002f1e:	2200      	movs	r2, #0
 8002f20:	4611      	mov	r1, r2
 8002f22:	f06f 0003 	mvn.w	r0, #3
 8002f26:	f7fd f9b3 	bl	8000290 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8002f2a:	2200      	movs	r2, #0
 8002f2c:	4611      	mov	r1, r2
 8002f2e:	f06f 0001 	mvn.w	r0, #1
 8002f32:	f7fd f9ad 	bl	8000290 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002f36:	2200      	movs	r2, #0
 8002f38:	4611      	mov	r1, r2
 8002f3a:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8002f3e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002f42:	f7fd b9a5 	b.w	8000290 <HAL_NVIC_SetPriority>
	...

08002f48 <HAL_SPI_MspInit>:

  /* USER CODE END MspInit 1 */
}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8002f48:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8002f4a:	6802      	ldr	r2, [r0, #0]
 8002f4c:	4b0f      	ldr	r3, [pc, #60]	; (8002f8c <HAL_SPI_MspInit+0x44>)
 8002f4e:	429a      	cmp	r2, r3
 8002f50:	d119      	bne.n	8002f86 <HAL_SPI_MspInit+0x3e>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002f52:	2100      	movs	r1, #0
 8002f54:	f503 3384 	add.w	r3, r3, #67584	; 0x10800
 8002f58:	9100      	str	r1, [sp, #0]
 8002f5a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002f5c:	480c      	ldr	r0, [pc, #48]	; (8002f90 <HAL_SPI_MspInit+0x48>)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002f5e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002f62:	645a      	str	r2, [r3, #68]	; 0x44
 8002f64:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002f66:	9103      	str	r1, [sp, #12]
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002f68:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002f6c:	9300      	str	r3, [sp, #0]
 8002f6e:	9b00      	ldr	r3, [sp, #0]
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8002f70:	23e0      	movs	r3, #224	; 0xe0
 8002f72:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002f74:	2302      	movs	r3, #2
 8002f76:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002f78:	2303      	movs	r3, #3
 8002f7a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002f7c:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8002f7e:	2305      	movs	r3, #5
 8002f80:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002f82:	f7fd f9ed 	bl	8000360 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8002f86:	b007      	add	sp, #28
 8002f88:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f8c:	40013000 	.word	0x40013000
 8002f90:	40020000 	.word	0x40020000

08002f94 <SVC_Handler>:
 8002f94:	4770      	bx	lr

08002f96 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 8002f96:	4770      	bx	lr

08002f98 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8002f98:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8002f9a:	f7fd f949 	bl	8000230 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8002f9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8002fa2:	f7fd b9d8 	b.w	8000356 <HAL_SYSTICK_IRQHandler>
	...

08002fa8 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8002fa8:	4801      	ldr	r0, [pc, #4]	; (8002fb0 <OTG_FS_IRQHandler+0x8>)
 8002faa:	f7fd bb2d 	b.w	8000608 <HAL_PCD_IRQHandler>
 8002fae:	bf00      	nop
 8002fb0:	200004c8 	.word	0x200004c8

08002fb4 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8002fb4:	490f      	ldr	r1, [pc, #60]	; (8002ff4 <SystemInit+0x40>)
 8002fb6:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002fba:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8002fbe:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002fc2:	4b0d      	ldr	r3, [pc, #52]	; (8002ff8 <SystemInit+0x44>)
 8002fc4:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002fc6:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002fc8:	f042 0201 	orr.w	r2, r2, #1
 8002fcc:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002fce:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002fd0:	681a      	ldr	r2, [r3, #0]
 8002fd2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8002fd6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002fda:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8002fdc:	4a07      	ldr	r2, [pc, #28]	; (8002ffc <SystemInit+0x48>)
 8002fde:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002fe0:	681a      	ldr	r2, [r3, #0]
 8002fe2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002fe6:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8002fe8:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002fea:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8002fee:	608b      	str	r3, [r1, #8]
 8002ff0:	4770      	bx	lr
 8002ff2:	bf00      	nop
 8002ff4:	e000ed00 	.word	0xe000ed00
 8002ff8:	40023800 	.word	0x40023800
 8002ffc:	24003010 	.word	0x24003010

08003000 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8003000:	b510      	push	{r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8003002:	4c09      	ldr	r4, [pc, #36]	; (8003028 <MX_USB_DEVICE_Init+0x28>)
 8003004:	4909      	ldr	r1, [pc, #36]	; (800302c <MX_USB_DEVICE_Init+0x2c>)
 8003006:	2200      	movs	r2, #0
 8003008:	4620      	mov	r0, r4
 800300a:	f7ff f991 	bl	8002330 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 800300e:	4908      	ldr	r1, [pc, #32]	; (8003030 <MX_USB_DEVICE_Init+0x30>)
 8003010:	4620      	mov	r0, r4
 8003012:	f7ff f9a2 	bl	800235a <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8003016:	4620      	mov	r0, r4
 8003018:	4906      	ldr	r1, [pc, #24]	; (8003034 <MX_USB_DEVICE_Init+0x34>)
 800301a:	f7ff f94a 	bl	80022b2 <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 800301e:	4620      	mov	r0, r4

}
 8003020:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);

  USBD_Start(&hUsbDeviceFS);
 8003024:	f7ff b9a0 	b.w	8002368 <USBD_Start>
 8003028:	2000029c 	.word	0x2000029c
 800302c:	20000124 	.word	0x20000124
 8003030:	20000044 	.word	0x20000044
 8003034:	20000114 	.word	0x20000114

08003038 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */ 
  return (USBD_OK);
  /* USER CODE END 4 */ 
}
 8003038:	2000      	movs	r0, #0
 800303a:	4770      	bx	lr

0800303c <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 800303c:	2000      	movs	r0, #0
 800303e:	4770      	bx	lr

08003040 <CDC_Init_FS>:
  *         Initializes the CDC media low layer over the FS USB IP
  * @param  None
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{ 
 8003040:	b510      	push	{r4, lr}
  /* USER CODE BEGIN 3 */ 
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8003042:	4c06      	ldr	r4, [pc, #24]	; (800305c <CDC_Init_FS+0x1c>)
 8003044:	4906      	ldr	r1, [pc, #24]	; (8003060 <CDC_Init_FS+0x20>)
 8003046:	2200      	movs	r2, #0
 8003048:	4620      	mov	r0, r4
 800304a:	f7ff f939 	bl	80022c0 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 800304e:	4905      	ldr	r1, [pc, #20]	; (8003064 <CDC_Init_FS+0x24>)
 8003050:	4620      	mov	r0, r4
 8003052:	f7ff f93d 	bl	80022d0 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
  /* USER CODE END 3 */ 
}
 8003056:	2000      	movs	r0, #0
 8003058:	bd10      	pop	{r4, pc}
 800305a:	bf00      	nop
 800305c:	2000029c 	.word	0x2000029c
 8003060:	200004c4 	.word	0x200004c4
 8003064:	200004c0 	.word	0x200004c0

08003068 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 8003068:	b510      	push	{r4, lr}
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 800306a:	4c05      	ldr	r4, [pc, #20]	; (8003080 <CDC_Receive_FS+0x18>)
 800306c:	4601      	mov	r1, r0
 800306e:	4620      	mov	r0, r4
 8003070:	f7ff f92e 	bl	80022d0 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 8003074:	4620      	mov	r0, r4
 8003076:	f7ff f948 	bl	800230a <USBD_CDC_ReceivePacket>
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 800307a:	2000      	movs	r0, #0
 800307c:	bd10      	pop	{r4, pc}
 800307e:	bf00      	nop
 8003080:	2000029c 	.word	0x2000029c

08003084 <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be send
  * @param  Len: Number of data to be send (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8003084:	b510      	push	{r4, lr}
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */ 
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8003086:	4c09      	ldr	r4, [pc, #36]	; (80030ac <CDC_Transmit_FS+0x28>)
 8003088:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  if (hcdc->TxState != 0){
 800308c:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
  * @param  Buf: Buffer of data to be send
  * @param  Len: Number of data to be send (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8003090:	460a      	mov	r2, r1
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */ 
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hcdc->TxState != 0){
 8003092:	b943      	cbnz	r3, 80030a6 <CDC_Transmit_FS+0x22>
    return USBD_BUSY;
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8003094:	4601      	mov	r1, r0
 8003096:	4620      	mov	r0, r4
 8003098:	f7ff f912 	bl	80022c0 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 800309c:	4620      	mov	r0, r4
  /* USER CODE END 7 */ 
  return result;
}
 800309e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hcdc->TxState != 0){
    return USBD_BUSY;
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 80030a2:	f7ff b91b 	b.w	80022dc <USBD_CDC_TransmitPacket>
  /* USER CODE END 7 */ 
  return result;
}
 80030a6:	2001      	movs	r0, #1
 80030a8:	bd10      	pop	{r4, pc}
 80030aa:	bf00      	nop
 80030ac:	2000029c 	.word	0x2000029c

080030b0 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80030b0:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80030b2:	6803      	ldr	r3, [r0, #0]
 80030b4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80030b8:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80030ba:	d125      	bne.n	8003108 <HAL_PCD_MspInit+0x58>
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80030bc:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80030c0:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80030c2:	2302      	movs	r3, #2
 80030c4:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80030c6:	2303      	movs	r3, #3
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80030c8:	2400      	movs	r4, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80030ca:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030cc:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80030ce:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030d0:	480e      	ldr	r0, [pc, #56]	; (800310c <HAL_PCD_MspInit+0x5c>)
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80030d2:	9305      	str	r3, [sp, #20]
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80030d4:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80030d6:	f7fd f943 	bl	8000360 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80030da:	4b0d      	ldr	r3, [pc, #52]	; (8003110 <HAL_PCD_MspInit+0x60>)
 80030dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80030de:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80030e2:	635a      	str	r2, [r3, #52]	; 0x34
 80030e4:	9400      	str	r4, [sp, #0]
 80030e6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80030e8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80030ec:	645a      	str	r2, [r3, #68]	; 0x44
 80030ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80030f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80030f4:	9300      	str	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 80030f6:	2043      	movs	r0, #67	; 0x43
 80030f8:	4622      	mov	r2, r4
 80030fa:	4621      	mov	r1, r4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80030fc:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 80030fe:	f7fd f8c7 	bl	8000290 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8003102:	2043      	movs	r0, #67	; 0x43
 8003104:	f7fd f8f8 	bl	80002f8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8003108:	b006      	add	sp, #24
 800310a:	bd10      	pop	{r4, pc}
 800310c:	40020000 	.word	0x40020000
 8003110:	40023800 	.word	0x40023800

08003114 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8003114:	f500 716f 	add.w	r1, r0, #956	; 0x3bc
 8003118:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800311c:	f7ff b93b 	b.w	8002396 <USBD_LL_SetupStage>

08003120 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8003120:	231c      	movs	r3, #28
 8003122:	fb03 0301 	mla	r3, r3, r1, r0
 8003126:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800312a:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 800312e:	f7ff b95f 	b.w	80023f0 <USBD_LL_DataOutStage>

08003132 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003132:	231c      	movs	r3, #28
 8003134:	fb03 0301 	mla	r3, r3, r1, r0
 8003138:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800313c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800313e:	f7ff b988 	b.w	8002452 <USBD_LL_DataInStage>

08003142 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8003142:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003146:	f7ff ba03 	b.w	8002550 <USBD_LL_SOF>

0800314a <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 800314a:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 800314c:	68c1      	ldr	r1, [r0, #12]
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 800314e:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;    
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);  
 8003150:	3100      	adds	r1, #0
 8003152:	bf18      	it	ne
 8003154:	2101      	movne	r1, #1
 8003156:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 800315a:	f7ff f9e7 	bl	800252c <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 800315e:	f8d4 03ec 	ldr.w	r0, [r4, #1004]	; 0x3ec
}
 8003162:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);  
  
  /*Reset Device*/
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8003166:	f7ff b9c2 	b.w	80024ee <USBD_LL_Reset>
	...

0800316c <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{  
 800316c:	b510      	push	{r4, lr}
 800316e:	4604      	mov	r4, r0
   /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8003170:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 8003174:	f7ff f9dd 	bl	8002532 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8003178:	6822      	ldr	r2, [r4, #0]
 800317a:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 800317e:	f043 0301 	orr.w	r3, r3, #1
 8003182:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8003186:	6a23      	ldr	r3, [r4, #32]
 8003188:	b123      	cbz	r3, 8003194 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 800318a:	4a03      	ldr	r2, [pc, #12]	; (8003198 <HAL_PCD_SuspendCallback+0x2c>)
 800318c:	6913      	ldr	r3, [r2, #16]
 800318e:	f043 0306 	orr.w	r3, r3, #6
 8003192:	6113      	str	r3, [r2, #16]
 8003194:	bd10      	pop	{r4, pc}
 8003196:	bf00      	nop
 8003198:	e000ed00 	.word	0xe000ed00

0800319c <HAL_PCD_ResumeCallback>:
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 800319c:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80031a0:	f7ff b9d0 	b.w	8002544 <USBD_LL_Resume>

080031a4 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 80031a4:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80031a8:	f7ff b9e0 	b.w	800256c <USBD_LL_IsoOUTIncomplete>

080031ac <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 80031ac:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80031b0:	f7ff b9da 	b.w	8002568 <USBD_LL_IsoINIncomplete>

080031b4 <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 80031b4:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80031b8:	f7ff b9da 	b.w	8002570 <USBD_LL_DevConnected>

080031bc <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 80031bc:	f8d0 03ec 	ldr.w	r0, [r0, #1004]	; 0x3ec
 80031c0:	f7ff b9d8 	b.w	8002574 <USBD_LL_DevDisconnected>

080031c4 <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 80031c4:	b508      	push	{r3, lr}
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
 80031c6:	7802      	ldrb	r2, [r0, #0]
 80031c8:	bb42      	cbnz	r2, 800321c <USBD_LL_Init+0x58>
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 80031ca:	4b15      	ldr	r3, [pc, #84]	; (8003220 <USBD_LL_Init+0x5c>)
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 80031cc:	2104      	movs	r1, #4
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 80031ce:	f8c3 03ec 	str.w	r0, [r3, #1004]	; 0x3ec
  pdev->pData = &hpcd_USB_OTG_FS; 
 80031d2:	f8c0 3220 	str.w	r3, [r0, #544]	; 0x220
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 80031d6:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80031da:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 80031de:	2102      	movs	r1, #2
 80031e0:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 80031e2:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80031e4:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 80031e6:	2101      	movs	r1, #1
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 80031e8:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 80031ea:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 80031ec:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 80031ee:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 80031f0:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 80031f2:	62d9      	str	r1, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 80031f4:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80031f6:	f7fd f985 	bl	8000504 <HAL_PCD_Init>
 80031fa:	b108      	cbz	r0, 8003200 <USBD_LL_Init+0x3c>
  {
    Error_Handler();
 80031fc:	f7ff fe72 	bl	8002ee4 <Error_Handler>
  }

  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8003200:	2180      	movs	r1, #128	; 0x80
 8003202:	4807      	ldr	r0, [pc, #28]	; (8003220 <USBD_LL_Init+0x5c>)
 8003204:	f7fd fdc4 	bl	8000d90 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8003208:	2240      	movs	r2, #64	; 0x40
 800320a:	2100      	movs	r1, #0
 800320c:	4804      	ldr	r0, [pc, #16]	; (8003220 <USBD_LL_Init+0x5c>)
 800320e:	f7fd fd9e 	bl	8000d4e <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8003212:	2280      	movs	r2, #128	; 0x80
 8003214:	2101      	movs	r1, #1
 8003216:	4802      	ldr	r0, [pc, #8]	; (8003220 <USBD_LL_Init+0x5c>)
 8003218:	f7fd fd99 	bl	8000d4e <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
}
 800321c:	2000      	movs	r0, #0
 800321e:	bd08      	pop	{r3, pc}
 8003220:	200004c8 	.word	0x200004c8

08003224 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003224:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8003226:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800322a:	f7fd f9d7 	bl	80005dc <HAL_PCD_Start>
 800322e:	2803      	cmp	r0, #3
 8003230:	bf9a      	itte	ls
 8003232:	4b02      	ldrls	r3, [pc, #8]	; (800323c <USBD_LL_Start+0x18>)
 8003234:	5c18      	ldrbls	r0, [r3, r0]
 8003236:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003238:	bd08      	pop	{r3, pc}
 800323a:	bf00      	nop
 800323c:	0800367e 	.word	0x0800367e

08003240 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 8003240:	b510      	push	{r4, lr}
 8003242:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, 
 8003244:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003248:	4613      	mov	r3, r2
 800324a:	4622      	mov	r2, r4
 800324c:	f7fd fc92 	bl	8000b74 <HAL_PCD_EP_Open>
 8003250:	2803      	cmp	r0, #3
 8003252:	bf9a      	itte	ls
 8003254:	4b01      	ldrls	r3, [pc, #4]	; (800325c <USBD_LL_OpenEP+0x1c>)
 8003256:	5c18      	ldrbls	r0, [r3, r0]
 8003258:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 800325a:	bd10      	pop	{r4, pc}
 800325c:	0800367e 	.word	0x0800367e

08003260 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8003260:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8003262:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003266:	f7fd fcb3 	bl	8000bd0 <HAL_PCD_EP_Close>
 800326a:	2803      	cmp	r0, #3
 800326c:	bf9a      	itte	ls
 800326e:	4b02      	ldrls	r3, [pc, #8]	; (8003278 <USBD_LL_CloseEP+0x18>)
 8003270:	5c18      	ldrbls	r0, [r3, r0]
 8003272:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003274:	bd08      	pop	{r3, pc}
 8003276:	bf00      	nop
 8003278:	0800367e 	.word	0x0800367e

0800327c <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 800327c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800327e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003282:	f7fd fd13 	bl	8000cac <HAL_PCD_EP_SetStall>
 8003286:	2803      	cmp	r0, #3
 8003288:	bf9a      	itte	ls
 800328a:	4b02      	ldrls	r3, [pc, #8]	; (8003294 <USBD_LL_StallEP+0x18>)
 800328c:	5c18      	ldrbls	r0, [r3, r0]
 800328e:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8003290:	bd08      	pop	{r3, pc}
 8003292:	bf00      	nop
 8003294:	0800367e 	.word	0x0800367e

08003298 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8003298:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 800329a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800329e:	f7fd fd31 	bl	8000d04 <HAL_PCD_EP_ClrStall>
 80032a2:	2803      	cmp	r0, #3
 80032a4:	bf9a      	itte	ls
 80032a6:	4b02      	ldrls	r3, [pc, #8]	; (80032b0 <USBD_LL_ClearStallEP+0x18>)
 80032a8:	5c18      	ldrbls	r0, [r3, r0]
 80032aa:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 80032ac:	bd08      	pop	{r3, pc}
 80032ae:	bf00      	nop
 80032b0:	0800367e 	.word	0x0800367e

080032b4 <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
 80032b4:	f011 0f80 	tst.w	r1, #128	; 0x80
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 80032b8:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 80032bc:	bf18      	it	ne
 80032be:	f001 037f 	andne.w	r3, r1, #127	; 0x7f
 80032c2:	f04f 001c 	mov.w	r0, #28
 80032c6:	bf15      	itete	ne
 80032c8:	fb00 2103 	mlane	r1, r0, r3, r2
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80032cc:	fb00 2101 	mlaeq	r1, r0, r1, r2
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 80032d0:	f891 003a 	ldrbne.w	r0, [r1, #58]	; 0x3a
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80032d4:	f891 01fa 	ldrbeq.w	r0, [r1, #506]	; 0x1fa
  }
}
 80032d8:	4770      	bx	lr
	...

080032dc <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 80032dc:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80032de:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80032e2:	f7fd fc35 	bl	8000b50 <HAL_PCD_SetAddress>
 80032e6:	2803      	cmp	r0, #3
 80032e8:	bf9a      	itte	ls
 80032ea:	4b02      	ldrls	r3, [pc, #8]	; (80032f4 <USBD_LL_SetUSBAddress+0x18>)
 80032ec:	5c18      	ldrbls	r0, [r3, r0]
 80032ee:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 80032f0:	bd08      	pop	{r3, pc}
 80032f2:	bf00      	nop
 80032f4:	0800367e 	.word	0x0800367e

080032f8 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 80032f8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 80032fa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80032fe:	f7fd fcb5 	bl	8000c6c <HAL_PCD_EP_Transmit>
 8003302:	2803      	cmp	r0, #3
 8003304:	bf9a      	itte	ls
 8003306:	4b02      	ldrls	r3, [pc, #8]	; (8003310 <USBD_LL_Transmit+0x18>)
 8003308:	5c18      	ldrbls	r0, [r3, r0]
 800330a:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;    
}
 800330c:	bd08      	pop	{r3, pc}
 800330e:	bf00      	nop
 8003310:	0800367e 	.word	0x0800367e

08003314 <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8003314:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003316:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800331a:	f7fd fc7c 	bl	8000c16 <HAL_PCD_EP_Receive>
 800331e:	2803      	cmp	r0, #3
 8003320:	bf9a      	itte	ls
 8003322:	4b02      	ldrls	r3, [pc, #8]	; (800332c <USBD_LL_PrepareReceive+0x18>)
 8003324:	5c18      	ldrbls	r0, [r3, r0]
 8003326:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003328:	bd08      	pop	{r3, pc}
 800332a:	bf00      	nop
 800332c:	0800367e 	.word	0x0800367e

08003330 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 8003330:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8003332:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003336:	f7fd fc91 	bl	8000c5c <HAL_PCD_EP_GetRxCount>
}
 800333a:	bd08      	pop	{r3, pc}

0800333c <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 800333c:	2312      	movs	r3, #18
 800333e:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8003340:	4800      	ldr	r0, [pc, #0]	; (8003344 <USBD_FS_DeviceDescriptor+0x8>)
 8003342:	4770      	bx	lr
 8003344:	20000144 	.word	0x20000144

08003348 <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8003348:	2304      	movs	r3, #4
 800334a:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 800334c:	4800      	ldr	r0, [pc, #0]	; (8003350 <USBD_FS_LangIDStrDescriptor+0x8>)
 800334e:	4770      	bx	lr
 8003350:	20000140 	.word	0x20000140

08003354 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003354:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8003356:	4c04      	ldr	r4, [pc, #16]	; (8003368 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8003358:	4804      	ldr	r0, [pc, #16]	; (800336c <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800335a:	460a      	mov	r2, r1
 800335c:	4621      	mov	r1, r4
 800335e:	f7ff fab8 	bl	80028d2 <USBD_GetString>
  return USBD_StrDesc;
}
 8003362:	4620      	mov	r0, r4
 8003364:	bd10      	pop	{r4, pc}
 8003366:	bf00      	nop
 8003368:	200008b8 	.word	0x200008b8
 800336c:	08003682 	.word	0x08003682

08003370 <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003370:	b510      	push	{r4, lr}
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8003372:	4c04      	ldr	r4, [pc, #16]	; (8003384 <USBD_FS_ProductStrDescriptor+0x14>)
 8003374:	4804      	ldr	r0, [pc, #16]	; (8003388 <USBD_FS_ProductStrDescriptor+0x18>)
 8003376:	460a      	mov	r2, r1
 8003378:	4621      	mov	r1, r4
 800337a:	f7ff faaa 	bl	80028d2 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 800337e:	4620      	mov	r0, r4
 8003380:	bd10      	pop	{r4, pc}
 8003382:	bf00      	nop
 8003384:	200008b8 	.word	0x200008b8
 8003388:	08003695 	.word	0x08003695

0800338c <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 800338c:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 800338e:	4c04      	ldr	r4, [pc, #16]	; (80033a0 <USBD_FS_SerialStrDescriptor+0x14>)
 8003390:	4804      	ldr	r0, [pc, #16]	; (80033a4 <USBD_FS_SerialStrDescriptor+0x18>)
 8003392:	460a      	mov	r2, r1
 8003394:	4621      	mov	r1, r4
 8003396:	f7ff fa9c 	bl	80028d2 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 800339a:	4620      	mov	r0, r4
 800339c:	bd10      	pop	{r4, pc}
 800339e:	bf00      	nop
 80033a0:	200008b8 	.word	0x200008b8
 80033a4:	080036ab 	.word	0x080036ab

080033a8 <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80033a8:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 80033aa:	4c04      	ldr	r4, [pc, #16]	; (80033bc <USBD_FS_ConfigStrDescriptor+0x14>)
 80033ac:	4804      	ldr	r0, [pc, #16]	; (80033c0 <USBD_FS_ConfigStrDescriptor+0x18>)
 80033ae:	460a      	mov	r2, r1
 80033b0:	4621      	mov	r1, r4
 80033b2:	f7ff fa8e 	bl	80028d2 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 80033b6:	4620      	mov	r0, r4
 80033b8:	bd10      	pop	{r4, pc}
 80033ba:	bf00      	nop
 80033bc:	200008b8 	.word	0x200008b8
 80033c0:	080036b8 	.word	0x080036b8

080033c4 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80033c4:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80033c6:	4c04      	ldr	r4, [pc, #16]	; (80033d8 <USBD_FS_InterfaceStrDescriptor+0x14>)
 80033c8:	4804      	ldr	r0, [pc, #16]	; (80033dc <USBD_FS_InterfaceStrDescriptor+0x18>)
 80033ca:	460a      	mov	r2, r1
 80033cc:	4621      	mov	r1, r4
 80033ce:	f7ff fa80 	bl	80028d2 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 80033d2:	4620      	mov	r0, r4
 80033d4:	bd10      	pop	{r4, pc}
 80033d6:	bf00      	nop
 80033d8:	200008b8 	.word	0x200008b8
 80033dc:	080036c3 	.word	0x080036c3

080033e0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 80033e0:	f8df d034 	ldr.w	sp, [pc, #52]	; 8003418 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80033e4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80033e6:	e003      	b.n	80033f0 <LoopCopyDataInit>

080033e8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80033e8:	4b0c      	ldr	r3, [pc, #48]	; (800341c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80033ea:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80033ec:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80033ee:	3104      	adds	r1, #4

080033f0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80033f0:	480b      	ldr	r0, [pc, #44]	; (8003420 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80033f2:	4b0c      	ldr	r3, [pc, #48]	; (8003424 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80033f4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80033f6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80033f8:	d3f6      	bcc.n	80033e8 <CopyDataInit>
  ldr  r2, =_sbss
 80033fa:	4a0b      	ldr	r2, [pc, #44]	; (8003428 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80033fc:	e002      	b.n	8003404 <LoopFillZerobss>

080033fe <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80033fe:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8003400:	f842 3b04 	str.w	r3, [r2], #4

08003404 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8003404:	4b09      	ldr	r3, [pc, #36]	; (800342c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8003406:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8003408:	d3f9      	bcc.n	80033fe <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800340a:	f7ff fdd3 	bl	8002fb4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800340e:	f000 f811 	bl	8003434 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8003412:	f7ff fc47 	bl	8002ca4 <main>
  bx  lr    
 8003416:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8003418:	20010000 	.word	0x20010000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800341c:	080036dc 	.word	0x080036dc
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8003420:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8003424:	200001bc 	.word	0x200001bc
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8003428:	200001bc 	.word	0x200001bc
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800342c:	20000abc 	.word	0x20000abc

08003430 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8003430:	e7fe      	b.n	8003430 <ADC_IRQHandler>
	...

08003434 <__libc_init_array>:
 8003434:	b570      	push	{r4, r5, r6, lr}
 8003436:	4b0e      	ldr	r3, [pc, #56]	; (8003470 <__libc_init_array+0x3c>)
 8003438:	4c0e      	ldr	r4, [pc, #56]	; (8003474 <__libc_init_array+0x40>)
 800343a:	1ae4      	subs	r4, r4, r3
 800343c:	10a4      	asrs	r4, r4, #2
 800343e:	2500      	movs	r5, #0
 8003440:	461e      	mov	r6, r3
 8003442:	42a5      	cmp	r5, r4
 8003444:	d004      	beq.n	8003450 <__libc_init_array+0x1c>
 8003446:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800344a:	4798      	blx	r3
 800344c:	3501      	adds	r5, #1
 800344e:	e7f8      	b.n	8003442 <__libc_init_array+0xe>
 8003450:	f000 f8fe 	bl	8003650 <_init>
 8003454:	4c08      	ldr	r4, [pc, #32]	; (8003478 <__libc_init_array+0x44>)
 8003456:	4b09      	ldr	r3, [pc, #36]	; (800347c <__libc_init_array+0x48>)
 8003458:	1ae4      	subs	r4, r4, r3
 800345a:	10a4      	asrs	r4, r4, #2
 800345c:	2500      	movs	r5, #0
 800345e:	461e      	mov	r6, r3
 8003460:	42a5      	cmp	r5, r4
 8003462:	d004      	beq.n	800346e <__libc_init_array+0x3a>
 8003464:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003468:	4798      	blx	r3
 800346a:	3501      	adds	r5, #1
 800346c:	e7f8      	b.n	8003460 <__libc_init_array+0x2c>
 800346e:	bd70      	pop	{r4, r5, r6, pc}
 8003470:	080036d4 	.word	0x080036d4
 8003474:	080036d4 	.word	0x080036d4
 8003478:	080036d8 	.word	0x080036d8
 800347c:	080036d4 	.word	0x080036d4

08003480 <malloc>:
 8003480:	4b02      	ldr	r3, [pc, #8]	; (800348c <malloc+0xc>)
 8003482:	4601      	mov	r1, r0
 8003484:	6818      	ldr	r0, [r3, #0]
 8003486:	f000 b865 	b.w	8003554 <_malloc_r>
 800348a:	bf00      	nop
 800348c:	200001b8 	.word	0x200001b8

08003490 <free>:
 8003490:	4b02      	ldr	r3, [pc, #8]	; (800349c <free+0xc>)
 8003492:	4601      	mov	r1, r0
 8003494:	6818      	ldr	r0, [r3, #0]
 8003496:	f000 b80f 	b.w	80034b8 <_free_r>
 800349a:	bf00      	nop
 800349c:	200001b8 	.word	0x200001b8

080034a0 <memcpy>:
 80034a0:	b510      	push	{r4, lr}
 80034a2:	1e43      	subs	r3, r0, #1
 80034a4:	440a      	add	r2, r1
 80034a6:	4291      	cmp	r1, r2
 80034a8:	d004      	beq.n	80034b4 <memcpy+0x14>
 80034aa:	f811 4b01 	ldrb.w	r4, [r1], #1
 80034ae:	f803 4f01 	strb.w	r4, [r3, #1]!
 80034b2:	e7f8      	b.n	80034a6 <memcpy+0x6>
 80034b4:	bd10      	pop	{r4, pc}
	...

080034b8 <_free_r>:
 80034b8:	b538      	push	{r3, r4, r5, lr}
 80034ba:	4605      	mov	r5, r0
 80034bc:	2900      	cmp	r1, #0
 80034be:	d046      	beq.n	800354e <_free_r+0x96>
 80034c0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80034c4:	1f0c      	subs	r4, r1, #4
 80034c6:	2b00      	cmp	r3, #0
 80034c8:	bfb8      	it	lt
 80034ca:	18e4      	addlt	r4, r4, r3
 80034cc:	f000 f8b0 	bl	8003630 <__malloc_lock>
 80034d0:	4a1f      	ldr	r2, [pc, #124]	; (8003550 <_free_r+0x98>)
 80034d2:	6813      	ldr	r3, [r2, #0]
 80034d4:	4611      	mov	r1, r2
 80034d6:	b913      	cbnz	r3, 80034de <_free_r+0x26>
 80034d8:	6063      	str	r3, [r4, #4]
 80034da:	6014      	str	r4, [r2, #0]
 80034dc:	e032      	b.n	8003544 <_free_r+0x8c>
 80034de:	42a3      	cmp	r3, r4
 80034e0:	d90e      	bls.n	8003500 <_free_r+0x48>
 80034e2:	6822      	ldr	r2, [r4, #0]
 80034e4:	18a0      	adds	r0, r4, r2
 80034e6:	4283      	cmp	r3, r0
 80034e8:	bf04      	itt	eq
 80034ea:	6818      	ldreq	r0, [r3, #0]
 80034ec:	685b      	ldreq	r3, [r3, #4]
 80034ee:	6063      	str	r3, [r4, #4]
 80034f0:	bf04      	itt	eq
 80034f2:	1812      	addeq	r2, r2, r0
 80034f4:	6022      	streq	r2, [r4, #0]
 80034f6:	600c      	str	r4, [r1, #0]
 80034f8:	e024      	b.n	8003544 <_free_r+0x8c>
 80034fa:	42a2      	cmp	r2, r4
 80034fc:	d803      	bhi.n	8003506 <_free_r+0x4e>
 80034fe:	4613      	mov	r3, r2
 8003500:	685a      	ldr	r2, [r3, #4]
 8003502:	2a00      	cmp	r2, #0
 8003504:	d1f9      	bne.n	80034fa <_free_r+0x42>
 8003506:	6818      	ldr	r0, [r3, #0]
 8003508:	1819      	adds	r1, r3, r0
 800350a:	42a1      	cmp	r1, r4
 800350c:	d10b      	bne.n	8003526 <_free_r+0x6e>
 800350e:	6821      	ldr	r1, [r4, #0]
 8003510:	4401      	add	r1, r0
 8003512:	1858      	adds	r0, r3, r1
 8003514:	4282      	cmp	r2, r0
 8003516:	6019      	str	r1, [r3, #0]
 8003518:	d114      	bne.n	8003544 <_free_r+0x8c>
 800351a:	6810      	ldr	r0, [r2, #0]
 800351c:	6852      	ldr	r2, [r2, #4]
 800351e:	605a      	str	r2, [r3, #4]
 8003520:	4401      	add	r1, r0
 8003522:	6019      	str	r1, [r3, #0]
 8003524:	e00e      	b.n	8003544 <_free_r+0x8c>
 8003526:	d902      	bls.n	800352e <_free_r+0x76>
 8003528:	230c      	movs	r3, #12
 800352a:	602b      	str	r3, [r5, #0]
 800352c:	e00a      	b.n	8003544 <_free_r+0x8c>
 800352e:	6821      	ldr	r1, [r4, #0]
 8003530:	1860      	adds	r0, r4, r1
 8003532:	4282      	cmp	r2, r0
 8003534:	bf04      	itt	eq
 8003536:	6810      	ldreq	r0, [r2, #0]
 8003538:	6852      	ldreq	r2, [r2, #4]
 800353a:	6062      	str	r2, [r4, #4]
 800353c:	bf04      	itt	eq
 800353e:	1809      	addeq	r1, r1, r0
 8003540:	6021      	streq	r1, [r4, #0]
 8003542:	605c      	str	r4, [r3, #4]
 8003544:	4628      	mov	r0, r5
 8003546:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800354a:	f000 b872 	b.w	8003632 <__malloc_unlock>
 800354e:	bd38      	pop	{r3, r4, r5, pc}
 8003550:	200001e0 	.word	0x200001e0

08003554 <_malloc_r>:
 8003554:	b570      	push	{r4, r5, r6, lr}
 8003556:	1ccd      	adds	r5, r1, #3
 8003558:	f025 0503 	bic.w	r5, r5, #3
 800355c:	3508      	adds	r5, #8
 800355e:	2d0c      	cmp	r5, #12
 8003560:	bf38      	it	cc
 8003562:	250c      	movcc	r5, #12
 8003564:	2d00      	cmp	r5, #0
 8003566:	4606      	mov	r6, r0
 8003568:	db01      	blt.n	800356e <_malloc_r+0x1a>
 800356a:	42a9      	cmp	r1, r5
 800356c:	d902      	bls.n	8003574 <_malloc_r+0x20>
 800356e:	230c      	movs	r3, #12
 8003570:	6033      	str	r3, [r6, #0]
 8003572:	e046      	b.n	8003602 <_malloc_r+0xae>
 8003574:	f000 f85c 	bl	8003630 <__malloc_lock>
 8003578:	4b23      	ldr	r3, [pc, #140]	; (8003608 <_malloc_r+0xb4>)
 800357a:	681c      	ldr	r4, [r3, #0]
 800357c:	461a      	mov	r2, r3
 800357e:	4621      	mov	r1, r4
 8003580:	b1a1      	cbz	r1, 80035ac <_malloc_r+0x58>
 8003582:	680b      	ldr	r3, [r1, #0]
 8003584:	1b5b      	subs	r3, r3, r5
 8003586:	d40e      	bmi.n	80035a6 <_malloc_r+0x52>
 8003588:	2b0b      	cmp	r3, #11
 800358a:	d903      	bls.n	8003594 <_malloc_r+0x40>
 800358c:	600b      	str	r3, [r1, #0]
 800358e:	18cc      	adds	r4, r1, r3
 8003590:	50cd      	str	r5, [r1, r3]
 8003592:	e01e      	b.n	80035d2 <_malloc_r+0x7e>
 8003594:	428c      	cmp	r4, r1
 8003596:	bf0d      	iteet	eq
 8003598:	6863      	ldreq	r3, [r4, #4]
 800359a:	684b      	ldrne	r3, [r1, #4]
 800359c:	6063      	strne	r3, [r4, #4]
 800359e:	6013      	streq	r3, [r2, #0]
 80035a0:	bf18      	it	ne
 80035a2:	460c      	movne	r4, r1
 80035a4:	e015      	b.n	80035d2 <_malloc_r+0x7e>
 80035a6:	460c      	mov	r4, r1
 80035a8:	6849      	ldr	r1, [r1, #4]
 80035aa:	e7e9      	b.n	8003580 <_malloc_r+0x2c>
 80035ac:	4c17      	ldr	r4, [pc, #92]	; (800360c <_malloc_r+0xb8>)
 80035ae:	6823      	ldr	r3, [r4, #0]
 80035b0:	b91b      	cbnz	r3, 80035ba <_malloc_r+0x66>
 80035b2:	4630      	mov	r0, r6
 80035b4:	f000 f82c 	bl	8003610 <_sbrk_r>
 80035b8:	6020      	str	r0, [r4, #0]
 80035ba:	4629      	mov	r1, r5
 80035bc:	4630      	mov	r0, r6
 80035be:	f000 f827 	bl	8003610 <_sbrk_r>
 80035c2:	1c43      	adds	r3, r0, #1
 80035c4:	d018      	beq.n	80035f8 <_malloc_r+0xa4>
 80035c6:	1cc4      	adds	r4, r0, #3
 80035c8:	f024 0403 	bic.w	r4, r4, #3
 80035cc:	42a0      	cmp	r0, r4
 80035ce:	d10d      	bne.n	80035ec <_malloc_r+0x98>
 80035d0:	6025      	str	r5, [r4, #0]
 80035d2:	4630      	mov	r0, r6
 80035d4:	f000 f82d 	bl	8003632 <__malloc_unlock>
 80035d8:	f104 000b 	add.w	r0, r4, #11
 80035dc:	1d23      	adds	r3, r4, #4
 80035de:	f020 0007 	bic.w	r0, r0, #7
 80035e2:	1ac3      	subs	r3, r0, r3
 80035e4:	d00e      	beq.n	8003604 <_malloc_r+0xb0>
 80035e6:	425a      	negs	r2, r3
 80035e8:	50e2      	str	r2, [r4, r3]
 80035ea:	bd70      	pop	{r4, r5, r6, pc}
 80035ec:	1a21      	subs	r1, r4, r0
 80035ee:	4630      	mov	r0, r6
 80035f0:	f000 f80e 	bl	8003610 <_sbrk_r>
 80035f4:	3001      	adds	r0, #1
 80035f6:	d1eb      	bne.n	80035d0 <_malloc_r+0x7c>
 80035f8:	230c      	movs	r3, #12
 80035fa:	6033      	str	r3, [r6, #0]
 80035fc:	4630      	mov	r0, r6
 80035fe:	f000 f818 	bl	8003632 <__malloc_unlock>
 8003602:	2000      	movs	r0, #0
 8003604:	bd70      	pop	{r4, r5, r6, pc}
 8003606:	bf00      	nop
 8003608:	200001e0 	.word	0x200001e0
 800360c:	200001dc 	.word	0x200001dc

08003610 <_sbrk_r>:
 8003610:	b538      	push	{r3, r4, r5, lr}
 8003612:	4c06      	ldr	r4, [pc, #24]	; (800362c <_sbrk_r+0x1c>)
 8003614:	2300      	movs	r3, #0
 8003616:	4605      	mov	r5, r0
 8003618:	4608      	mov	r0, r1
 800361a:	6023      	str	r3, [r4, #0]
 800361c:	f000 f80a 	bl	8003634 <_sbrk>
 8003620:	1c43      	adds	r3, r0, #1
 8003622:	d102      	bne.n	800362a <_sbrk_r+0x1a>
 8003624:	6823      	ldr	r3, [r4, #0]
 8003626:	b103      	cbz	r3, 800362a <_sbrk_r+0x1a>
 8003628:	602b      	str	r3, [r5, #0]
 800362a:	bd38      	pop	{r3, r4, r5, pc}
 800362c:	20000ab8 	.word	0x20000ab8

08003630 <__malloc_lock>:
 8003630:	4770      	bx	lr

08003632 <__malloc_unlock>:
 8003632:	4770      	bx	lr

08003634 <_sbrk>:
 8003634:	4b04      	ldr	r3, [pc, #16]	; (8003648 <_sbrk+0x14>)
 8003636:	6819      	ldr	r1, [r3, #0]
 8003638:	4602      	mov	r2, r0
 800363a:	b909      	cbnz	r1, 8003640 <_sbrk+0xc>
 800363c:	4903      	ldr	r1, [pc, #12]	; (800364c <_sbrk+0x18>)
 800363e:	6019      	str	r1, [r3, #0]
 8003640:	6818      	ldr	r0, [r3, #0]
 8003642:	4402      	add	r2, r0
 8003644:	601a      	str	r2, [r3, #0]
 8003646:	4770      	bx	lr
 8003648:	200001e4 	.word	0x200001e4
 800364c:	20000abc 	.word	0x20000abc

08003650 <_init>:
 8003650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003652:	bf00      	nop
 8003654:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003656:	bc08      	pop	{r3}
 8003658:	469e      	mov	lr, r3
 800365a:	4770      	bx	lr

0800365c <_fini>:
 800365c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800365e:	bf00      	nop
 8003660:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003662:	bc08      	pop	{r3}
 8003664:	469e      	mov	lr, r3
 8003666:	4770      	bx	lr
